+++
collection = false
order = 13
soruces = [
"https://lwn.net/Articles/305782/",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-24"
tags = [

]
categories = [

]
series = [

]
title = "RCU בקצרה"
+++

RCU הוא מנגנון מורכב והוא יכול בקלות להיות חומר למספר מאמרים, ולכן אני כרגע אסביר עליו בקצרה (ובתקווה אכתוב עליו מאמר יותר מעמיק בהמשך)

RCU ראשי תיבות של "Read-Copy-Update", הוא מנגנון סנכרון המשמש בקרנל לניהול גישה במקביל למבני נתונים ללא צורך במנעולים שעלולים להכניס contention ו-performance bottlenecks.

המנגנון RCU מאפשר ל-thread-ים מרובים לקרוא מבנה נתונים במקביל ללא נעילה, ועדכונים למבנה הנתונים מבוצעים באמצעות מנגנון המבטיח עקביות. RCU מתאים במיוחד לתרחישים שבהם הקריאות תכופות הרבה יותר מאשר כתיבה.

RCU שונה ממנגנוני סינכורון נפוצים, הוא לא דורש אובייקט מנעול למשתמש אלה הוא גלובלי ופועל כלפי כלל המערכת.
## צד קריאה וצד וכתיבה
ה-RCU מפשט את הבעיה של סנכון בין מספר גורמים על ידי שהוא עושה מספר חלוקות למקרים:
ב-RCU יש 2 צדדים: הצד הכותב והצד הקורא, הצד הקורא צריך להיות מהיר מאוד (יש מקרים שהוא יכול להיות עם 0 תקורה) והצד הכותב הוא כבר מטפל בכל הבעיות (כמעט) והוא כבר איטי יותר.

 הצד הכותב גם בתוכו מחלק את הפעולות שהוא צריך לעשות ל-2 שלבים עקריים:
 - שלב ההסרה (removal): מסיר או מעדכן הפניות לפריטי נתונים בתוך מבנה נתונים.
 - שלב הטיוב (reclamation): השלב שבו צריך לשחרר את הזיכרון הישן.

בצורה הזו ניתן לעשות את שלב ההסרה במקביל לקוראים (המגנון מבטיח שהקוראים יראו זיכרון שלם אבל לא בטוח עדכני - כלומר לא בטוח איזה מידע יגיע לקורא שפועל בזמן העדכון) ורק את שלב השחרור לעשות לאחר שאנחנו בטוחים שכבר אף אחד לא יגש לזיכרון הישן ולכן צריך לחכות שכל הקוראים האפשריים יסימו את הקריאה שלהם.
הרעיון המרכזי ב-RCU הוא שיחרור זיכרון בצורה דחויה.

הזמן בו הכותב מחכה מהרגע שהוא מעדכן את המידע לרגע שהוא יכול לשחרר את המידע הישן נקרא `grace period` (תקופת חסד) וזה הזמן שבו אנחנו מאפשרים לכל הקוראים לסיים את הגישה לזיכרון הישן ולאחר תקופת החסד ניתן לשחרר את הזיכרון הזה כי מובטח שאין אף אחד שיגש אליו.

המנגנון RCU מבטיח קוהרנטיות לגישות קריאה על ידי שמירה על גרסאות מרובות של מבני נתונים והבטחה שהן לא משוחררות עד להשלמת כל הקטעים הקריטיים הקיימים בצד הקריאה.

המנגנון RCU הוא דרך להמתין עד שקטעים קריטיים בצד הקריאה של RCU יסתיימו לחלוטין, כולל פעולות זיכרון המבוצעות על ידי אותם מקטעים קריטיים.


RCU פועל על פי העיקרון של לאפשר לקוראים להמשיך מבלי לחסום או לרכוש מנעולים, תוך הבטחה שעדכונים מכותבים אינם מציגים חוסר עקביות. זה עושה את זה יעיל במיוחד בתרחישים שבהם יש פעולות קריאה תכופות ופעולות כתיבה נדירות.
## תפקידים

קורא (read): קוראים ב-RCU יכולים לגשת בבטחה למבנה הנתונים המשותף מבלי לרכוש מנעולים. הם מסתמכים על העובדה שמבנה הנתונים נשאר יציב לאורך כל הגישה שלהם. עם זאת, חשוב לציין שקוראים עשויים לראות את הגרסה הישנה של הנתונים או את הגרסה המעודכנת החדשה, בהתאם להתקדמות העדכונים.

עדכון (update): כאשר עדכון צריך לשנות את מבנה הנתונים המשותף, הוא יוצר עותק חדש של הנתונים. זה נעשה כדי להבטיח שהקריאה השוטפת תוכל להמשיך ללא הפרעה בגרסה הישנה. לאחר מכן, המעדכן מבצע את השינויים הדרושים בעותק החדש, שהופך לגרסה ה"נוכחית" של מבנה הנתונים לאחר השלמת העדכון.

טיוב (Reclaimer): תפקידו של Reclaimer הוא לשחרר (deallocate) את הגרסה הישנה של מבנה הנתונים ברגע שבטוח שאף קוראים לא ניגשים אליו. RCU מספק מנגנונים כדי להבטיח שכל הקוראים הקיימים השלימו את הגישה שלהם לגרסה הישנה לפני שהיא משוחררת.

## ספירת הפניות
שימוש נפוץ של RCU הוא עם ספירת הפניות, RCU משתמשת לעתים קרובות בטכניקות ספירת הפניות כדי לעקוב אחר השימוש במבנה הנתונים. זה מבטיח שהגרסה הישנה לא תשוחרר בטרם עת בזמן שעדיין יש קוראים שניגשים אליה.
גם באובייקט ה-dentry זאת המטרה של השימוש ב-rcu (יחד עם השדה `d_rcu`).

## מחסומי זיכרון 
מחסומי זיכרון חיוניים ב-RCU מכיוון שהם אוכפים את ערבויות הסנכרון והסידור (memory order) הנדרש. הם מונעים מהקומפיילר,והמעבד לבצע אופטימיזציה או סדר מחדש של פעולות הזיכרון בדרכים שעלולות להוביל להתנהגות לא נכונה או לתצוגות לא עקביות של מבנה הנתונים.

על ידי ניצול יעיל של מחסומי זיכרון, RCU מבטיח שהקוראים יראו תצוגה עקבית של מבנה הנתונים המשותף, או הגרסה הישנה או הגרסה החדשה, בהתאם להתקדמות העדכונים. הוא מאפשר גישת צד קריאה יעילה ולא חוסמת תוך שמירה על תקינות וסנכרון עם עדכוני צד כתיבה בקרנל.

מחסומי זיכרון ב-RCU מספקים ערובות סידור לפעולות זיכרון, מונעות סידור מחדש לא רצוי או אופטימיזציות שעלולות להוביל לתצוגות לא עקביות של מבנה הנתונים המשותף. הם מבטיחים ששינויים שנעשו על ידי כותבים יהיו גלויים לקוראים בסדר הנכון ובזמן המתאים.

חשוב לציין שפונקציות מחסום הזיכרון הספציפיות המשמשות ב-RCU עשויות להשתנות בהתאם לארכיטקטורה ופרטי היישום של קרנל. גרסאות שונות של RCU וחלקים שונים של הקרנל עשויים להשתמש בפונקציות ספציפיות של מחסום זיכרון או בפקודות מאקרו המותאמות לדרישות שלהם.

## קטע קריטי ב-RCU
קטע קריטי של צד הקריאה מתחיל ב-`rcu_read_lock` ומסתיים ב-`rcu_read_unlock` ויכולים להיות מקוננים, הקטע הקריטי בצד הקריאה חייב להיות מאוד מהיר ולכן אסור לעשות פעולות שחוסמות (כמו תזמון מחדש, אבל כן מותר למשל להשתמש ב-spinlock כי גם הוא נועד לשימושים מהירים וקצרים),  
 אם כי קרנלים שנבנו עם `CONFIG_PREEMPT_RCU` יכולים להקדים את החלקים הקריטיים בצד הקריאה של RCU. כל מבנה נתונים מוגן RCU שאליו ניגש במהלך קטע קריטי בצד הקריאה של RCU מובטח שיישאר ללא שינוי לכל משך הזמן המלא של אותו קטע קריטי. ניתן להשתמש ב-reference count בשילוב עם RCU כדי לשמור על הפניות לטווח ארוך יותר למבני נתונים.

החזקת הפניה מקטע קריטי בצד הקריאה של ה-RCU למשנהו אינה חוקית באותה מידה כמו החזקת הפניה מקטע קריטי מבוסס מנעול אחד לאחר! באופן דומה, שימוש בהפניה מחוץ לסעיף הקריטי בו הוא נרכש אינו חוקי בדיוק כמו לעשות זאת עם נעילה רגילה.

## צד הכתיבה
הפונקציה `synchronize_rcu` מסמנת את סיומו של קוד המעדכן ותחילתו של קוד reclaimer.
צריך להשתמש ב-`synchronize_rcu()` כדי להבטיח שכל הקוראים שיש להם הפניות למבנה הישן ישלימו לפני שחרור המבנה הישן.
הפונקציה `synchronize_rcu` מחכה עד שכל הקטעים הקריטים שהתחילו מלפני הקריאה לפונקציה הסיימו ולכן היא חוסמת ויכולה לגרום לעיכוב בצד העדכון.
אם יש צורך גם בצד כתיבה מהיר ולא חוסם אז ניתן להשתמש ב-callback על ידי הפונקציה `call_rcu` והפונקצית callback תרוץ בסוף תקופת החסד בצורה אסינכרונית.
