+++
collection = false
order = 2
Sources = [
"https://en.wikipedia.org/wiki/Slab_allocation",
"https://www.kernel.org/doc/gorman/html/understand/understand011.html",
"https://www.kernel.org/doc/Documentation/sysctl/vm.txt",
"https://lwn.net/Articles/890025/",
"https://lwn.net/Articles/545119/",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-24"
tags = [

]
categories = [

]
series = [

]
title = "תיאור כללי בקצרה"
+++



### מה זה Dcache
ה-dcache (קיצור של directory cache) הוא רכיב בשכבת מערכת הקבצים הווירטואלית (VFS). זהו cache המאחסן מידע על directory entries או בקיצור dentries.

ה-dcache מספק מנגנון חיפוש מהיר לגישה לקבצים ולתיקיות לפי שמם.

כאשר ניגשים לקובץ או תיקייה, הקרנל מחפש ב-dcache כדי למצוא את ה-dentry המתאים. אם ה-dentry נמצא ב-cache, הקרנל יכול לאחזר במהירות את ה-metadata המשויכים ולבצע את הפעולה המבוקשת. מנגנון ה-caching זה משפר את ביצועי מערכת הקבצים על ידי הפחתת הצורך לבצע פעולות io יקרות לדיסק  עבור כל גישה לקובץ.

ה-dcache מאורגן במספר דרכים על מנת לאפשר גישה מהירה לנתונים:

- ה-dcache מאורגן כטבלת hash, כאשר כל ערך מתאים לערך תיקייה ייחודי. טבלת ה-hash מאפשרת חיפוש יעיל על סמך שם הערך. כאשר נוצרת dentry חדש או גישה קיימת, היא מתווספת ל-dcache או נחפשת בו.

- ובמקביל מבני dentries מאורגנים במבנה דמוי עץ היררכי התואם את מבנה התיקיות של מערכת הקבצים. מבנה זה מאפשר מעבר וחיפוש יעילים של תיקיות וקבצים, מה שמאפשר לקרנל לאתר ולגשת לקבצים במהירות.

ה-dcache אחראי גם לשמירה על עקביות וסנכרון. מנעולים וסמפורים שונים משמשים כדי להגן על שלמות ה-dcache ולהבטיח שפעולות במקביל על אותו dentry או תיקייה מסודרת כהלכה.

בסך הכל, ה-dcache ממלא תפקיד מכריע בפעולות מערכת הקבצים של הקרנל על ידי מתן מנגנון שמירה ב-cache לחיפוש יעיל וגישה לערכי תיקייה, שיפור הביצועים של פעולות מערכת הקבצים.

התפקיד שלו הוא לשמור על תמונה עדכנית של כל מערכת הקבצים על ה-ram, כלומר הוא שומר בעזרת אובייקטי dentry את ההרכייה והיחסים בין תיקיות (directories) וקבצים (files) ויוצר עץ שבעזרתו ניתן לגשת לקבצים בתיקיות בצורה מהירה (יחסית לגישה לדיסק).

### מה זה Dentry
ה-dentry מתייחס למבנה נתונים המייצג ערך כניסה בתיקייה. זה קיצור של directory entry. מבנה ה-dentry משמש לייצוג וניהול תיקיות וקבצים בתוך מערכת הקבצים.

כל dentry מכיל מידע על קובץ או תיקייה ספציפיים, כגון השם שלו, ה-inode שלו (המאחסן metadata על הקובץ או התיקייה) ותכונות שונות אחרות. מבנה ה-dentry נוצר ומתוחזק על ידי הקרנל כדי לספק גישה יעילה לאובייקטים של מערכת הקבצים.

dentries חיוניים לפעולות שונות של מערכת הקבצים, כגון יצירת קבצים, מחיקה, שינוי שם וריזלוב (resolution) של נתיבים (path). הם גם מעורבים במנגנוני אחסון ב-cache של מערכות קבצים כדי להאיץ את הגישה לקבצים ותיקיות בשימוש תכוף.

באופן כללי, dentries ממלאות תפקיד מכריע בתשתית מערכת הקבצים של קרנל, מה שמאפשר ניהול יעיל של קבצים ותיקיות ומספק את הבסיס לפעולות מערכת קבצים מבוססות נתיבים.

ה-dentry הוא אובייקט שמייצג קשר בין inode לבין תיקייה , והוא מקשר ביניהם על ידי השם של הקובץ. ה-dentry משמש לגישה לכל קובץ בזמן תהליך החיפוש (lookup) של קובץ היעד.

בזמן lookup כל רכיב ב-path צריך שיהיה לו dentry משלו והוא משמש לחיפוש של המשך הרכיבים ב-path.
למשל בחיפוש של `tmp/hello/` יווצרו 3 dentries חדשות: root, tmp, hello. (הכוונה של root היא תקיית השורש של כל המערכת קבצים).

אפשר לראות עליו פרטים עליו בקובץ `proc/slabinfo/`:

```sh {linenos=inline}
sudo grep "dentry" /proc/slabinfo
```



### Negative Dentry
יש תפקיד חשוב ל-dentry גם בהאצה של lookup לקבצים שלא קיימים.

dentries שליליות נשמרות ב-dentry cache כדי לתעד את העובדה ששם ספציפי אינו קיים.
כדי לראות דוגמה למה צריך dentries שליליות, הפעל כל תוכנית פשוטה תחת מעקב וצפה בכמה syscall-ים חוזרים עם `ENOENT`.

לדוגמה הרצה של `ls`:
```sh {linenos=inline}
 strace ls README 2>&1| grep "ENOENT"
```


כדי קצת יותר לעומק על negative dentry צריך להסביר משהו קטן  לפני זה :
כל dentry מכיל שדה `d_inode` שהוא מצביע ל-inode של הקובץ, הוא יכול להכיל בשדה גם `NULL`.
אם ה-d_inode מצביע ל-inode קיים אז הוא נקרא positive, אחרת הוא negative.
בתחילת חייו של ה-dentry הוא נוצר לפני שהוא מחובר ל-inode ולכן הוא מתחיל כ-negative.
dentry חיובי יכול להפוך לשלילי במהלך חייו, למשל כשקובץ נמחק, או מערכת קבצים מנותקת (umount).

תהליך ה-lookup מנסה לחפש במורד העץ את הקובץ הרצוי ובמהלך החיפוש הוא יוצר בתחילה dentry ואחרי זה הוא מנסה לחפש אם קיים לו inode מתאים בתקיית האבא לכל רכיב ב-path, אם הוא מוצא inode הוא ממשיך בתהליך, ואם הוא לא מוצא אז חוזרת שגיאה, אבל הוא עדיין משאיר (לרוב) את ה-dentry שנוצרה ב-dcache, זה נעשה בגלל שהרבה פעמים נעשה חיפוש של קובץ שלא קיים מספר פעמים ובמקום כל פעם לנסות לחפש אותו מחדש בדיסק, אז אפשר לחסוך את זה ומחפשים את היעד ב- dcache ואם מגיעים ל-dentry השלילית אז יודעים שהקובץ לא קיים.

יש הרבה זמן בעיה עם denries שליליות ([למעלה מ-20 שנים](https://lwn.net/Articles/890025/)), הבעיה היא לא בעיה רק שלהם אלה בעיה כללית של ניהול cache, הבעיה היא שכל פעם שיש lookup על dentry לא קיים נוצר dentry שלילית, וזה לפעמים נכון לשמור אות כי יש חיפושים חוזרים, אבל לפעמים זה בזבוז כי לא נעשה חיפוש עוד של אותו dentry והוא סתם תופס מקום בזכרון, נעשו דיונים בנשוא מספר פעמים אבל לא יצא מהם תשובה לאיך לשפר את המצב.

### Dentry & links
 צריך לזכור שבלינוקס כל inode יכול לשמש למספר קבצים שונים, התוכן הוא אותו תוכן אבל הקובץ עצמו יושב במקומות שונים במערכת הקבצים, כלומר יכול להיות מספר dentries שמכילים את מצביע לאותו inode וזה מצב רגיל לגמרי, זה נוצר עם שימוש במספר לינקים לקובץ.

אבל יש קבצים מסויימים שאסור שיהיה להם מספר לינקים ואלו הם תיקיות, יש איסור שנוצר בגלל שיש עם הרעיון הזה מספר בעיות:

-  יש שימוש באלגוריתמים בקרנל שעושים סריקות וחיפוש בעץ והמצב של מספר כניסות לאותו תיקייה הוא בעייתי להם, כי זה כבר לא מבנה של עץ והוא יכול להפוך לגרף לא מכוון שאפשר לחזור למקומות שכבר סרקו.
  
- כשרוצים לחזור אחורה לתקיית אב משתמשים ב- `..` (dotdot) אבל כשיש מספר כניסות לכל תיקייה כבר לא ברור מי זה האבא שצריך להגיע אליו כשחוזרים אחורה.

- ריבוי לינקים ל-directories שובר את הכללים שהקרנל קבע לעצמו וזה יכול לגרום [לבעיות נעילה כמו deadlock](https://lwn.net/Articles/545119/).

יש עוד בעיות שנגרמות מהרעיון הזה, וזה אפשרי לפתור כנראה את הבעיות ולאפשר ריבוי לינקים לתיקיות אבל זה לא דבר ממש חשוב לדעת מעצבי הקרנל אז פשוט לא נוגעים בזה.

### dentry & slab
כל dentry מוקצה מתוך ה-slab allocator ומנוהל בעזרתו בצורה של lru (קיצור של least recently used).
אני לא ארחיב על ה-slab allocator  יותר מידי כי מגיע לו מאמר נפרד, אבל אסביר בקצרה עליו.

ה-slab allocator הוא שכבת עזר להקצאה וניהול של אובייקטים (structs).
הוא משתמש בשמירה של זיכרון מוקצה המכיל אובייקט נתונים מסוג מסוים לשימוש חוזר בהקצאות עוקבות של אובייקטים מאותו סוג. זה מקביל ל-pool אובייקטים בזיכרון.

ה-slab allocator עוזר למתכנת כדי שיוכל להקצות בצורה נוחה ויעלה יותר במקום להשתמש ישירות במנגנון הקצאת page-ים וה-buddy system.

הוא מאפשר:
- הקצאת בלוקים קטנים של זיכרון כדי לסייע בביטול פיצול פנימי שייגרם אחרת על ידי ה-buddy system.
- שמירה ב-cache של אובייקטים נפוצים כך שהמערכת לא מבזבזת זמן בהקצאה, אתחול והשמדת אובייקטים.
- ניצול טוב יותר של cache החומרה על ידי יישור אובייקטים ל-cache L1 או L2.



#### drop caches
קיים `sysctl` ניתן לקרוא לו על ידי הקובץ  `/proc/sys/vm/drop_caches`.
ניתן לכתוב לקובץ  `2` וזה מפעיל ניקוי של slab ללא שימוש:
לקריאה נוספת בדקו ב-`man proc` וגם אפשר [לקרוא בתיעוד הקרנל באתר](https://www.kernel.org/doc/Documentation/sysctl/vm.txt)
את המימוש של ה-`sysctl` הזה אפשר למצוא ב-`fs/drop_caches.c`.




