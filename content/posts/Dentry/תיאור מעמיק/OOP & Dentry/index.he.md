+++
collection = false
order = 6
Sources = [
"https://lwn.net/Articles/444910/",
"https://lwn.net/Articles/446317/",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-24"
tags = [

]
categories = [

]
series = [

]
title = "OOP & Dentry"
+++

למרות הקרנל כתוב בשפות תכנות לא מונחות עצמים זה לא מונע ממנו להשתמש בתבניות של OOP לפי הצורך.
בקרנל יש הרבה שימושים לדפוס oop ואחד המקומות הברורים לזה הוא ב-VFS ובפרט ב-dcache. בחלק הזה אסביר על הדפוס oop במימוש של ה-dentry.

# הסבר כללי על OOP בקרנל

## הורשת נתונים

### הרחבה באמצעות `unions`
הגישה הזאת, שהיא כנראה הברורה ביותר אך גם הפחות גמישה, היא להכריז על union כמרכיב אחד של המבנה המשותף, ולגבי כל יישום, להכריז על כניסה באותו union עם תחומים נוספים שהיישום המסוים צריך.
גישה זו להורשת נתונים היא פשוטה וישירה, אך היא גם מגושמת במקצת.
יש עם הגישה הזאת 2 בעיות עקריות:
1. זה מכוער, יכול להיות מצב שיש מספר גדול של סוגי אובייקטים שיורשים מאובייקט מסויים וכל אחד מהם יצטרך להוסיף עוד שדה ל-union.
2. המימוש הזה מחייב את כל סוגי האובייקטים היורשים לשאת בשדות של אובייקטים יורשים אחרים גם אם הם לא צריכים את השדה, זה בעיה אמיתית בגלל שזה תופס עוד זיכרון מיותר.

### Embedded structures
במקום שהמבנה הפרטי יהיה מוטבע במבנה הנתונים המשותף, מבנה הנתונים המשותף מוטבע  (embedded) כעת במבנה הפרטי.
זה מונע בצורה מסודרת את שתי הבעיות עם unions, כעת למשל כל מערכת קבצים צריכה רק להקצות זיכרון לאחסון מבנה משלה ללא כל צורך לדעת דבר על מה שמערכות קבצים אחרות עשויות להזדקק לו.

הרבה פעמים ה-caller צריך להעביר ל-method את האובייקט שעליה היא צרכה לפעול, המימוש של מידע שהוא embedded ב-struct פותר את הבעיה עם המאקרו `container_of` כדי לבצע את אריתמטיקה המצביע הנחוצה, והמאקרו מאפשר למפות ממבנה נתונים embedded למבנה שבו הוא מוטבע בו.

למשל ב-`dentry` בשדה `d_u` שהוא union וזה בא לידי ביטוי בשחרור ה-dentry, בגלל שה-dentry משתמש ב-rcu אז הוא צריך להכיל שדה `rcu_head`, הדפוס הזה הוא כמו הורשה שה-dentry יורש ממחלקת אב מסויימת את rcu_head על מנת לאפשר שימוש של rcu.

השדה `d_u`:
```c {linenos=inline}
struct dentry {
...
	union {
		struct hlist_node d_alias;	/* inode alias list */
		struct hlist_bl_node d_in_lookup_hash;	/* only for in-lookup ones */
	 	struct rcu_head d_rcu;
	} d_u;
} __randomize_layout;

```

הפונקציה `__d_free`:
```c {linenos=inline}
static void __d_free(struct rcu_head *head)
{
	struct dentry *dentry = container_of(head, struct dentry, d_u.d_rcu);

	kmem_cache_free(dentry_cache, dentry); 
}
```

כאן אפשר לראות שעל מנת לשחרר את האובייקט צריך להשתמש במעקף כי יש לנו רק מצביע לשדה הפנימי head שהוא בתוך ה-dentry, וכדי להגיע לאובייקט עצמו צריך את `container_of`.


## methods
### vtables
שימוש של methods ספציפי לאובייקט מסויים הוא נפוץ, ובהרבה שפות תכנות הוא ממומש בעזרת הרעיון של vtables (קיצור של `virtual function table`), יש לזה מספר סיבות:

הרבה פעמים הערכים בשדות של אובייקט משתנים אבל ה-methods נשארות קבועות ולכן זה רעיון טוב לאחד אותם למבנה אחד שהוא יכול להיות אחיד כלפי כולם ואז אפשר שיתקיים רק מופע אחד שלו בזכרון וכל אחד מהמופעים של האובייקט יכילו מצביע אליו וככה יש אפשרות לחסוך הרבה מקום בזיכרון אם אובייקט מרכזי מרכז בעצמו את כל ה-methods שאוביקטי בנים צריכים אם כולם בעלי אותם methods, למשל לרוב במערכת קבצים ה-methods של כל אובייקטי ה-`dentry` יצרכו את אותה השוואה ולכן צריכים את אותו מימוש של `d_compare` ולכן היה אפשר להעביר את המצביע הזה ב-vtable של ה-dentry אל ה-vtable של ה-super_block אבל חלק מהמערכות קבצים צריכות השוואה שונה כלפי `dentry` שונה ולכן צריך "לבזבז" עם הרבה שכפולים של המידע.

עוד יתרון שה-vtable נותן הוא גמישות, בדרך הזו כל משתמש של האובייקט יכול להחליט איזה methods הוא צריך ואפילו זה יכול לאפשר method שונה כלפי כל מופע של סוג האובייקט (במקרה ההפוך לדוגמה הראשונה - כאן במקום לאחד את כל ה-method לכל המופעים עושים את הפעולה ההפוכה).


### NULL function pointers

בחלק המקרים מצביעי פונקציות מסוימים בטבלאות vtables מסוימות רשאיות להיות NULL.
לרוב ה-caller ל-methods הללו מכיל בדרך כלל בדיקה של המצביע שהוא NULL.
האפשרות למצביע NULL נותנת יישום default ל-method לפעמים, וגם הוא מאפשר למימושים שונים להשתמש ב-method שונים לפי הצורך, כלומר אם מערכת קבצים מסויימת צריכה method מסויים ומערכת קבצים אחרת לא אז רק זו שעושה שימוש ב-method תמלא את המצביע והשנייה תשאיר אותה NULL.



### `void` pointers
הרחבת סוג נתונים באמצעות מצביע להרחבה פרטית.
גישה זו התייחסה לשתי הבעיות עם unions, שכן אין צורך בשינויים בהצהרות משותפות וכל מימוש של סוג אובייקט משתמש רק בשטח הדרוש לו.
חסרון גדול של הגישה הזאת היא שיש צורך בגישת זיכרון נוספת של dereference כדי לגשת למבנה הפרטי מהמבנה המשותף.
זה מצריך הרבה הפניות זיכרון נוספות, או שזה דורש להחזיק את הכתובת של המבנה הפרטי ברגיסטר מה שמגביר את הלחץ רגיסטרים.

בעיה מסוימת היא שכאשר אתה מסתכל על מצביע void, כמו להסתכל על goto, אתה לא באמת יודע על מה הוא מצביע. מצביע void בשם private הוא אפילו יותר גרוע, כמעט חסר משמעות מבלי לקרוא הרבה הקשר.

ניתן לראות את השימוש בעוגן מוטבע כמו struct list_head כסגנון של ירושה שכן המבנה המכיל אותו "הוא-" איבר ברשימה בזכות ירושה מ-struct list_head אבל כנראה שעדיף לחשוב על סוג זה של הטבעה יותר כמו סגנון "mixin" של ירושה.

דוגמה למצביע void ב-dentry ניתן לראות בשדה `void *d_fsdata`.





# OOP & Dentry
### ה-methods של ה-Dentry
כמו בהרבה מקומות בקרנל, גם באובייקטים של ה-dcache יש שימוש של "OOP" ב-C כאן משתמשים במימוש של methods לאובייקטי ה-dentry, כל מערכת קבצים יכולה ליצור את ה-methods שהיא צריכה וזה יוצר התנהגות של overload שכאן היא מתאימה ונוחה, להרבה מה-methods יש מימוש קיים כברירת מחדל או שאין ופשוט אין קריאות לאותן methods.



#### d_set_d_op
לפני שאסביר על ה-methods עצמן אני אסביר רגע על ה-`d_set_d_op` והתרומה שלו ל-OOP של ה-dentry.
כדי לחבר methods ל-dentry משתמשים במבנה `dentry_operations` שהוא struct שמכיל מצביעים לפונקציות של ה-dentry שמערכת הקבצים צריכה. הרעיון הזה נפוץ בהרבה מקרים כשצריך ליצור התנהגות כזאת, למשל קיים אותו דבר כלפי ה-`struct inode`, לו יש את ה-`inode_operations`.
כערך ברירת מחדל ה-`dentry_operations` מכיל במקום מצביעים ערכי `NULL` והרעיון הזה קצת בעייתי כי כל פעם לפני שקוראים לפונקציה מסויימת צריך לבדוק את הערך של המצביע ואז לקרוא לפונקציה רק אם היא שונה מ-`NULL`, במקרים רבים זה בסדר לעשות את זה, אבל כאן יש בעיה כי חייבים שהפונקציות יהיו מעוד מהירות ויעלות בגלל שמשתמשים במערכת הזאת הרבה מאוד, ולכן צריך לעשות כמה שיותר אופטימיזציות. בגלל זה הכניסו דגלים ל-dentry שמספרים איזה methods קיימות ואז אפשר ככה לבדוק רק את הדגל במקום לבדוק את המבציע, מכיוון ששדה הדגל צפוי להיות בכל מקרה ב-cache, ולעתים קרובות לא יהיה צורך כלל במבנה `dentry_operations`, הדבר מונע שליפת זיכרון ב-hot path.
אז התפקיד של הפונקציה `d_set_d_op` היא לחבר `dentry_operations` ל-dentry והיא מדליקה את הדגלים הרצויים.

---
