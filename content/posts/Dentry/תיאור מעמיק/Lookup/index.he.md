+++
collection = false
order = 4
Sources = [
"https://lwn.net/Articles/419811/",
"https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html",
"https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#a-walk-among-the-symlinks",
"https://lwn.net/Articles/685108/",
"https://zhuanlan.zhihu.com/p/457005511",
"https://lwn.net/Articles/692546/",

]
authors = [
"Michael Shalitin",

]
math = true
date = "2025-01-24"
tags = [

]
categories = [

]
series = [

]
title = "Lookup"
+++



# תהליך ה-Lookup
התהליך של חיפוש הוא תהליך מורכב והוא בעצמו דורש מאמר נפרד, אבל אסביר עליו בקצרה כאן רק כדי לתת רקע כללי:

## 2 סוגי walking
תהליך החיפוש משומש הרבה מאוד פעמים ולכן הוא חייב להיות מאוד יציב (כלומר לתת תוצאה נכונה) ובו זמנית גם מאוד מהיר.
2 הגישות סותרות זו את זו בגלל שאם רוצים משהו יציב אז הוא צריך לעשות הרבה בדיקות, ולכן הפרידו את תהליך ה-lookup ל-2 מקרים:

- `REF-walk` - הוא כבד למדי עם מנעולים וספירות התייחסות, הוא לוקח את כל הנעילות שהוא צריך כדי לוודא שהכל נעשה בצורה נכונה ובלי התנגשויות.
- `RCU-walk` - הוא מנגנון שמשתמש במעט נעילות (יחסית ל-`REF-walk`) אבל הוא גם לא יודע להתמודד עם כל הבעיות ולכן אם הוא לא מצליח להתמודד עם הבעיה הוא מפסיק והחיפוש "נופל" מ-`RCU-walk` ל-`REF-walk`.


כאשר מחפשים שם בתיקייה, REF-walk לוקח את `d_lock` על כל dentry מועמד שהוא מוצא בטבלת ה-hash ולאחר מכן בודק שהאב והשם נכונים. אז זה לא נועל את ההורה בזמן חיפוש ב-cache; זה נועל רק ילדים.

REF-walk משתמש ב-`rename_lock` כדי להגן מפני האפשרות של שרשראות hash ב-dcache משתנות בזמן שהן נמצאות בחיפוש. זה יכול לגרום לכישלון למצוא משהו שבאמת נמצא שם. כאשר RCU-walk לא מצליח למצוא משהו ב-dcache, בין אם הוא באמת שם או לא, הוא כבר יורד ל-REF-walk ומנסה שוב עם נעילה מתאימה. זה מטפל בצורה מסודרת בכל המקרים, כך שהוספת בדיקות נוספות על `rename_lock` לא יביא ערך משמעותי.


## מערכות קבצים
יש 2 סוגים של מערכות קבצים:

- מערכות קבצים מסוימות מבטיחות שהמידע ב-dcache תמיד מדויק לחלוטין (אבל לא בהכרח שלם). זה מאפשר ל-VFS לקבוע אם קובץ מסוים קיים או לא קיים מבלי לבדוק עם המערכת קבצים, ומשמעות הדבר היא שה-VFS יכול להגן על מערכת הקבצים מפני races מסוימים ובעיות אחרות. אלו בדרך כלל מערכות קבצים מקומיות כגון `ext3`, `XFS` ו-`Btrfs`.
- מערכות קבצים אחרות אינן מספקות ערבות זו כי הן אינן יכולות, בדרך כלל אלה מערכות קבצים רשתיות. המערכות קבצים האלו מאפשרות ל-VFS לאמת מחדש מידע שמור, וחייבות לספק הגנה משלהן מפני races. ה-VFS יכול לזהות מערכות קבצים אלו על ידי הגדרת הדגל `DCACHE_OP_REVALIDATE` ב-dentry.



## dcache layout
כדי להבין יותר טוב את תהליך החיפוש של dentry ב-dcache צריך להבין איך שמור המידע עצמו ואיך הוא מסודר ומאורגן בזיכרון.

#### ניהול רשימת LRU
dentry עם ספירת התייחסות גדולה מ-0 נקראת dentry בשימוש. כאשר ספירת ההתייחסות של dentry מופחתת ל-0, כל הפעולות הפתוחות שבוצעו על ידי המשתמשים נסגרו, וה-dentry הופך ל-dentry ללא שימוש. dentry ללא שימוש ייכנסו תחילה לרשימת ה-`lru` של `super_block`, ממתינה לשימוש חוזר או לשחרור.


לכל `super_block` יש שדה `s_dentry_lru`, המשמש לשמירת רשימת ה-lru של כל dentry שאינה בשימוש, וה-dentry משתמש בשדה `d_lru` כדי לקשר אל רשימת lru זו. הפונקציות `d_lru_add` ו-`d_lru_del` מסופקות, המשמשים להוספת dentry או הסרה של רשימת ה-lru של `super_block` שלו, בהתאמה.



###  dentry tree
בנוסף לכל ה-hashtable-ים, יש עוד סדר שנעשה ב-dcache על מנת לאפשר גישה יעליה ומהירה, והמבנה הזה הוא עץ הירכיה של ה-dentries במערכת קבצים, כלומר יש קישורים בתוך כל dentry להורה שלו, לאחים שלו ואם הוא directory אז גם לבנים שלו אם יש לו.
הגישה הזאת לרוב משמשת בסריקות שבהן מחפשים לרוב dentries לפי קשר משפחתי (כלומר לפי הלינקים שלהם אחד לשני).
לדוגמה הפונקציה `d_walk` עושה שימוש בטכניקות סריקה לפי העץ.


## RCU & Dcache

המנגנון  RCU (read-copy-update) משמש כדי להבטיח שמבני dentries יישארו קיימים מספיק זמן כדי לבצע בדיקה מסויימת.
המנגנון RCU משמש בעיקר להגנה מפני מחיקת dentries.

בדיקת ההרשאה נעשית על ידי מערכת הקבצים, באמצעות פעולת `permission()`של ה-inode.


הערבות המיוחדת שה-`rcu` בשימוש של ה-dentry מספקת היא שמבני הנתונים המרכזיים: dentries, inodes, super_blocks ו-mounts - לא ישתחררו בזמן שהמנעול מוחזק.
הם עשויים להיות unlinked או בוטלו (invalidated) בדרך זו או אחרת, אך הזיכרון לא ישופץ (repurposed) כך שערכים בתחומים שונים עדיין יהיו בעלי משמעות.
זוהי הערבות היחידה ש-RCU מספק במקרה הזה;


## Symlinks lookup

יש עוד מורכבות של חיפוש עם symlinks וזה מוסבר טוב [במאמר](https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#a-walk-among-the-symlinks) אבל כן הייתי רוצה להסביר משהו קטן שמוזכר שם: magic-links.
### magic-links
דברים ב-`/proc` שנראים כמו קישורים סימליים אבל הם לא באמת (ולכן מכונים בדרך כלל "magic-links") זה באמת הפניה לקובץ היעד, לא רק השם שלו.
​


---





## lookup & inode

הרעיון של חיפוש cache המחזיר אובייקט לא שלם (אך נעול) רחוק מלהיות חדש.


חיפוש שמות ב-dcache מתרחש בתדירות גבוהה הרבה יותר מאשר חיפוש אינודים ב-icache, ולכן, בהתחשב בעובדה שהנתיבים החמים יותר נוטים להיות אופטימליים יותר, אין זה צריך להיות מפתיע שגרסת ה-dcache אינה פשוטה כמו גרסת ה-icache.

### חיפוש הפוך
ניתן גם לבצע חיפוש הפוך (לא על ידי השם של הקובץ אלה על ידי מספר inode) בשימוש עם הפונקציה `iget_locked()` שמחפשת ב-inode cache  של הקרנל אחר inode שמספרו תואם לזה שנרשם במבנה ה-dentries `de`. הוא מחזיר מצביע לערך קיים, או, אם לא נמצא ערך, הוא מקצה ערך cache חדש לא מאותחל שהוא מחזיר ל-caller.




### dcache & mount table

ה-dcache משולב באופן הדוק עם ה-mount table שמתעד איזו מערכת קבצים מותקנת היכן. מה שבעצם mount table מאחסן הוא איזו dentry מותקן על איזו dentries אחרות.

### חיפוש עם מחיקה
כאשר קובץ נמחק, זה יכול לבוא לידי ביטוי ב-cache: על ידי הגדרת d_inode ל-NULL, או על ידי הסרתו מטבלת ה-hash המשמשת לחיפוש השם בספריית האב. אם ה-dentry עדיין בשימוש, נעשה שימוש באפשרות השנייה מכיוון שזה חוקי לחלוטין להמשיך להשתמש בקובץ פתוח לאחר מחיקתו וה-dentries בסביבה עוזרת. אם ה-dentry לא בשימוש אחר (כלומר אם הספירה מחדש ב-d_lockref היא אחת), רק אז תוגדר d_inode ל-NULL. לעשות זאת בצורה זו יעילה יותר עבור מקרה נפוץ מאוד.

אז כל עוד מתקיימת הפניה שנספרה ל-dentry, ערך שאינו NULL ->d_inode לעולם לא ישתנה.




## readdir & getdents

מכיוון שיש מצב הקשור ל-`readdir()` (כלומר מיקום תיקייה), זה לא ממש הגיוני לאפשר לשני thread-ים לקרוא `getdents()` באותו מתאר קובץ תיקייה במקביל. לקובץ struct המייצג את קובץ התיקייה הפתוחה יש נעילה שמונעת מ-`read()` ו-`lseek()` להתרחש במקביל; הוא משמש למניעת קריאות מקבילות` readdir()`/`getdents()`.











