<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Store-Buffer on Michael Shalitin</title>
    <link>https://smichaelshal.github.io/he/tags/store-buffer/</link>
    <description>Recent content in Store-Buffer on Michael Shalitin</description>
    <generator>Hugo</generator>
    <language>he</language>
    <lastBuildDate>Sat, 21 Dec 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://smichaelshal.github.io/he/tags/store-buffer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Causal &amp; Physics</title>
      <link>https://smichaelshal.github.io/he/posts/causal--physics/</link>
      <pubDate>Sat, 21 Dec 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/causal--physics/</guid>
      <description>&lt;h2 id=&#34;ראייה-מורכבת-יותר-של-זיכרון&#34;&gt;ראייה מורכבת יותר של זיכרון&lt;/h2&gt;&#xA;&lt;p&gt;מערכות מחשוב מודרניות מספקות אופטימיזציות וביצועים גבוהים אבל זה לא מגיע בחינם, כל אלה גורמים לסיבוך משמעותי, ולכן הרבה פעמים משתמשים בכלים שגורמים לכל הסיבוך הזה להיות שקוף כלפי המשתמש כמו שפות high level,  מנגנוני נעילה וכל מיני מנגנונים אחרים.&lt;/p&gt;&#xA;&lt;p&gt;בצורה הזאת אפשר לדמות שפות high level ומנגנוני נעילה למערכת שמתפקדת על פי עקרונות של פיזיקה ניוטונית: כשיש נעילה, המערכת מתנהגת בצורה דטרמיניסטית וצפויה, וניתן לדעת בוודאות מה יתרחש בכל מצב נתון. לעומת זאת, במעבר לרמות נמוכות יותר של ניהול זיכרון (למשל, ניהול זיכרון במערכות מרובות ליבות ללא נעילה), המצב מתחיל להזכיר את עקרונות הפיזיקה הקוונטית, שבהם אירועים מפתיעים יכולים להתרחש, וההבנה המלאה של התהליכים מורכבת יותר. רק מעטים יטענו שהם מבינים את כל ההתרחשויות בעולם הזה. אמנם לרוב ניתן לפעול היטב בסביבה זו מבלי להבין את הפרטים המורכבים, אך ישנם מקרים שבהם ידע מעמיק בתחום, נחוץ כדי להבין ולפתור בעיות מורכבות.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Speculation</title>
      <link>https://smichaelshal.github.io/he/posts/optimization-techniques/speculation/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/optimization-techniques/speculation/</guid>
      <description>&lt;h1 id=&#34;ספקולציות&#34;&gt;ספקולציות&lt;/h1&gt;&#xA;&lt;h2 id=&#34;מבוא&#34;&gt;מבוא&lt;/h2&gt;&#xA;&lt;p&gt;ביצוע ספקולטיבי הוא שיטת אופטימיזציה במערכות מחשב, שבה מבוצעות משימות מראש, לפני שנודע בוודאות אם הן נדרשות. המטרה היא לחסוך זמן ולמנוע עיכובים בביצוע העבודה לאחר שמתברר שהיא נדרשת. אם בסופו של דבר מתברר שהמשימה לא הייתה הכרחית, המערכת מבטלת את רוב השינויים שבוצעו ומתעלמת מתוצאות הביצוע.&lt;/p&gt;&#xA;&lt;p&gt;מטרת הביצוע הספקולטיבי היא להגדיל את ניצול המשאבים במערכת ולהפחית עיכובים. השיטה משמשת בתחומים רבים, כמו חיזוי נתיבי branch במעבדים עם pipeline, חיזוי ערכי נתונים לניצול מקומיות ערכית, ושליפת נתונים מראש מהזיכרון.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Store buffer</title>
      <link>https://smichaelshal.github.io/he/posts/processor-components/store-buffer/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/processor-components/store-buffer/</guid>
      <description>&lt;h2 id=&#34;מבוא&#34;&gt;מבוא&lt;/h2&gt;&#xA;&lt;p&gt;המעבדים היום הרבה יותר מהירים מהזיכרון הראשי ולכן כל גישה לזיכרון יכולה לגרום לעיכוב משמעותי בביצועי המעבד ולכן מעבדים מנסים לצמצם ככל הניתן את העיכוב הזה, ולכן פותחו טכניקות שמנסות לנתק כמה שניתן את ביצועי המעבד מהזיכרון עצמו, כמו cache-ים וכל מיני סוגי buffer-ים יעודיים.&lt;/p&gt;&#xA;&lt;p&gt;אחד ה-buffer-ים המרכזיים הוא ה-store buffer (ידוע גם כ-write buffer) והמטרה שלו היא לנתק את ביצוע הכתיבה של המעבד.&lt;/p&gt;&#xA;&lt;p&gt;ה-store buffer מאפשר למעבד לשגר את הוראת הכתיבה ואז הוא יכול &amp;ldquo;לשכוח&amp;rdquo; מהכתיבה וכל האחריות של ביצוע הכתיבה וכל מה שכרוך בה עוברת ל-store buffer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Register renaming</title>
      <link>https://smichaelshal.github.io/he/posts/optimization-techniques/register-renaming/</link>
      <pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/optimization-techniques/register-renaming/</guid>
      <description>&lt;h2 id=&#34;מבוא&#34;&gt;מבוא&lt;/h2&gt;&#xA;&lt;p&gt;בארכיטקטורת מחשבים, Register Renaming הוא טכניקה שמבצעת הפרדה בין רגיסטרים לוגיים לרגיסטרים פיזיים. כל רגיסטר לוגי מקושר לקבוצה של רגיסטרים פיזיים, וכאשר הוראת שפת מכונה מתייחסת לרגיסטר לוגי, המעבד ממפה אותו לרגיסטר פיזי ספציפי במהלך הביצוע. הרגיסטרים הפיזיים אינם נגישים ישירות, וניתן לגשת אליהם רק דרך השמות הקנוניים של הרגיסטרים הלוגיים.&lt;/p&gt;&#xA;&lt;p&gt;טכניקה זו מאפשרת להתגבר על תלות כוזבת בנתונים הנובעת משימוש חוזר ברגיסטרים על ידי הוראות עוקבות שאין ביניהן תלות אמיתית. ביטול התלות הכוזבת מגביר את המקבילות ברמת ההוראה בזרם הפקודות, מה שמאפשר לנצל טכניקות כמו ביצוע על-סקלרי וביצוע מחוץ לסדר לשיפור הביצועים.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
