<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tso on Michael Shalitin</title>
    <link>https://smichaelshal.github.io/he/tags/tso/</link>
    <description>Recent content in Tso on Michael Shalitin</description>
    <generator>Hugo</generator>
    <language>he</language>
    <lastBuildDate>Sat, 19 Oct 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://smichaelshal.github.io/he/tags/tso/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Models</title>
      <link>https://smichaelshal.github.io/he/posts/models/models/</link>
      <pubDate>Sat, 19 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/models/models/</guid>
      <description>&lt;h2 id=&#34;מבוא&#34;&gt;מבוא&lt;/h2&gt;&#xA;&lt;p&gt;מחשבים, בהיותם אוטומטים דטרמיניסטיים, בדרך כלל יניבו התנהגות צפויה ואחידה, ולכן רוב האנשים יחשבו שגזירת התוצאה היא אחת בלבד. עבור מערכות חד-מעבדים, רוב הזמן הם יהיו נכונים בהנחה הזו. עם זאת, במערכות מרובות מעבדים, התמונה משתנה, והן יכולות להוביל למגוון רחב הרבה יותר של התנהגויות. זאת בשל שינויים עדינים בתזמון היחסי של המעבדים השונים במערכת, כמו גם השפעת האותות המועברים ביניהם, ה-cache-ים והזיכרון הראשי.&lt;/p&gt;&#xA;&lt;p&gt;מודלים של זיכרון מנסים להביא סדר לתמונה הזו, וזאת בעיקר על ידי תיאור מדויק של אילו תוצאות אפשריות עשויות להתרחש במערכת מרובת מעבדים SMP שמריצה תוכנית מסוימת. מטרת המודל היא להבהיר את התוצאה הצפויה מהפעולות המבוצעות, ולהגביל את האפשרויות באופן שיקל על ניתוח התנהגות המערכת.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Store buffer</title>
      <link>https://smichaelshal.github.io/he/posts/processor-components/store-buffer/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/processor-components/store-buffer/</guid>
      <description>&lt;h2 id=&#34;מבוא&#34;&gt;מבוא&lt;/h2&gt;&#xA;&lt;p&gt;המעבדים היום הרבה יותר מהירים מהזיכרון הראשי ולכן כל גישה לזיכרון יכולה לגרום לעיכוב משמעותי בביצועי המעבד ולכן מעבדים מנסים לצמצם ככל הניתן את העיכוב הזה, ולכן פותחו טכניקות שמנסות לנתק כמה שניתן את ביצועי המעבד מהזיכרון עצמו, כמו cache-ים וכל מיני סוגי buffer-ים יעודיים.&lt;/p&gt;&#xA;&lt;p&gt;אחד ה-buffer-ים המרכזיים הוא ה-store buffer (ידוע גם כ-write buffer) והמטרה שלו היא לנתק את ביצוע הכתיבה של המעבד.&lt;/p&gt;&#xA;&lt;p&gt;ה-store buffer מאפשר למעבד לשגר את הוראת הכתיבה ואז הוא יכול &amp;ldquo;לשכוח&amp;rdquo; מהכתיבה וכל האחריות של ביצוע הכתיבה וכל מה שכרוך בה עוברת ל-store buffer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Atomic</title>
      <link>https://smichaelshal.github.io/he/posts/atomic/atomic/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://smichaelshal.github.io/he/posts/atomic/atomic/</guid>
      <description>&lt;h2 id=&#34;מבוא&#34;&gt;מבוא&lt;/h2&gt;&#xA;&lt;p&gt;כאשר מספר thread-ים מנסים לשנות בו-זמנית את אותו מיקום בזיכרון, המעבדים אינם מבטיחים תוצאה ספציפית כלשהי כתוצאה מהפעולה.&lt;/p&gt;&#xA;&lt;p&gt;כשאנחנו אומרים שעדכון מסוג RMW, כמו למשל &lt;code&gt;atomic_inc(&amp;amp;x)&lt;/code&gt;, הוא אטומי, הכוונה היא לכך שמיקום הזיכרון (במקרה הזה, &lt;code&gt;x&lt;/code&gt;) לא ישתנה בין שלבי הקריאה והכתיבה שמרכיבים את הפעולה האטומית. במילים אחרות, אם שני מעבדים מבצעים את &lt;code&gt;atomic_inc(&amp;amp;x)&lt;/code&gt; במקביל, יש לוודא שהערך הסופי של &lt;code&gt;x&lt;/code&gt; יהיה הערך ההתחלתי בתוספת 2.&#xA;אין מצב שבו ניתן יהיה לקבל רצף אירועים כזה:&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
