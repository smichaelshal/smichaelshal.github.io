<!DOCTYPE html>
<html lang="he" dir="rtl">

<head>
  <title>
  Acquire Release · Michael Shalitin
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">


<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self' https://www.youtube.com; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' default-src 'unsafe-eval' https://www.google-analytics.com https://cdn.jsdelivr.net/ https://static.cloudflareinsights.com https://cloudflareinsights.com; connect-src 'self' https://www.google-analytics.com https://static.cloudflareinsights.com https://cloudflareinsights.com;">




<meta name="author" content="Michael Shalitin">
<meta name="description" content="
  מבוא
  
    
    Link to heading
  

ההוראות מסוג load-acquire ו-store-release, כוללות מחסומים מובנים חד-כיווניים, המאפשרים דרישות סדר חלשות ממחסומים כלליים. הן משפיעות על הסדר של גישה לזיכרון מפורש שצוינו שנמצא בכל צד של הוראת מחסום הזיכרון. אופי זה מאפשר ביצועים משופרים בזכות אופטימיזציות מיקרו-ארכיטקטוניות ומצמצם את השפעת הביצועים לעומת מחסום זיכרון כללי.
כאשר הסדר הנדרש נתמך על ידי load-acquire או store-release, מומלץ להשתמש בהן במקום במחסום כללי כדי לשפר את היעילות.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Acquire Release">
  <meta name="twitter:description" content="מבוא Link to heading ההוראות מסוג load-acquire ו-store-release, כוללות מחסומים מובנים חד-כיווניים, המאפשרים דרישות סדר חלשות ממחסומים כלליים. הן משפיעות על הסדר של גישה לזיכרון מפורש שצוינו שנמצא בכל צד של הוראת מחסום הזיכרון. אופי זה מאפשר ביצועים משופרים בזכות אופטימיזציות מיקרו-ארכיטקטוניות ומצמצם את השפעת הביצועים לעומת מחסום זיכרון כללי.
כאשר הסדר הנדרש נתמך על ידי load-acquire או store-release, מומלץ להשתמש בהן במקום במחסום כללי כדי לשפר את היעילות.">

<meta property="og:url" content="https://smichaelshal.github.io/he/posts/barriers/acquire-release/">
  <meta property="og:site_name" content="Michael Shalitin">
  <meta property="og:title" content="Acquire Release">
  <meta property="og:description" content="מבוא Link to heading ההוראות מסוג load-acquire ו-store-release, כוללות מחסומים מובנים חד-כיווניים, המאפשרים דרישות סדר חלשות ממחסומים כלליים. הן משפיעות על הסדר של גישה לזיכרון מפורש שצוינו שנמצא בכל צד של הוראת מחסום הזיכרון. אופי זה מאפשר ביצועים משופרים בזכות אופטימיזציות מיקרו-ארכיטקטוניות ומצמצם את השפעת הביצועים לעומת מחסום זיכרון כללי.
כאשר הסדר הנדרש נתמך על ידי load-acquire או store-release, מומלץ להשתמש בהן במקום במחסום כללי כדי לשפר את היעילות.">
  <meta property="og:locale" content="he">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-02T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-02T00:00:00+00:00">
    <meta property="article:tag" content="Barrier">
    <meta property="article:tag" content="Memory">
    <meta property="article:tag" content="Memory-Barrier">
    <meta property="article:tag" content="Cpu">
    <meta property="article:tag" content="Ordering">
    <meta property="article:tag" content="Cache">
      <meta property="og:see_also" content="https://smichaelshal.github.io/he/posts/barriers/amba-ace-barrier/">
      <meta property="og:see_also" content="https://smichaelshal.github.io/he/posts/barriers/mb/">




<link rel="canonical" href="https://smichaelshal.github.io/he/posts/barriers/acquire-release/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6c967191184c40e901e41977158c33a73a2cfa2d9413cf73dddd6732eeae7af4.css" integrity="sha256-bJZxkRhMQOkB5Bl3FYwzpzos&#43;i2UE89z3d1nMu6uevQ=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://smichaelshal.github.io/he/">
      Michael Shalitin
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/he/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/he/posts/">Blog</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="/posts/barriers/acquire-release/">🇬🇧</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://smichaelshal.github.io/he/posts/barriers/acquire-release/">
              Acquire Release
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-11-02T00:00:00Z">
                נובמבר 2, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-newspaper" aria-hidden="true"></i>
                3132 מילים
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/he/categories/barriers/">Barriers</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/he/tags/barrier/">Barrier</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/memory/">Memory</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/memory-barrier/">Memory-Barrier</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/cpu/">Cpu</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/ordering/">Ordering</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/cache/">Cache</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/x86/">X86</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/arm/">Arm</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/ppc/">Ppc</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/linux/">Linux</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/kernel/">Kernel</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/asm/">Asm</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/release/">Release</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/acquire/">Acquire</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/release-acquire/">Release-Acquire</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/multi-copy-atomicity/">Multi-Copy-Atomicity</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="מבוא">
  מבוא
  <a class="heading-link" href="#%d7%9e%d7%91%d7%95%d7%90">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>ההוראות מסוג load-acquire ו-store-release, כוללות מחסומים מובנים חד-כיווניים, המאפשרים דרישות סדר חלשות ממחסומים כלליים. הן משפיעות על הסדר של גישה לזיכרון מפורש שצוינו שנמצא בכל צד של הוראת מחסום הזיכרון. אופי זה מאפשר ביצועים משופרים בזכות אופטימיזציות מיקרו-ארכיטקטוניות ומצמצם את השפעת הביצועים לעומת מחסום זיכרון כללי.</p>
<p>כאשר הסדר הנדרש נתמך על ידי load-acquire או store-release, מומלץ להשתמש בהן במקום במחסום כללי כדי לשפר את היעילות.</p>
<p>סמנטיקות acquire ו-release הן מרכיבים חיוניים לאפשר העברת מידע מתואמת מ-thread אחד לאחר באופן אמין.</p>
<p>סמנטיקת acquire מתארת פעולה שקוראת מזיכרון משותף, בין אם מדובר בקריאה רגילה או ב-RMW. כאשר פעולה כזו מוגדרת כ-load-acquire, היא מונעת שינויים בסדר הפעולות כך שכל קריאה או כתיבה שמבוצעת לאחר פעולת ה-load-acquire תישאר בסדר שבו הופיעה בקוד המקורי.</p>
<p>לעומת זאת, סמנטיקת release מתארת פעולה שכותבת לזיכרון משותף: כתיבה רגילה ו-RMW. פעולה שמוגדרת כ-store-release מונעת שינויים בסדר הפעולות, כך שכל קריאה או כתיבה שמבוצעת לפניה נשארת בסדר המקורי שלה בקוד.</p>
<p>עם ההבנה הזו, ניתן לראות שסמנטיקות acquire ו-release מושגות למעשה באמצעות שילובים מתאימים של מחסומי זיכרון שונים. כך לדוגמה, יש למקם מחסום לאחר פעולת ה-load-acquire ולפני פעולת ה-store-release. מחסומים אלו מספקים את אפקט ההגנה הדרוש, אף שלעתים הם קפדניים יותר ממה שנחוץ עבור סמנטיקת acquire ו-release לפעולה בודדת בזיכרון.</p>
<figure>
    <img src="/posts/barriers/acquire-release/acq-rel-barriers_preshing_acquire_and_release_semantics.png"class="dark-image"
    ><figcaption class="image-title">acq-rel-barriers preshing acquire and release semantics from Acquire and Release Fences (preshing.com)</figcaption></figure><style>
  .dark-image {
    background-color: white;
  }

  .image-title {
    width: 50%;
    margin: auto;
  }
</style>
<p>מעניין במיוחד שסמנטיקות acquire ו-release אינן מצריכות שימוש במחסום מסוג store-load, שהוא לרוב סוג מחסום יקר יחסית. לדוגמה, במעבדים מסוג PowerPC, ההוראה <code>lwsync</code> פועלת כאיחוד של המחסומים: load-store, store-store ו-load-load מבלי לכלול את store-load, ולכן היא יעילה יותר בהיבט זה.</p>
<p>אחת הדרכים ליישם מחסומי זיכרון נדרשים היא באמצעות שימוש בהוראות מחסום מפורשות. נבחן דוגמה בסיסית עבור מעבדי PowerPC: מאחר ש-<code>lwsync</code> מספקת מספר סוגים של מחסומי זיכרון, אפשר להשתמש בה כדי לייצר סמנטיקות acquire או release בהתאם לצורך.</p>
<figure>
    <img src="/posts/barriers/acquire-release/platform-fences_preshing_acquire_and_release_semantics.png"class="dark-image"
    ><figcaption class="image-title">platform-fences preshing acquire and release semantics from Acquire and Release Semantics (preshing.com)</figcaption></figure><style>
  .dark-image {
    background-color: white;
  }

  .image-title {
    width: 50%;
    margin: auto;
  }
</style>
<p>בתרחיש זה, thread 1 מבצע כתיבה למשתנה <code>Ready</code> שמשמשת כ-store-release, בעוד ש-thread 2 מבצע קריאה מאותו משתנה והיא מוגדרת כ-load-acquire. כאשר שני ה-thread-ים רצים במקביל ואנחנו מגלים כי <code>r1 == 1</code>, ניתן לראות בכך אישור שהערך של <code>A</code>, שהוקצה ב-thread 1, אכן עבר בצורה תקינה ל-thread 2. זה מבטיח גם ש-<code>r2 == 42</code>.</p>
<p>באופן כללי, כדי שהטכניקה תעבוד בצורה אמינה, סמנטיקות ה-acquire וה-release צריכות לפעול על אותו משתנה, במקרה זה <code>Ready</code>. בנוסף, גם פעולת ה-load וגם פעולת ה-store צריכות להיות אטומיות. כאן, <code>Ready</code> הוא משתנה int מיושר בזיכרון, ולכן הפעולות עליו הן אטומיות כברירת מחדל במעבדי PowerPC.</p>
<p>כאשר רוכשים מנעול, מתבצע acquire מרומז (implicit), וכאשר משחררים את המנעול מתבצע release מרומז. כלומר, כל פעולות הזיכרון המבוצעות בין רכישת המנעול לשחרורו נמצאות במסגרת מוגנת שמונעת סידור מחדש של זיכרון מחוץ לגבולות אלו.</p>
<h2 id="מחסום-acquire">
  מחסום acquire
  <a class="heading-link" href="#%d7%9e%d7%97%d7%a1%d7%95%d7%9d-acquire">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>מחסום acquire מונע סידור מחדש של הזיכרון של כל קריאה שקודמת לו בסדר התוכנית עם כל קריאה או כתיבה שאחריו לפי סדר התוכנית. במילים אחרות, מחסום acquire ממלא תפקיד של מחסום load-load ו-load-store.</p>
<p>פעולת acquire מבטיחה כי כל פעולות הזיכרון שיבוצעו לאחריה יושלמו לאחר סיומה. עם זאת, פעולות זיכרון שנעשו לפני פעולת acquire עשויות להסתיים גם לאחריה, כך שפעולת acquire מבטיחה בעיקר שהוראות שיבואו אחריה לא יוקדמו במיקומן.</p>
<h2 id="מחסום-release">
  מחסום release
  <a class="heading-link" href="#%d7%9e%d7%97%d7%a1%d7%95%d7%9d-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>מחסום release מונע את סידור הזיכרון מחדש של כל קריאה או כתיבה שקודמת לו בסדר התוכנית עם כל כתיבה שאחריו לפי סדר התוכנית. מחסום release, מתפקד כמחסום load-store ו-store-store.</p>
<p>פעולת release מספקת הבטחה שכל הפעולות שבוצעו לפני פעולה זו יהיו גלויות וניתנות לצפייה לפני שה-release עצמה מתבצעת. כלומר, כאשר מתבצעת פעולה release, כל הגישות לזיכרון שנעשו קודם לכן ייחשבו כגלויות לכל המעבדים המעורבים, ובכך זה מאפשר למעבדים אחרים לראות את השינויים שהתרחשו לפני פעולה זו. עם זאת, פעולות זיכרון שבאות לאחר פעולת release עשויות להסתיים עוד לפני סיומה.</p>
<h3 id="אינטראקציה-בין-מחסומי-acquire-ו-release">
  אינטראקציה בין מחסומי acquire ו-release
  <a class="heading-link" href="#%d7%90%d7%99%d7%a0%d7%98%d7%a8%d7%90%d7%a7%d7%a6%d7%99%d7%94-%d7%91%d7%99%d7%9f-%d7%9e%d7%97%d7%a1%d7%95%d7%9e%d7%99-acquire-%d7%95-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>כאשר מבצעים פעולת acquire על משתנה מסוים, מובטח שכל גישות הזיכרון שהתבצעו לפני פעולת release קודמת לאותו משתנה יהיו גלויות. כלומר, בכניסה לקטע קריטי באמצעות acquire, מובטח שכל השינויים שבוצעו בקטעים קריטיים קודמים על אותו משתנה זמינים כעת לקריאה.</p>
<p>במקרים של אינטראקציה בין מעבדים שונים, יש להקפיד להתאים מחסומי זיכרון מתאימים כדי למנוע שגיאות סנכרון.</p>
<h3 id="מחסומים-כלליים-מול-מחסומי-acquire-release">
  מחסומים כלליים מול מחסומי acquire-release
  <a class="heading-link" href="#%d7%9e%d7%97%d7%a1%d7%95%d7%9e%d7%99%d7%9d-%d7%9b%d7%9c%d7%9c%d7%99%d7%99%d7%9d-%d7%9e%d7%95%d7%9c-%d7%9e%d7%97%d7%a1%d7%95%d7%9e%d7%99-acquire-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>שימוש במחסומי זיכרון כלליים לא רק מבטיח התאמה של כל גישות הזיכרון בכל המעבדים, אלא גם מפצה על תכונות כמו non-multi-copy atomicity, שבהן עותקי זיכרון עשויים להתעדכן בזמנים שונים במעבדים השונים</p>
<p>לעומת זאת, מחסומים בזוגות acquire-release יוצרים סידור זיכרון שרלוונטי רק לאותם מעבדים שמשתתפים באותה שרשרת ספציפית של acquire-release. כלומר, הם מבטיחים סנכרון מקומי למעבדים שמשתמשים באותם משתנים אך אינם מבטיחים בהכרח התאמה כוללת בין כל המעבדים במערכת.</p>
<p>מעניין לראות שבמעבדי x86, כל הוראת load לזיכרון מתפרשת כהוראת load acquire, בעוד שכל הוראת store נחשבת כהוראת store release. התנהגות זו היא חלק מהדרישות של הארכיטקטורה.</p>
<h3 id="קשר-synchronizes-with">
  קשר synchronizes-with
  <a class="heading-link" href="#%d7%a7%d7%a9%d7%a8-synchronizes-with">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>בהנחה שנשקול שתי פעולות, A ו-B, אשר שתיהן מתבצעות על אותו משתנה אטומי M, נניח כי A היא פעולה של release, מה שאומר שהיא מבצעת כתיבה ל-M. ונניח ש-B היא פעולה של acquire, כך שהיא קוראת מ-M.</p>
<p>כדי שאפשר יהיה לקבוע כי הפעולה A מסונכרנת עם B, יש צורך שב-B ייקרא ערך אשר נכתב על ידי A, או על ידי כל פעולה אטומית אחרת שכתבה ערך ל-M לאחר ביצוע A. כלומר, אכן ניתן לומר כי A מסונכרנת עם B, אם ב-B מתבצעת קריאה של ערך שנכתב על ידי A, או ערך שנכתב לאחר הכתיבה של A למשתנה האטומי.</p>
<p>ניתן לנסח זאת בצורה יותר ברורה: שתי פעולות שמבוצעות על אותו משתנה אטומי מסונכרנות זו עם זו אם אחת מהן רואה תוצאה של השנייה, ובתוספת לכך, כל התנאים המתקיימים בפרמטרים של סדר הזיכרון ישפיעו על תהליך הסנכרון.</p>
<h2 id="rc---release-consistency">
  RC - Release Consistency
  <a class="heading-link" href="#rc---release-consistency">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>הרעיון המרכזי של עקביות release הוא שלפעולות הסנכרון, הן הקריאה והן הכתיבה, יש דרישות סדר שונות. פעולת ה-release מסמנת שהפעולות הקודמות הושלמו, ואין לה השפעה על סדר הגישה שלאחר מכן. לכן, למרות שפעולת ה-release מחכה להשלמת פעולות הזיכרון הקודמות לפי סדר התוכנית, פעולות הזיכרון שאחריה יכולות להתרחש ללא עיכוב.</p>
<p>באותו אופן, פעולת acquire לא מחייבת סיום של פעולות זיכרון קודמות, מכיוון שהיא לא מעניקה הרשאה למעבדים אחרים לגשת למיקומים המשותפים בזמן זה. זה מאפשר סידור מחדש וחפיפות נוספות של פעולות זיכרון ביחס ל-acquires ו-releases.</p>
<p>המודל RC מבדיל בין פעולות הסנכרון של כניסה (entrance) ויציאה (exit).</p>
<p>במודל סדר חלש, כאשר מתבצעת פעולה של סנכרון, כל הפעולות שמבוצעות בכל המעבדים חייבות להיות גלויות לפני שהמעבד ממשיך בפעולה הבאה. במילים אחרות, כל הכתיבות והקריאות המתרחשות לפני הסנכרון צריכות להתפרסם ולהיות נראות לפני שמבצעים את פעולת הסנכרון.</p>
<p>במודל RC, לעומת זאת, במהלך הכניסה לקטע קריטי, המוכר בשם acquire, יש להשלים את כל הפעולות הקשורות למשתני זיכרון המקומיים. במהלך היציאה מהקטע הקריטי, המכונה release, יש להפיץ את כל השינויים שנעשו על ידי המעבד המקומי לכל שאר המעבדים במערכת. בכך נשמרת הקוהרנטיות של הזיכרון.</p>
<p>פעולת ה-acquire מתבצעת באמצעות הוראת load, שמטרתה לגשת לקטע הקריטי. מצד שני, פעולת ה-release מתבצעת באמצעות הוראת store, שמאפשרת למעבדים אחרים לגשת למשתנים המשותפים.</p>
<p>באופן כללי, בין משתני הסנכרון ניתן לשמור על SC או עקביות מעבד (PC). במודל SC, יש לעבד את כל משתני הסנכרון המתחרים בסדר הנכון, בעוד שבמודל PC, זוג משתנים מתחרים צריכים לפעול רק לפי הסדר המסוים הזה. במודל PC, ניתן לאפשר להוראות acquire להתבצע לפני release שנעשו בעבר, מה שמספק גמישות רבה יותר בניהול הסנכרון ובפעולות במערכת.</p>
<h3 id="עקביות-כניסה-entry-consistency">
  עקביות כניסה (Entry Consistency)
  <a class="heading-link" href="#%d7%a2%d7%a7%d7%91%d7%99%d7%95%d7%aa-%d7%9b%d7%a0%d7%99%d7%a1%d7%94-entry-consistency">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>עקביות כניסה היא גרסה של מודל עקביות ה-release, אשר דורשת את השימוש בהוראות acquire ו-release כדי לציין במפורש את הכניסה לקטע קריטי או היציאה ממנו. תחת מודל זה, לכל משתנה משותף מוקצה משתנה סנכרון ייחודי. המשמעות היא שכאשר פעולת acquire מתבצעת עבור משתנה מסוים (למשל x), יש להשליך את כל הפעולות הקשורות למשתנה זה על המעבד המפעיל את ה-acquire.</p>
<p>גישה זו מאפשרת למעבדים לבצע פעולות מקבילות על קטעים קריטיים שונים של משתנים משותפים שונים, מבלי שהן יתנגשו אחת עם השנייה. עם זאת, יש לציין שלא ניתן לראות חפיפות בין פעולות קריטיות המבוצעות על אותו משתנה משותף, מה שמחייב טיפול זהיר בכל הנוגע לסנכרון של פעולות על משתנים משותפים.</p>
<h1 id="arm">
  Arm
  <a class="heading-link" href="#arm">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>ארכיטקטורת Arm מספקת סט הוראות המאפשר סמנטיקות Acquire לפעולות loads וסמנטיקות Release לפעולות stores. הוראות אלו תומכות במודל עקביות מסוג RCsc. נוסף לכך, כשמוגדר FEAT_LRCPC אז קיימת הוראה מסוג Load-AcquirePC, שניתן לשלב עם Store-Release כדי לתמוך במודל עקביות חלש יותר, המכונה RCpc.</p>
<p>באמצעות הוראות Load-Acquire, Load-AcquirePC ו-Store-Release, ניתן לעיתים להימנע משימוש בהוראות DMB מפורשות, משום שהן מספקות בעצמן את הסדר הנדרש בזיכרון.</p>
<p>מידע נוסף על דרישות הסדר והיישור של הוראות אלו:</p>
<ul>
<li>
<p>עבור ההוראות Load-Acquire, Load-AcquirePC ו-Store-Release, נדרש יישור הכתובת של אובייקט הנתונים בהתאם לגודלו. אחרת, הגישה תוביל לשגיאת יישור (Alignment fault).</p>
</li>
<li>
<p>עבור הוראות Load-Acquire Exclusive Pair ו-Store-Release Exclusive Pair, נדרש יישור כפול מגודל הנתונים, אחרת תיווצר שגיאת יישור. לדוגמה:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="ln">1</span><span class="cl"><span class="nf">LDAXP</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x1</span><span class="p">,</span> <span class="p">[</span><span class="mi">0x08</span><span class="p">]</span> <span class="c1">; Alignment fault
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span><span class="nf">LDAXP</span> <span class="no">x0</span><span class="p">,</span> <span class="no">x1</span> <span class="p">[</span><span class="mi">0x10</span><span class="p">]</span>
</span></span></code></pre></div></li>
<li>
<p>בניגוד להוראות DMB, שמקבל כפרמטר את הדומיין, הוראות ה-LDAR וה-STLR משתמשות בתכונה של הכתובת שאליה מתבצע הגישה.</p>
</li>
<li>
<p>בנוסף, קיימות גם גרסאות בלעדיות של הוראות Load-Acquire ו-Store-Release, המספקות תכונות אטומיות נוספות, ההוראות הן <code>LDAXR</code> ו-<code>STLXR</code> בהתאמה.</p>
</li>
</ul>
<h3 id="load-acquire-ldar">
  Load-Acquire (LDAR)
  <a class="heading-link" href="#load-acquire-ldar">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>דרישות הסדר המוטלות על ידי הוראת Load-Acquire <code>LDAR</code> הן:</p>
<ul>
<li>כל הגישה המפורשת לזיכרון לאחר ה-<code>LDAR</code> תיראה לאחר ה-<code>LDAR</code>.</li>
<li>כל הגישה המפורשת לזיכרון לפני ה-<code>LDAR</code> לא מושפעת, ומסודרת מחדש לגבי ה-<code>LDAR</code>.</li>
</ul>
<p>ניתן לראות את דרישות הסדר האלה <a href="https://documentation-service.arm.com/static/62a304f231ea212bb662321f?token="  class="external-link" target="_blank" rel="noopener">בתרשים</a> הבא:</p>
<figure>
    <img src="/posts/barriers/acquire-release/Figure_1_LDAR_ordering_requirements.svg"class="dark-image"
    ><figcaption class="image-title">Figure 1 LDAR ordering requirements from Load-Acquire and Store-Release instructions (developer.arm.com)</figcaption></figure><style>
  .dark-image {
    background-color: white;
  }

  .image-title {
    width: 50%;
    margin: auto;
  }
</style>
<h3 id="store-release">
  Store-Release
  <a class="heading-link" href="#store-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>דרישות הסדר המוטלות על ידי הוראת Store-Release <code>STLR</code> הן:</p>
<ul>
<li>כל הגישה המפורשת לזיכרון לפני <code>STLR</code> תיראה לפני <code>STLR</code>.</li>
<li>כל הגישה המפורשת לזיכרון לאחר <code>STLR</code> לא מושפעת, ומסודרת מחדש לגבי <code>STLR</code>.</li>
</ul>
<p>אתה יכול לראות את דרישות הסדר האלה <a href="https://documentation-service.arm.com/static/62a304f231ea212bb6623216?token="  class="external-link" target="_blank" rel="noopener">בתרשים</a> הבא:</p>
<figure>
    <img src="/posts/barriers/acquire-release/Figure_2_STLR_ordering_requirements.svg"class="dark-image"
    ><figcaption class="image-title">Figure 2 STLR ordering requirements from Load-Acquire and Store-Release instructions (developer.arm.com)</figcaption></figure><style>
  .dark-image {
    background-color: white;
  }

  .image-title {
    width: 50%;
    margin: auto;
  }
</style>
<p>הדוגמה הבאה מראה כיצד להשתמש ב-<code>STLR</code> כדי לאכוף ניראות ביצוע הוראות. מיקומי הזיכרון ב-<code>X1</code> ו-<code>X3</code> מאתחלים ל-<code>0x0</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="ln">1</span><span class="cl"><span class="nf">STR</span>  <span class="p">,</span> <span class="p">[</span><span class="no">X1</span><span class="p">]</span> 
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="no">STLR</span> <span class="p">,</span> <span class="p">[</span><span class="no">X3</span><span class="p">]</span>  <span class="c1">; Cannot observe this STLR without observing the previous STR.
</span></span></span></code></pre></div><p>בדוגמה זו, אם מיקום הזיכרון ב-<code>X3</code> נצפה מעודכן, אז גם <code>X1</code> חייב להיות מעודכן. אם מעבד אחר קורא את אותם שני מיקומי זיכרון, באותו סדר, הטבלה הבאה מציגה את שילוב הערכים שמערכת הזיכרון עשויה להחזיר:</p>
<table>
  <thead>
      <tr>
          <th>X1</th>
          <th>X3</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0x0</td>
          <td>0x0</td>
      </tr>
      <tr>
          <td>0x1</td>
          <td>0x0</td>
      </tr>
      <tr>
          <td>0x1</td>
          <td>0x1</td>
      </tr>
  </tbody>
</table>
<h3 id="זוגות-load-acquire-ו-store-release">
  זוגות Load-Acquire ו-Store-Release
  <a class="heading-link" href="#%d7%96%d7%95%d7%92%d7%95%d7%aa-load-acquire-%d7%95-store-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הוראות מסוג load-acquire ו-store-release יכולות לשמש בזוג כדי להגן על קטע קריטי בקוד. כאשר הוראות אלו מופעלות כזוג, הן מבטיחות שגישות זיכרון המבוצעות בתוך הקטע הקריטי אינן &ldquo;זולגות&rdquo; או מסודרות מחדש מחוץ לקטע זה.</p>
<p>אבל סדר הגישות בתוך הקטע הקריטי אינו מושפע. כלומר, ניתן עדיין לשנות את הסדר של פעולות המתרחשות בתוך הקטע הקריטי עצמו, בהתאם לאופטימיזציות אפשריות בתוך הדומיין המוגדר כמו <a href="https://documentation-service.arm.com/static/62a304f231ea212bb662321e?token="  class="external-link" target="_blank" rel="noopener">בתרשים</a> הבא:</p>
<figure>
    <img src="/posts/barriers/acquire-release/%27Figure_3_Protecting_a_critical_code_section_with_an_LDAR-STLR_pair.svg"class="dark-image"
    ><figcaption class="image-title">&#39;Figure 3 Protecting a critical code section with an LDAR-STLR pair from Load-Acquire and Store-Release instructions (developer.arm.com)</figcaption></figure><style>
  .dark-image {
    background-color: white;
  }

  .image-title {
    width: 50%;
    margin: auto;
  }
</style>
<h3 id="load-acquirepc">
  Load-AcquirePC
  <a class="heading-link" href="#load-acquirepc">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הארכיטקטורה Armv8.3-A מציעה את ההוראה <code>LDAPR</code> שהיא הוראות נוספות מסוג Load-AcquirePC. השימוש בשילוב של הוראות Load-AcquirePC עם הוראות Store-Release נועד לתמוך במודל ה-RCpc, אשר הוא מודל חלש יותר בהשוואה למודלים אחרים.</p>
<p>ניתן לראות את השפעת השימוש בהוראות הללו בתרשים הבא:</p>
<figure>
    <img src="/posts/barriers/acquire-release/Figure_5_Load-AcquirePC_instructions.svg"class="dark-image"
    ><figcaption class="image-title">Figure 5 Load-AcquirePC instructions from Load-Acquire and Store-Release instructions (developer.arm.com)</figcaption></figure><style>
  .dark-image {
    background-color: white;
  }

  .image-title {
    width: 50%;
    margin: auto;
  }
</style>
<p>שינוי משמעותי במודל זה הוא שהדרישה לכך שגישות Load-Acquire יהיו נצפות בסדר קבוע עם store-releases הקודמות הוסרה בהוראות Load-AcquirePC החדשות, דבר שמקל על השימוש בהן ומאפשר גמישות רבה יותר בהסדרת גישות לזיכרון.</p>
<p>ההוראה LDAPR יחד עם הוראות store release, מאפשרת אמולציה יעילה של x86-TSO.</p>
<h3 id="קביעת-דומיין">
  קביעת דומיין
  <a class="heading-link" href="#%d7%a7%d7%91%d7%99%d7%a2%d7%aa-%d7%93%d7%95%d7%9e%d7%99%d7%99%d7%9f">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הדומיין shareability קובע את טווח המעבדים בהם נשמר הסדר שיצרו הוראות אלו, בהתאם לשיתוף הכתובת שנגישה. לדוגמה, אם מעבד P0 ומעבד P1 נמצאים בדומיינים שונים (למשל, הם לא נמצאים באותו דומיין Inner), ייתכן ש-P1 יבחין בעדכון מיקום הזיכרון ב-<code>X3</code> לפני ש-<code>X1</code> עודכן, אם הכתובת ב-<code>X3</code> היא בדומיין שיתוף פנימי.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-asm" data-lang="asm"><span class="line"><span class="ln">1</span><span class="cl"><span class="nf">P0</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nf">STR</span>  <span class="p">,</span> <span class="p">[</span><span class="no">X1</span><span class="p">]</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="nf">STLR</span> <span class="p">,</span> <span class="p">[</span><span class="no">X3</span><span class="p">]</span>
</span></span></code></pre></div><h1 id="lkmm">
  LKMM
  <a class="heading-link" href="#lkmm">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="release">
  Release
  <a class="heading-link" href="#release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>פעולות  Release משמשות להבטחת סדר בזיכרון על ידי כך שהן מסדרות את ה-store שלהן מול כל גישה קודמת לזיכרון (באותו מעבד).</p>
<p>סידור הזיכרון של release מבטיח שכל ה-stores שבוצעו קודם בסדר התוכנית באותו מעבד, כמו גם כל ה-stores המופצים ממעבדים אחרים, יתפשטו לכל המעבדים במערכת לפני שפעולת ה-release תושלם. זהו מאפיין A-cumulative.</p>
<h3 id="יתרונות">
  יתרונות
  <a class="heading-link" href="#%d7%99%d7%aa%d7%a8%d7%95%d7%a0%d7%95%d7%aa">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>בגלל אופן הפעולה של פעולות Release, הן מאפשרות בדרך כלל קוד פשוט וקריא יותר עם ביצועים משופרים בהשוואה לשימוש במחסומים מפורשים כגון <code>smp_wmb</code>. לדוגמה, שימוש ב-<code>smp_store_release</code> יכול להחליף את הצורך ב-<code>smp_wmb</code>, תוך שמירה על סדר כתיבה נכון בזיכרון:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>בדרך כלל, הערך המאוחסן על ידי פעולת Release, כמו בכתיבה ל-<code>y</code> בדוגמה, ישמש כחלק מאלגוריתם מקבילי, שבו חלקים אחרים באלגוריתם ייגשו אליו באמצעות פעולת Acquire. בכך, פעולת ה-Release מקלה על תיאום בין מעבדים שונים באלגוריתם, ומספקת בסיס לשיתוף מידע בצורה עקבית.</p>
<p>במקרה בו נדרש סידור עבור קריאה מ-<code>x</code> ולא כתיבה (כמו קודם), כמו בדוגמה הבאה:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="nf">smp_mb</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>אפשר להשתמש ב-<code>smp_mb</code> כדי להבטיח את הסדר הנדרש. אולם <code>smp_mb</code> מייצר לעיתים תקורה גבוהה. לעומת זאת, <code>smp_store_release</code> יספק את הסדר הדרוש בצורה יעילה יותר, ללא התקורה הגבוהה של <code>smp_mb</code>.</p>
<p>ב-x86, ה-<code>smp_store_release</code> עשוי להתקמפל להוראות בסיסיות של <code>load</code> ו-<code>store</code>, מה שמאפשר הוראה פשוטה ויעילה בהרבה. לעומת זאת, <code>smp_mb</code> מצריך הוראה מורכבת יותר, מה שמגביר את התקורה בשימוש בו.</p>
<h3 id="סוגי-פעולות-release">
  סוגי פעולות Release
  <a class="heading-link" href="#%d7%a1%d7%95%d7%92%d7%99-%d7%a4%d7%a2%d7%95%d7%9c%d7%95%d7%aa-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>קיימות מספר פעולות Release שמספקות מנגנונים שונים להבטחת סידור:</p>
<h4 id="פעולות-כתיבה-אטומיות-ללא-החזרת-ערך">
  פעולות כתיבה אטומיות ללא החזרת ערך
  <a class="heading-link" href="#%d7%a4%d7%a2%d7%95%d7%9c%d7%95%d7%aa-%d7%9b%d7%aa%d7%99%d7%91%d7%94-%d7%90%d7%98%d7%95%d7%9e%d7%99%d7%95%d7%aa-%d7%9c%d7%9c%d7%90-%d7%94%d7%97%d7%96%d7%a8%d7%aa-%d7%a2%d7%a8%d7%9a">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>פעולות אלו כוללות את <code>smp_store_release</code>, כמו גם את <code>atomic_set_release</code> ו-<code>atomic_long_set_release</code>.</p>
<h4 id="פעולות-rmw-עם-החזרת-ערך">
  פעולות RMW עם החזרת ערך
  <a class="heading-link" href="#%d7%a4%d7%a2%d7%95%d7%9c%d7%95%d7%aa-rmw-%d7%a2%d7%9d-%d7%94%d7%97%d7%96%d7%a8%d7%aa-%d7%a2%d7%a8%d7%9a">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>פעולות RMW אטומיות שמחזירות ערך, שמספקות סידור Release ששמותיהן מסתיימות ב-<code>_release</code>. דוגמאות כוללות את <code>atomic_fetch_add_release</code> ו-<code>cmpxchg_release</code>. עם זאת, חשוב לשים לב שסידור Release מובטח רק עבור חלק ה-store של פעולת ה-RMW, כלומר סדר זה מבטיח רק שהכתיבה תתקיים אחרי כל הפעולות הקודמות בזיכרון, ולא עבור חלק ה-load שבוצע כחלק מה-RMW.</p>
<p>בנוסף, עבור פעולות מותנות כמו <code>cmpxchg_release</code>, יש לזכור שהן מספקות סידור זה רק אם הפעולה הצליחה.</p>
<h2 id="acquire">
  Acquire
  <a class="heading-link" href="#acquire">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>פעולות Acquire מבטיחות שה-load שלהן יתקיים בסדר נכון ביחס לגישות הזיכרון הקודמות והבאות של המעבד, כך שכל פעולה שמתבצעת לאחר פעולת ה-Acquire תתקיים רק אחרי ה-load הנוכחי. בהשוואה למחסומי זיכרון כלליים (כגון <code>smp_rmb</code>), פעולות Acquire מאפשרות קוד קריא יותר ובעל ביצועים משופרים.</p>
<h3 id="דוגמה-לסידור-זיכרון-באמצעות-smp_load_acquire">
  דוגמה לסידור זיכרון באמצעות <code>smp_load_acquire</code>
  <a class="heading-link" href="#%d7%93%d7%95%d7%92%d7%9e%d7%94-%d7%9c%d7%a1%d7%99%d7%93%d7%95%d7%a8-%d7%96%d7%99%d7%9b%d7%a8%d7%95%d7%9f-%d7%91%d7%90%d7%9e%d7%a6%d7%a2%d7%95%d7%aa-smp_load_acquire">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>במקום להשתמש ב-<code>smp_rmb</code> כדי להבטיח סידור זיכרון, ניתן להשתמש ב-<code>smp_load_acquire</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="n">r0</span> <span class="o">=</span> <span class="nf">smp_load_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="n">r1</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span></code></pre></div><p>כמו פעולת <code>smp_store_release</code>, פעולת <code>smp_load_acquire</code> מאפשרת לאלגוריתם המקבילי לפעול בצורה סינכרונית על ידי יצירת סידור ברור מול פעולות ה-Release. במקרה זה, <code>smp_load_acquire</code> יעיל יותר מ-<code>smp_rmb</code>, משום שהוא מספק סידור מול כל פעולות ה-store וה-load המתרחשות לאחריו, ולא רק מול פעולות ה-load.</p>
<h3 id="סוגי-פעולות-acquire">
  סוגי פעולות Acquire
  <a class="heading-link" href="#%d7%a1%d7%95%d7%92%d7%99-%d7%a4%d7%a2%d7%95%d7%9c%d7%95%d7%aa-acquire">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>ישנם מספר סוגים של פעולות Acquire, כל אחד מהם מתאים לשימושים שונים:</p>
<h4 id="פעולות-קריאה-אטומיות-עם-acquire">
  פעולות קריאה אטומיות עם Acquire
  <a class="heading-link" href="#%d7%a4%d7%a2%d7%95%d7%9c%d7%95%d7%aa-%d7%a7%d7%a8%d7%99%d7%90%d7%94-%d7%90%d7%98%d7%95%d7%9e%d7%99%d7%95%d7%aa-%d7%a2%d7%9d-acquire">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>פעולות אלו כוללות מספר פונקציות כמו <code>smp_load_acquire</code>, <code>atomic_read_acquire</code>, <code>atomic64_read_acquire</code> ו-<code>test_bit_acquire</code>. כל אחת מפעולות אלו מספקת את סידור הזיכרון הנדרש עבור פעולת load, ומבטיחה כי פעולות הקריאה והכתיבה בזיכרון שיבואו אחריהן יתקיימו רק לאחריה.</p>
<h4 id="פעולות-rmw-עם-acquire-שמחזירות-ערך">
  פעולות RMW עם Acquire שמחזירות ערך
  <a class="heading-link" href="#%d7%a4%d7%a2%d7%95%d7%9c%d7%95%d7%aa-rmw-%d7%a2%d7%9d-acquire-%d7%a9%d7%9e%d7%97%d7%96%d7%99%d7%a8%d7%95%d7%aa-%d7%a2%d7%a8%d7%9a">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>פעולות RMW אטומיות מחזירות ערך ששמן מסתיים ב-<code>_acquire</code> (כגון <code>atomic_xchg_acquire</code> ו-<code>atomic_cmpxchg_acquire</code>) מספקות סידור Acquire רק עבור חלק ה-load של פעולת ה-RMW, ולא עבור חלק ה-store. כמו כן, פעולות מותנות, כמו <code>atomic_cmpxchg_acquire</code> ו-<code>test_and_set_bit_lock</code>, מבטיחות סידור זה רק אם הן מצליחות.</p>
<h2 id="acquire--release">
  acquire &amp; release
  <a class="heading-link" href="#acquire--release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="שימוש-acquire-עם-release">
  שימוש Acquire עם Release
  <a class="heading-link" href="#%d7%a9%d7%99%d7%9e%d7%95%d7%a9-acquire-%d7%a2%d7%9d-release">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>לרוב הוראות מחסום הזיכרון החלשות המשמשות ליישום <code>smp_load_acquire</code> ו-<code>smp_store_release</code> והן אינן נדרשות לסדר stores קודמים ביחס ל-loads הבאים בכל המקרים.</p>
<p>עם זאת, זכור כי <code>smp_load_acquire</code> אינו קסם. בפרט, הוא פשוט קורא מהארגומנט שלו עם סדר. זה <strong>לא</strong> מבטיח שערך מסוים ייקרא.</p>
<p>פעולות ה-acquire מוצמדות לרוב לפעולות ה-release. לדוגמה, שקול את הדוגמה הבאה, שבה <code>task0</code> ו- <code>task1</code> פועלות במקביל:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">task0</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="kt">void</span> <span class="nf">task1</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="n">r0</span> <span class="o">=</span> <span class="nf">smp_load_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="n">r1</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>אם נניח שהערכים ההתחלתיים של <code>x</code> ו-<code>y</code> הם אפס, אז הערכים הסופיים של <code>r0</code> ו-<code>r1</code> יכולים להיות:</p>
<ul>
<li>או ש-<code>r0</code> ו-<code>r1</code> שניהם אפס,</li>
<li>או ש-<code>r0</code> שווה ל-<code>r1</code>.</li>
</ul>
<p>התוצאה היחידה שאינה מותרת היא מצב שבו <code>r0</code> מכיל אפס ו-<code>r1</code> מכיל 1, מכיוון שהיא סותרת את הסידור הנדרש שמבטיחות פעולות ה-Acquire וה-Release.</p>
<h3 id="שרשראות-release-acquire">
  שרשראות Release-Acquire
  <a class="heading-link" href="#%d7%a9%d7%a8%d7%a9%d7%a8%d7%90%d7%95%d7%aa-release-acquire">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>שרשראות של פעולות release-acquire מספקות כלי יעיל, גמיש ונוח ליצירת סדר עקבי בין פעולות על פני מעבדים שונים. עם זאת, ישנם מספר מגבלות ופרטים חשובים שראוי להבין.</p>
<p>להלן דוגמה בסיסית המשתמשת בשרשרת release-acquire כדי לשמור על הסדר:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cm">/* See ISA2+pooncerelease+poacquirerelease+poacquireonce.litmus. */</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">void</span> <span class="nf">CPU0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">CPU1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="n">r0</span> <span class="o">=</span> <span class="nf">smp_load_acquire</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="nf">CPU2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="n">r1</span> <span class="o">=</span> <span class="nf">smp_load_acquire</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="n">r2</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>בתרחיש זה, אם ערכיהם הסופיים של <code>r0</code> ו-<code>r1</code> הם שניהם 1, אז גם <code>r2</code> חייב לקבל ערך סופי של 1. כאן מתקיים סדר גלובלי חזק, אך למעשה הוא חזק יותר מהנדרש. לדוגמה, אפשר להחליף את <code>smp_load_acquire</code> של CPU1 ב-<code>READ_ONCE</code>, והסדר יישמר.</p>
<p>עם זאת, חשוב להדגיש ששרשרת release-acquire אינה מבטיחה שכל store מתבצע באופן גלובלי לפי הסדר המדויק שצופה המשתמש. לדוגמה, נניח את התוכנית הבאה:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cm">/* See Z6.0+pooncerelease+poacquirerelease+mbonceonce.litmus. */</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="kt">void</span> <span class="nf">CPU0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="kt">void</span> <span class="nf">CPU1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="n">r0</span> <span class="o">=</span> <span class="nf">smp_load_acquire</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="kt">void</span> <span class="nf">CPU2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="nf">smp_mb</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="n">r1</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ייתכן שנרצה לחשוב שאם <code>r0</code> הוא 1 והערך של <code>z</code> בסוף הוא 2, אז <code>r1</code> יהיה בהכרח 1. עם זאת, במציאות <code>r1</code> עשוי להיות 0, שכן CPU2 אינו משתתף בשרשרת release-acquire המוגדרת בין CPU0 ל-CPU1. כלומר, CPU2 יכול לגשת למשתנים בלי להיות מחובר לשרשרת זו ולכן אינו מחויב לסדר הגלובלי שלה.</p>
<p>למרות מגבלות אלו, שרשראות release-acquire נשארות כלי חיוני ויעיל, בזכות התקורה הנמוכה וקלות השימוש שלהן. הן מבטיחות סדר עקבי עבור משתתפים בשרשרת, כך שבמרבית המקרים, הן מאפשרות יציבות ופשטות בסידור הגישה לזיכרון במערכות מרובות ליבות.</p>
<h3 id="מימוש-ב-power-pc">
  מימוש ב-Power PC
  <a class="heading-link" href="#%d7%9e%d7%99%d7%9e%d7%95%d7%a9-%d7%91-power-pc">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>עוד דרך מעניינת להבין את הרעיון של acquire release היא על ידי המימוש של הקרנל של בארכיטקטורת PowerPC:</p>
<p>המימוש מתוך <code>arch/powerpc/include/asm/barrier.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"> <span class="nf">__smp_load_acquire</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>						\
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">({</span>									\
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="nf">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">___p1</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>				\
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">compiletime_assert_atomic_type</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>				\
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nf">__smp_lwsync</span><span class="p">();</span>							\
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="n">___p1</span><span class="p">;</span>								\
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="p">})</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"> <span class="nf">__smp_store_release</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>						\
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="k">do</span> <span class="p">{</span>									\
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">compiletime_assert_atomic_type</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>				\
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="nf">__smp_lwsync</span><span class="p">();</span>							\
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="nf">WRITE_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>						\
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>אפשר לראות שגם ה-acquire וגם ה-release ממומשים עם המחסום החלש <code>lwsync</code> של PowerPC, והשוני העיקרי בין המימושים הוא המיקום של המחסום ביחס להוראת הזיכרון: ב-acquire המחסום מגיע אחרי הקריאה וב-release המחסום מגיע לפני הכתיבה.</p>
<p>ניתן להשתמש  ב-PPC כדי להבין למה רק מעבדים שמשתתפים בשרשרת  Release-Acquire מבטיחים סדר הפצה של כתיבות, כמו שהוזכר קודם פעולות release מגיעות עם מאפיין A-cumulative, וזה ברור אם רואים את המימוש של release ב-PPC, ה-<code>lwsync</code> מגיע לפני הכתיבה ומאלץ את כל הכתיבות שהתפשטו למעבד שמבצע את המחסום לפני ביצוע המחסום להתפשט למעבד שקורא את הערך שנכתב על ידי ה-release כי לפני שהוא ראה את הערך הוא היה חייב לקבל את המחסום ולפני שהוא קיבל את המחסום הוא היה חייב לקבל את כל הכתיבות שהתפשטו למעבד שביצע את ה-release. בגלל שהסדר של השרשרת מתבסס על הפצה של הכתיבות בין המעבדים בשרשרת אז מעבדים מחוץ לשרשרת לא בטוח יקבלו את הכתיבות בשרשרת.</p>
<h2 id="מימוש-בקרנל">
  מימוש בקרנל
  <a class="heading-link" href="#%d7%9e%d7%99%d7%9e%d7%95%d7%a9-%d7%91%d7%a7%d7%a8%d7%a0%d7%9c">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>בקרנל כברירת מחדל ה-<code>smp_load_acquire</code> הוא הזוג <code>READ_ONCE() + smp_mb()</code> (כלומר <code>READ_ONCE</code> ואחריו <code>smp_mb</code>).
ה-<code>smp_load_acquire</code> מוגדר ב-<code>include/asm-generic/barrier.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"> <span class="nf">__smp_load_acquire</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>						\
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">({</span>									\
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nf">__unqual_scalar_typeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="n">___p1</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>		\
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="nf">compiletime_assert_atomic_type</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>				\
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="nf">__smp_mb</span><span class="p">();</span>							\
</span></span><span class="line"><span class="ln">6</span><span class="cl">	<span class="p">(</span><span class="nf">typeof</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">))</span><span class="n">___p1</span><span class="p">;</span>						\
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">})</span>
</span></span></code></pre></div><p>השימוש בהגדרה הזאת היא הכללית אלה אם מוגדר לארכיטקטורה מסויימת מימוש אחר של <code>smp_load_acquire</code> כמו בחלק מהמקרים (למשל ב-x86_64 ו-aarch64) שבהם יש מחסומים קלים יותר מהמחסום המלאה <code>smp_mb</code> שמבטיחים את ההתנהגות הרצויה ב-<code>acquire</code>.</p>
<hr>

      </div>


      <footer>
        
  <h3 dir="rtl">
    מקורות
  </h3>
  <ul dir="ltr">
  
    <li>
      <a href="https://developer.arm.com/documentation/102336/0100/Load-Acquire-and-Store-Release-instructions">https://developer.arm.com/documentation/102336/0100/Load-Acquire-and-Store-Release-instructions</a>
    </li>
  
    <li>
      <a href="https://preshing.com/20120913/acquire-and-release-semantics/">https://preshing.com/20120913/acquire-and-release-semantics/</a>
    </li>
  
    <li>
      <a href="https://preshing.com/20130922/acquire-and-release-fences">https://preshing.com/20130922/acquire-and-release-fences</a>
    </li>
  
    <li>
      <a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">https://www.kernel.org/doc/Documentation/memory-barriers.txt</a>
    </li>
  
    <li>
      <a href="https://lwn.net/Articles/827180/">https://lwn.net/Articles/827180/</a>
    </li>
  
    <li>
      <a href="http://infolab.stanford.edu/pub/cstr/reports/csl/tr/95/685/CSL-TR-95-685.pdf">http://infolab.stanford.edu/pub/cstr/reports/csl/tr/95/685/CSL-TR-95-685.pdf</a>
    </li>
  
    <li>
      <a href="https://en.wikipedia.org/wiki/Consistency_model">https://en.wikipedia.org/wiki/Consistency_model</a>
    </li>
  
    <li>
      <a href="https://documentation-service.arm.com/static/65fdad3c1bc22b03bca90781?token=">https://documentation-service.arm.com/static/65fdad3c1bc22b03bca90781?token=</a>
    </li>
  
    <li>
      <a href="https://lwn.net/Articles/847481/">https://lwn.net/Articles/847481/</a>
    </li>
  
    <li>
      <a href="https://developer.arm.com/documentation/100941/0101/Barriers">https://developer.arm.com/documentation/100941/0101/Barriers</a>
    </li>
  
    <li>
      <a href="https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/ordering.txt">https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/ordering.txt</a>
    </li>
  
    <li>
      <a href="https://github.com/torvalds/linux/blob/master/Documentation/core-api/refcount-vs-atomic.rst">https://github.com/torvalds/linux/blob/master/Documentation/core-api/refcount-vs-atomic.rst</a>
    </li>
  
    <li>
      <a href="https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/recipes.txt">https://github.com/torvalds/linux/blob/master/tools/memory-model/Documentation/recipes.txt</a>
    </li>
  
    <li>
      <a href="https://www.kernel.org/doc/Documentation/atomic_bitops.txt">https://www.kernel.org/doc/Documentation/atomic_bitops.txt</a>
    </li>
  
    <li>
      <a href="http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/toplas21.pdf">http://www0.cs.ucl.ac.uk/staff/j.alglave/papers/toplas21.pdf</a>
    </li>
  
    <li>
      <a href="https://krinkinmu.github.io/2024/04/20/arm-synchronization.html">https://krinkinmu.github.io/2024/04/20/arm-synchronization.html</a>
    </li>
  

        

<section class="see-also">
  
    
    
    
      <h3 id="רואה-עוד-ב-barriers" dir="rtl">        רואה עוד ב barriers
        <a class="heading-link" href="#%d7%a8%d7%95%d7%90%d7%94-%d7%a2%d7%95%d7%93-%d7%91-barriers">
          <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
          <span class="sr-only">Link to heading</span>
        </a>
      </h3>
      <nav>
        <ul>
        
        
          
            <li>
              <a href="/he/posts/barriers/amba-ace-barrier/">AMBA ACE Barrier</a>
            </li>
          
        
          
        
          
            <li>
              <a href="/he/posts/barriers/mb/">mb</a>
            </li>
          
        
        </ul>
      </nav>
    
  
</section>


        
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script><style>
  .katex {
    direction: ltr;
    display: inline-flex;
    flex-direction: row-reverse;
    unicode-bidi: embed;
  }
</style>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
     Michael Shalitin 
    ·
    
    מופעל על ידי <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "316bf5f2576c4cb68b54c0b2a91cb739"}'></script>



  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
