<!DOCTYPE html>
<html lang="he" dir="rtl">

<head>
  <title>
  Dentry · Michael Shalitin
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">


<meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests; block-all-mixed-content; default-src 'self'; child-src 'self'; font-src 'self' https://fonts.gstatic.com https://cdn.jsdelivr.net/; form-action 'self'; frame-src 'self' https://www.youtube.com; img-src 'self'; object-src 'none'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com/ https://cdn.jsdelivr.net/; script-src 'self' 'unsafe-inline' default-src 'unsafe-eval' https://www.google-analytics.com https://cdn.jsdelivr.net/ https://static.cloudflareinsights.com https://cloudflareinsights.com; connect-src 'self' https://www.google-analytics.com https://static.cloudflareinsights.com https://cloudflareinsights.com;">




<meta name="author" content="Michael Shalitin">
<meta name="description" content="Kernel developer">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Dentry">
  <meta name="twitter:description" content="Kernel developer">

<meta property="og:url" content="https://smichaelshal.github.io/he/posts/dentry/">
  <meta property="og:site_name" content="Michael Shalitin">
  <meta property="og:title" content="Dentry">
  <meta property="og:description" content="Kernel developer">
  <meta property="og:locale" content="he">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-12-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2023-12-12T00:00:00+00:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Kernel">
    <meta property="article:tag" content="Filesystem">
    <meta property="article:tag" content="Cache">
    <meta property="article:tag" content="Dentry">
    <meta property="article:tag" content="Dcache">




<link rel="canonical" href="https://smichaelshal.github.io/he/posts/dentry/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.6c967191184c40e901e41977158c33a73a2cfa2d9413cf73dddd6732eeae7af4.css" integrity="sha256-bJZxkRhMQOkB5Bl3FYwzpzos&#43;i2UE89z3d1nMu6uevQ=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-dark">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="https://smichaelshal.github.io/he/">
      Michael Shalitin
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/he/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/he/posts/">Blog</a>
            </li>
          
        
        
          
          
          
            
              
                <li class="navigation-item menu-separator">
                  <span>|</span>
                </li>
                
              
              <li class="navigation-item">
                <a href="/posts/dentry/">🇬🇧</a>
              </li>
            
          
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://smichaelshal.github.io/he/posts/dentry/">
              Dentry
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2023-12-12T00:00:00Z">
                דצמבר 12, 2023
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-newspaper" aria-hidden="true"></i>
              
            </span>
          </div>
          
          
          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/he/tags/linux/">Linux</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/kernel/">Kernel</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/filesystem/">Filesystem</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/cache/">Cache</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/dentry/">Dentry</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/dcache/">Dcache</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/icache/">Icache</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/inode/">Inode</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/super-block/">Super-Block</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/lookup/">Lookup</a>
    </span>
      <span class="separator">•</span>
    <span class="tag">
      <a href="/he/tags/file/">File</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        
        
        
        

        
          
            <p>בלינוקס  כמו בשאר משפחת Unix אחד מהדברים הראשונים שלומדים הוא שכל דבר הוא קובץ (<a href="https://en.wikipedia.org/wiki/Everything_is_a_file"  class="external-link" target="_blank" rel="noopener">Everything is a file</a>) וכבר הדבר הבסיסי הזה מראה לנו כמה קבצים זה דבר משמעותי בלינוקס, ובגלל זה גם לומדים על links ו-inodes אבל יש עוד כמה אחים לא פחות חשובים במשפחה הזאת שהם פחות מוכרים מה-<code>inode</code> המפורסם.
כל המשפחה הזאת שמתארת את מערכת הקבצים יושבת בשכבה בקרנל שנקראת <code>VFS</code> - <a href="https://www.kernel.org/doc/html/next/filesystems/vfs.html"  class="external-link" target="_blank" rel="noopener">Virtual File System</a> והיא מספקת את ממשק מערכת הקבצים לתוכנות userspace וגם מספקת הפשטה בתוך הקרנל שמאפשרת להטמעות שונות של מערכות קבצים להתקיים במקביל. יש מספר אובייקטים מרכזיים ב-vfs כמו: <code>superblock</code>, <code>file</code>, <code>dentry</code>, <code>vfsmount</code> ועוד.
במאמר הזה אני אתרכז ב-<code>dentry</code> שהוא אובייקט מרכזי וחשוב בקרנל.</p>
<p>אבל רגע, לפני הכל למה כדאי ללמוד על ה-<code>dentry</code>?</p>
<ul>
<li>ההבנה כיצד הקרנל מנהל את ה-dentries היא בסיסית להבנת המבנה הכולל של מערכת הקבצים.</li>
<li>אם אתה מעורב בפיתוח או תרומה למערכות קבצים לקרנל, הבנת ה-dentry היא .חיונית מפתחי מערכות קבצים צריכים לעבוד עם מבני dentries כדי להבטיח אינטגרציה נכונה עם תשתית מערכת הקבצים של הקרנל.</li>
<li>הבנת dentry היא בעלת ערך בעת איתור באגים ופתרון בעיות הקשורות למערכת הקבצים. ידע כיצד הקרנל מנהל dentries יכול לעזור באבחון ותיקון בעיות הקשורות לגישה לקבצים.</li>
<li>ה-dcache subsystem הוא רכיב חשוב ומרכזי יחסית בקרנל, הוא משתמש בהרבה טכניקות ועקרונות חשובים של הקרנל ולכן ניתן ללמוד ממנו על הרבה תתי מערכות אחרות ועקרונות מורכבים ומעניינים.</li>
</ul>
<p>במאמר הזה אני אסביר על ה-dcache וה-dentry בקרנל, בתחילת המאמר אני אתן הסבר קצר יחסית כדי לתת רקע כללי, ולאחר מכן אני אצלול יותר לעומק ואסביר על מספר נושאים:</p>
<ul>
<li>אסביר בקצרה על תהליך ה-lookup</li>
<li>ה-<code>struct dentry</code></li>
<li>דגלים מעניינים של ה-<code>dentry</code></li>
<li>OOP &amp; Dentry</li>
<li>dcache hash tables</li>
<li>פונקציות מרכזיות</li>
</ul>
<p>וכן גם אגע קצת בנושאים מסביב שקשורים בצורה הדוקה ל-dentry:</p>
<ul>
<li>
<p>lockref</p>
</li>
<li>
<p>qstr</p>
</li>
<li>
<p>אסביר בקצרה על ה-rcu</p>
</li>
<li>
<p>bl_hlist</p>
</li>
<li>
<p>bit spinlock</p>
</li>
</ul>

            
          
            <h3 id="מה-זה-dcache">
  מה זה Dcache
  <a class="heading-link" href="#%d7%9e%d7%94-%d7%96%d7%94-dcache">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>ה-dcache (קיצור של directory cache) הוא רכיב בשכבת מערכת הקבצים הווירטואלית (VFS). זהו cache המאחסן מידע על directory entries או בקיצור dentries.</p>
<p>ה-dcache מספק מנגנון חיפוש מהיר לגישה לקבצים ולתיקיות לפי שמם.</p>
<p>כאשר ניגשים לקובץ או תיקייה, הקרנל מחפש ב-dcache כדי למצוא את ה-dentry המתאים. אם ה-dentry נמצא ב-cache, הקרנל יכול לאחזר במהירות את ה-metadata המשויכים ולבצע את הפעולה המבוקשת. מנגנון ה-caching זה משפר את ביצועי מערכת הקבצים על ידי הפחתת הצורך לבצע פעולות io יקרות לדיסק  עבור כל גישה לקובץ.</p>
<p>ה-dcache מאורגן במספר דרכים על מנת לאפשר גישה מהירה לנתונים:</p>
<ul>
<li>
<p>ה-dcache מאורגן כטבלת hash, כאשר כל ערך מתאים לערך תיקייה ייחודי. טבלת ה-hash מאפשרת חיפוש יעיל על סמך שם הערך. כאשר נוצרת dentry חדש או גישה קיימת, היא מתווספת ל-dcache או נחפשת בו.</p>
</li>
<li>
<p>ובמקביל מבני dentries מאורגנים במבנה דמוי עץ היררכי התואם את מבנה התיקיות של מערכת הקבצים. מבנה זה מאפשר מעבר וחיפוש יעילים של תיקיות וקבצים, מה שמאפשר לקרנל לאתר ולגשת לקבצים במהירות.</p>
</li>
</ul>
<p>ה-dcache אחראי גם לשמירה על עקביות וסנכרון. מנעולים וסמפורים שונים משמשים כדי להגן על שלמות ה-dcache ולהבטיח שפעולות במקביל על אותו dentry או תיקייה מסודרת כהלכה.</p>
<p>בסך הכל, ה-dcache ממלא תפקיד מכריע בפעולות מערכת הקבצים של הקרנל על ידי מתן מנגנון שמירה ב-cache לחיפוש יעיל וגישה לערכי תיקייה, שיפור הביצועים של פעולות מערכת הקבצים.</p>
<p>התפקיד שלו הוא לשמור על תמונה עדכנית של כל מערכת הקבצים על ה-ram, כלומר הוא שומר בעזרת אובייקטי dentry את ההרכייה והיחסים בין תיקיות (directories) וקבצים (files) ויוצר עץ שבעזרתו ניתן לגשת לקבצים בתיקיות בצורה מהירה (יחסית לגישה לדיסק).</p>
<h3 id="מה-זה-dentry">
  מה זה Dentry
  <a class="heading-link" href="#%d7%9e%d7%94-%d7%96%d7%94-dentry">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>ה-dentry מתייחס למבנה נתונים המייצג ערך כניסה בתיקייה. זה קיצור של directory entry. מבנה ה-dentry משמש לייצוג וניהול תיקיות וקבצים בתוך מערכת הקבצים.</p>
<p>כל dentry מכיל מידע על קובץ או תיקייה ספציפיים, כגון השם שלו, ה-inode שלו (המאחסן metadata על הקובץ או התיקייה) ותכונות שונות אחרות. מבנה ה-dentry נוצר ומתוחזק על ידי הקרנל כדי לספק גישה יעילה לאובייקטים של מערכת הקבצים.</p>
<p>dentries חיוניים לפעולות שונות של מערכת הקבצים, כגון יצירת קבצים, מחיקה, שינוי שם וריזלוב (resolution) של נתיבים (path). הם גם מעורבים במנגנוני אחסון ב-cache של מערכות קבצים כדי להאיץ את הגישה לקבצים ותיקיות בשימוש תכוף.</p>
<p>באופן כללי, dentries ממלאות תפקיד מכריע בתשתית מערכת הקבצים של קרנל, מה שמאפשר ניהול יעיל של קבצים ותיקיות ומספק את הבסיס לפעולות מערכת קבצים מבוססות נתיבים.</p>
<p>ה-dentry הוא אובייקט שמייצג קשר בין inode לבין תיקייה , והוא מקשר ביניהם על ידי השם של הקובץ. ה-dentry משמש לגישה לכל קובץ בזמן תהליך החיפוש (lookup) של קובץ היעד.</p>
<p>בזמן lookup כל רכיב ב-path צריך שיהיה לו dentry משלו והוא משמש לחיפוש של המשך הרכיבים ב-path.
למשל בחיפוש של <code>/tmp/hello</code> יווצרו 3 dentries חדשות: root, tmp, hello. (הכוונה של root היא תקיית השורש של כל המערכת קבצים).</p>
<p>אפשר לראות עליו פרטים עליו בקובץ <code>proc/slabinfo/</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl">sudo grep <span class="s2">&#34;dentry&#34;</span> /proc/slabinfo
</span></span></code></pre></div><h3 id="negative-dentry">
  Negative Dentry
  <a class="heading-link" href="#negative-dentry">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>יש תפקיד חשוב ל-dentry גם בהאצה של lookup לקבצים שלא קיימים.</p>
<p>dentries שליליות נשמרות ב-dentry cache כדי לתעד את העובדה ששם ספציפי אינו קיים.
כדי לראות דוגמה למה צריך dentries שליליות, הפעל כל תוכנית פשוטה תחת מעקב וצפה בכמה syscall-ים חוזרים עם <code>ENOENT</code>.</p>
<p>לדוגמה הרצה של <code>ls</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="ln">1</span><span class="cl"> strace ls README 2&gt;<span class="p">&amp;</span>1<span class="p">|</span> grep <span class="s2">&#34;ENOENT&#34;</span>
</span></span></code></pre></div><p>כדי קצת יותר לעומק על negative dentry צריך להסביר משהו קטן  לפני זה :
כל dentry מכיל שדה <code>d_inode</code> שהוא מצביע ל-inode של הקובץ, הוא יכול להכיל בשדה גם <code>NULL</code>.
אם ה-d_inode מצביע ל-inode קיים אז הוא נקרא positive, אחרת הוא negative.
בתחילת חייו של ה-dentry הוא נוצר לפני שהוא מחובר ל-inode ולכן הוא מתחיל כ-negative.
dentry חיובי יכול להפוך לשלילי במהלך חייו, למשל כשקובץ נמחק, או מערכת קבצים מנותקת (umount).</p>
<p>תהליך ה-lookup מנסה לחפש במורד העץ את הקובץ הרצוי ובמהלך החיפוש הוא יוצר בתחילה dentry ואחרי זה הוא מנסה לחפש אם קיים לו inode מתאים בתקיית האבא לכל רכיב ב-path, אם הוא מוצא inode הוא ממשיך בתהליך, ואם הוא לא מוצא אז חוזרת שגיאה, אבל הוא עדיין משאיר (לרוב) את ה-dentry שנוצרה ב-dcache, זה נעשה בגלל שהרבה פעמים נעשה חיפוש של קובץ שלא קיים מספר פעמים ובמקום כל פעם לנסות לחפש אותו מחדש בדיסק, אז אפשר לחסוך את זה ומחפשים את היעד ב- dcache ואם מגיעים ל-dentry השלילית אז יודעים שהקובץ לא קיים.</p>
<p>יש הרבה זמן בעיה עם denries שליליות (<a href="https://lwn.net/Articles/890025/"  class="external-link" target="_blank" rel="noopener">למעלה מ-20 שנים</a>), הבעיה היא לא בעיה רק שלהם אלה בעיה כללית של ניהול cache, הבעיה היא שכל פעם שיש lookup על dentry לא קיים נוצר dentry שלילית, וזה לפעמים נכון לשמור אות כי יש חיפושים חוזרים, אבל לפעמים זה בזבוז כי לא נעשה חיפוש עוד של אותו dentry והוא סתם תופס מקום בזכרון, נעשו דיונים בנשוא מספר פעמים אבל לא יצא מהם תשובה לאיך לשפר את המצב.</p>
<h3 id="dentry--links">
  Dentry &amp; links
  <a class="heading-link" href="#dentry--links">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>צריך לזכור שבלינוקס כל inode יכול לשמש למספר קבצים שונים, התוכן הוא אותו תוכן אבל הקובץ עצמו יושב במקומות שונים במערכת הקבצים, כלומר יכול להיות מספר dentries שמכילים את מצביע לאותו inode וזה מצב רגיל לגמרי, זה נוצר עם שימוש במספר לינקים לקובץ.</p>
<p>אבל יש קבצים מסויימים שאסור שיהיה להם מספר לינקים ואלו הם תיקיות, יש איסור שנוצר בגלל שיש עם הרעיון הזה מספר בעיות:</p>
<ul>
<li>
<p>יש שימוש באלגוריתמים בקרנל שעושים סריקות וחיפוש בעץ והמצב של מספר כניסות לאותו תיקייה הוא בעייתי להם, כי זה כבר לא מבנה של עץ והוא יכול להפוך לגרף לא מכוון שאפשר לחזור למקומות שכבר סרקו.</p>
</li>
<li>
<p>כשרוצים לחזור אחורה לתקיית אב משתמשים ב- <code>..</code> (dotdot) אבל כשיש מספר כניסות לכל תיקייה כבר לא ברור מי זה האבא שצריך להגיע אליו כשחוזרים אחורה.</p>
</li>
<li>
<p>ריבוי לינקים ל-directories שובר את הכללים שהקרנל קבע לעצמו וזה יכול לגרום <a href="https://lwn.net/Articles/545119/"  class="external-link" target="_blank" rel="noopener">לבעיות נעילה כמו deadlock</a>.</p>
</li>
</ul>
<p>יש עוד בעיות שנגרמות מהרעיון הזה, וזה אפשרי לפתור כנראה את הבעיות ולאפשר ריבוי לינקים לתיקיות אבל זה לא דבר ממש חשוב לדעת מעצבי הקרנל אז פשוט לא נוגעים בזה.</p>
<h3 id="dentry--slab">
  dentry &amp; slab
  <a class="heading-link" href="#dentry--slab">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>כל dentry מוקצה מתוך ה-slab allocator ומנוהל בעזרתו בצורה של lru (קיצור של least recently used).
אני לא ארחיב על ה-slab allocator  יותר מידי כי מגיע לו מאמר נפרד, אבל אסביר בקצרה עליו.</p>
<p>ה-slab allocator הוא שכבת עזר להקצאה וניהול של אובייקטים (structs).
הוא משתמש בשמירה של זיכרון מוקצה המכיל אובייקט נתונים מסוג מסוים לשימוש חוזר בהקצאות עוקבות של אובייקטים מאותו סוג. זה מקביל ל-pool אובייקטים בזיכרון.</p>
<p>ה-slab allocator עוזר למתכנת כדי שיוכל להקצות בצורה נוחה ויעלה יותר במקום להשתמש ישירות במנגנון הקצאת page-ים וה-buddy system.</p>
<p>הוא מאפשר:</p>
<ul>
<li>הקצאת בלוקים קטנים של זיכרון כדי לסייע בביטול פיצול פנימי שייגרם אחרת על ידי ה-buddy system.</li>
<li>שמירה ב-cache של אובייקטים נפוצים כך שהמערכת לא מבזבזת זמן בהקצאה, אתחול והשמדת אובייקטים.</li>
<li>ניצול טוב יותר של cache החומרה על ידי יישור אובייקטים ל-cache L1 או L2.</li>
</ul>
<h4 id="drop-caches">
  drop caches
  <a class="heading-link" href="#drop-caches">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>קיים <code>sysctl</code> ניתן לקרוא לו על ידי הקובץ  <code>/proc/sys/vm/drop_caches</code>.
ניתן לכתוב לקובץ  <code>2</code> וזה מפעיל ניקוי של slab ללא שימוש:
לקריאה נוספת בדקו ב-<code>man proc</code> וגם אפשר <a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt"  class="external-link" target="_blank" rel="noopener">לקרוא בתיעוד הקרנל באתר</a>
את המימוש של ה-<code>sysctl</code> הזה אפשר למצוא ב-<code>fs/drop_caches.c</code>.</p>

            
          
            <div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="kt">seqcount_spinlock_t</span> <span class="n">d_seq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_hash</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">d_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="k">struct</span> <span class="n">qstr</span> <span class="n">d_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">d_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="p">];</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">struct</span> <span class="n">lockref</span> <span class="n">d_lockref</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="o">*</span><span class="n">d_op</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">d_sb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">d_time</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="kt">void</span> <span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">		<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_lru</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">		<span class="kt">wait_queue_head_t</span> <span class="o">*</span><span class="n">d_wait</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_child</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">d_subdirs</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">d_alias</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">		<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_in_lookup_hash</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">d_rcu</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">	<span class="p">}</span> <span class="n">d_u</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h1 id="fields-in-struct">
  Fields In struct
  <a class="heading-link" href="#fields-in-struct">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="השדה-d_hash">
  השדה <code>d_hash</code>:
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_hash">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>struct hlist_bl_node d_hash;</code></p>
<p>הוא שדה שמשמש לגישה לעץ ה-dcache בזמן חיפוש dentry, ה-<code>d_hash</code> הוא מצביע ל-<code>node</code> בתוך הטבלה <code>dentry_hashtable</code> (היא הטבלת hash הגדולה של ה-dcache), וה-hash מחושב לפי הערך של ה-dentry אב והשם של dentry עצמו.</p>
<h2 id="קשר-משפחתי-השדות-d_parent-d_child-d_subdirs">
  קשר משפחתי: השדות <code>d_parent</code>, <code>d_child</code>, <code>d_subdirs</code>
  <a class="heading-link" href="#%d7%a7%d7%a9%d7%a8-%d7%9e%d7%a9%d7%a4%d7%97%d7%aa%d7%99-%d7%94%d7%a9%d7%93%d7%95%d7%aa-d_parent-d_child-d_subdirs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="השדה-d_parent">
  השדה <code>d_parent</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_parent">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct dentry *d_parent;</code>
השדה <code>d_parent</code> משמש כדי להצביע על ה-dentry אב.</p>
<h3 id="השדה-d_subdirs">
  השדה <code>d_subdirs</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_subdirs">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct list_head d_subdirs;</code></p>
<p>השדה <code>d_subdirs</code> הוא רשימה מקושרת המשמשת לשמירת כל הבנים של ה-dentry, כלומר כל הקבצים והתיקיות שנמצאים תחת אותה תיקייה.
ועוד דרך להסתכל על ה-<code>d_subdirs</code> היא כמובן רשימה של אחים.</p>
<p>לגישה לעץ ה-dentry יש שני מצבים, האחד הוא &ldquo;מעבר&rdquo; והשני הוא &ldquo;חיפוש&rdquo;. מה שנקרא מעבר הוא לתת צומת root של תת-עץ של תיקייה, לעבור ולבקר בכל הצמתים הצאצאים שלו, ולצאת עד לתנאי היציאה. בזמן זה נעשה שימוש בשדה d_subdirs.</p>
<h3 id="השדה-d_child">
  השדה <code>d_child</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_child">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct list_head d_child;</code></p>
<p>השדה הוא ה-node עצמו שמופיע ברשימה <code>d_subdirs</code> של האב, כלומר האבא מחזיק מצביע ל-d_child של אחד הבנים שלו, והוא מחזיק בתוך ה-d_child את הקישור לאח שלו וביחד הם יוצרים רשימה.</p>
<h2 id="השדה-d_alias">
  השדה <code>d_alias</code>:
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_alias">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>struct hlist_node d_alias;</code>
הוא שדה המשמש כרשימה של dentries בעלי אותו inode, המקרה קורה בגלל שלינוקס תומך בריבוי לינקים (hard links) לאותו inode על ידי מספר קבצים.</p>
<h2 id="השדות-d_iname-ו-d_name">
  השדות <code>d_iname</code> ו-<code>d_name</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%95%d7%aa-d_iname-%d7%95-d_name">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>השדות האלו משמשים על מנת להחזיק את השם של ה-dentry.</p>
<h3 id="השדה-d_iname">
  השדה <code>d_iname</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_iname">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>unsigned char d_iname[DNAME_INLINE_LEN];</code>
כמו שהשם של השדה מרמז (d_iname הוא קיצור של <code>d_name</code> ו-<code>inline</code>) הוא שדה שמשמש אם השם קצר, בגלל שאז השם יכול להכנס לתוך ה-dentry עצמו וכך למנוע גישה לזיכרון מחוץ לאובייקט וזה מייעל את הגישה למידע (גם מבחינת גישה ל-page עצמו, וגם זה מונע פגיע ב-cache), אם השם ארוך מידי אז צריך להשתמש באובייקט חיצוני שהמצביע שלו הוא השדה <code>d_name</code>.</p>
<h3 id="השדה-d_name">
  השדה <code>d_name</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_name">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct qstr d_name;</code>
השדה הוא מסוג <code>qstr</code> שהוא היצוג של <code>UTF-8</code> בקרנל.</p>
<h3 id="השדה-d_fsdata">
  השדה <code>d_fsdata</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_fsdata">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>void *d_fsdata;</code></p>
<p>השדה הוא שדה כללי שכל מערכת קבצים יכולה להחליט להשתמש בו אם היא צריכה לחבר מידע נוסף ל-dentry struct.</p>
<h3 id="השדה-d_sb">
  השדה <code>d_sb</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_sb">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct super_block *d_sb;</code>
מצביע ל-<code>struct super_block</code> של מערכת הקבצים שלה שייך ה-dentry.
(ה-struct גדול ויחסית מורכב ולא ארחיב עליו במאמר הזה, אולי יוסבר בהמשך במאמר נפרד על mount).</p>
<h3 id="השדה-d_inode">
  השדה <code>d_inode</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_inode">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct inode *d_inode;</code>
הוא מצביע ל-<code>struct inode</code> המשוייך ל-dentry, הוא יכול להכיל מצביע תקין ל-inode של הקובץ או שהוא יכול להכיל ערך <code>NULL</code>: אם ה-dentry שלילית.</p>
<h3 id="השדה-d_flags">
  השדה <code>d_flags</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_flags">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>unsigned int d_flags;</code>
מכיל את הדגלים של ה-<code>dentry</code>.</p>
<h3 id="השדה-d_seq">
  השדה <code>d_seq</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_seq">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>seqcount_spinlock_t d_seq;</code>
הוא מנעול <code>seqlock</code> המשמש על מנת לבדוק שלא נעשה שימוש בזמן הנעילה.</p>
<h3 id="השדה-d_op">
  השדה <code>d_op</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_op">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>const struct dentry_operations *d_op;</code></p>
<p>הוא מצביע ל-vtable של ה-dentry שמכיל בתוכו את כל ה-methods הרלוונטים של ה-dentry, ערכים ב-vtable יכולים  להיות מוגדרים ל-<code>NULL</code>, מכיוון שהם אופציונלים או שה-VFS משתמש בברירת מחדל.</p>
<p>את ה-<code>d_op</code> מעדכנים על ידי הפונקציה <code>d_set_d_op</code> שעוזרת בניהול של ה-vtable וגורמת להתנהגות ברירת מחדל במקרה של NULL ומעדכנת את הדגלים בהתאם ל-methods הקיימות.</p>
<p>בנוסף יש עטיפות מסויימות ל-methods לדוגמה <code>d_revalidate</code> בקובץ <code>fs/namei.c</code> שהמטרה שלהן היא גם לגרום להתנהגות מתאימה במקרה של NULL.</p>
<p><a href="https://www.kernel.org/doc/html/latest/filesystems/vfs.html#id3"  class="external-link" target="_blank" rel="noopener">הסבר מפורט</a></p>
<h3 id="השדה-d_lru">
  השדה <code>d_lru</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_lru">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>השדה <code>d_lru</code> משמש כדי לקשר dentry שכבר לא בשימוש לרשימת ה-lru של ה-<code>super_block</code> שלו.
לעולם לא מסתכלים על d_lru עד שהוא מפסיק להיות ב-lookup ולכן הוא יכול להתקיים באותו union עם השדה <code>d_wait</code> שמשמש רק בזמן שהוא ב-lookup.</p>
<h3 id="השדה-d_wait">
  השדה <code>d_wait</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_wait">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>wait_queue_head_t *d_wait;</code>
השדה הוא ראש של <code>wait queue</code> ומשמש רק בזמן שה-dentry ב-lookup.
הוא נועד על מנת למנוע מצב שיש מספר thread-ים שמנסים בו זמנית לעשות lookup ויכולים להוסיף dentry חדשה ולגרום להתנגשות בטבלת hash.</p>
<h3 id="השדה-d_in_lookup_hash">
  השדה <code>d_in_lookup_hash</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_in_lookup_hash">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>struct hlist_bl_node d_in_lookup_hash;</code></p>
<p>השדה <code>d_in_lookup_hash</code> שנמצא תחת ה-<code>d_u</code> (שהוא union) משמש את <code>d_alloc_parallel</code> והוא כמו שהוא נשמע, כש-<code>dentry</code> הנוכחי נמצא תחת חיפוש השדה מכיל את הכניסה של ה-<code>dentry</code> ב-<code>in_lookup_hashtable</code>.</p>
<h3 id="השדה-d_rcu">
  השדה <code>d_rcu</code>
  <a class="heading-link" href="#%d7%94%d7%a9%d7%93%d7%94-d_rcu">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>השדה d_rcu שנמצא תחת ה-<code>d_u</code> והשדה משמש רק לשחרור הזיכרון הסופי של האובייקט.
בגלל שה-<code>dentry</code> הוא אובייקט שמשתמש ב-<code>call_rcu</code> אז הוא צריך להשתמש בשדה שמוכל בתוכו בצורת embedded בגלל שהגישה שה-<code>call_rcu</code> מאפשר הוא דרך פרמטר <code>struct rcu_head</code> בפונקציית ה-callback.</p>
<p>לכן פונקצית השחרור הסופי <code>__d_free</code> נראת כך:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nf">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_rcu</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="nf">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>עד כאן הוסבר למה צריך בכלל שדה מסוג <code>struct rcu_head</code> אבל יש כאן עוד משהו מוזר בשדה הזה - למה הוא יושב בתוך <code>d_u</code>. הסיבה לזה היא חסכון בגודל האובייקט <code>dentry</code>, בגלל שהוא אובייקט שמופיע בזכרון הרבה מאוד פעמים כל חסכון חשוב.
הרעיון של השילוב ביניהם דומה קצת לרעיון למה השדות <code>d_alias</code> ו-<code>d_in_lookup_hash</code> שולבו, במקרה הזה גם השדות לא מתקיימים בו זמנית ולכן אפשר לעשות את זה. המימוש הזה נשען על ההנחה שבאמת יש שימוש אחד לשדה <code>d_rcu</code> וזה רק שחרור סופי של האובייקט ולכן בשלב הסופי של מעגל החיים של ה-<code>dentry</code> כבר אין שימוש יותר לשדות  <code>d_alias</code> ו-<code>d_in_lookup_hash</code> ולא ניגשים אליהם ובשלבים לפני השחרור של ה-<code>dentry</code> אין שימוש ב-<code>d_rcu</code> ורק  ב-<code>d_alias</code> או <code>d_in_lookup_hash</code>.</p>
<hr>

            
          
            <h1 id="תהליך-ה-lookup">
  תהליך ה-Lookup
  <a class="heading-link" href="#%d7%aa%d7%94%d7%9c%d7%99%d7%9a-%d7%94-lookup">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>התהליך של חיפוש הוא תהליך מורכב והוא בעצמו דורש מאמר נפרד, אבל אסביר עליו בקצרה כאן רק כדי לתת רקע כללי:</p>
<h2 id="2-סוגי-walking">
  2 סוגי walking
  <a class="heading-link" href="#2-%d7%a1%d7%95%d7%92%d7%99-walking">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>תהליך החיפוש משומש הרבה מאוד פעמים ולכן הוא חייב להיות מאוד יציב (כלומר לתת תוצאה נכונה) ובו זמנית גם מאוד מהיר.
2 הגישות סותרות זו את זו בגלל שאם רוצים משהו יציב אז הוא צריך לעשות הרבה בדיקות, ולכן הפרידו את תהליך ה-lookup ל-2 מקרים:</p>
<ul>
<li><code>REF-walk</code> - הוא כבד למדי עם מנעולים וספירות התייחסות, הוא לוקח את כל הנעילות שהוא צריך כדי לוודא שהכל נעשה בצורה נכונה ובלי התנגשויות.</li>
<li><code>RCU-walk</code> - הוא מנגנון שמשתמש במעט נעילות (יחסית ל-<code>REF-walk</code>) אבל הוא גם לא יודע להתמודד עם כל הבעיות ולכן אם הוא לא מצליח להתמודד עם הבעיה הוא מפסיק והחיפוש &ldquo;נופל&rdquo; מ-<code>RCU-walk</code> ל-<code>REF-walk</code>.</li>
</ul>
<p>כאשר מחפשים שם בתיקייה, REF-walk לוקח את <code>d_lock</code> על כל dentry מועמד שהוא מוצא בטבלת ה-hash ולאחר מכן בודק שהאב והשם נכונים. אז זה לא נועל את ההורה בזמן חיפוש ב-cache; זה נועל רק ילדים.</p>
<p>REF-walk משתמש ב-<code>rename_lock</code> כדי להגן מפני האפשרות של שרשראות hash ב-dcache משתנות בזמן שהן נמצאות בחיפוש. זה יכול לגרום לכישלון למצוא משהו שבאמת נמצא שם. כאשר RCU-walk לא מצליח למצוא משהו ב-dcache, בין אם הוא באמת שם או לא, הוא כבר יורד ל-REF-walk ומנסה שוב עם נעילה מתאימה. זה מטפל בצורה מסודרת בכל המקרים, כך שהוספת בדיקות נוספות על <code>rename_lock</code> לא יביא ערך משמעותי.</p>
<h2 id="מערכות-קבצים">
  מערכות קבצים
  <a class="heading-link" href="#%d7%9e%d7%a2%d7%a8%d7%9b%d7%95%d7%aa-%d7%a7%d7%91%d7%a6%d7%99%d7%9d">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>יש 2 סוגים של מערכות קבצים:</p>
<ul>
<li>מערכות קבצים מסוימות מבטיחות שהמידע ב-dcache תמיד מדויק לחלוטין (אבל לא בהכרח שלם). זה מאפשר ל-VFS לקבוע אם קובץ מסוים קיים או לא קיים מבלי לבדוק עם המערכת קבצים, ומשמעות הדבר היא שה-VFS יכול להגן על מערכת הקבצים מפני races מסוימים ובעיות אחרות. אלו בדרך כלל מערכות קבצים מקומיות כגון <code>ext3</code>, <code>XFS</code> ו-<code>Btrfs</code>.</li>
<li>מערכות קבצים אחרות אינן מספקות ערבות זו כי הן אינן יכולות, בדרך כלל אלה מערכות קבצים רשתיות. המערכות קבצים האלו מאפשרות ל-VFS לאמת מחדש מידע שמור, וחייבות לספק הגנה משלהן מפני races. ה-VFS יכול לזהות מערכות קבצים אלו על ידי הגדרת הדגל <code>DCACHE_OP_REVALIDATE</code> ב-dentry.</li>
</ul>
<h2 id="dcache-layout">
  dcache layout
  <a class="heading-link" href="#dcache-layout">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>כדי להבין יותר טוב את תהליך החיפוש של dentry ב-dcache צריך להבין איך שמור המידע עצמו ואיך הוא מסודר ומאורגן בזיכרון.</p>
<h4 id="ניהול-רשימת-lru">
  ניהול רשימת LRU
  <a class="heading-link" href="#%d7%a0%d7%99%d7%94%d7%95%d7%9c-%d7%a8%d7%a9%d7%99%d7%9e%d7%aa-lru">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>dentry עם ספירת התייחסות גדולה מ-0 נקראת dentry בשימוש. כאשר ספירת ההתייחסות של dentry מופחתת ל-0, כל הפעולות הפתוחות שבוצעו על ידי המשתמשים נסגרו, וה-dentry הופך ל-dentry ללא שימוש. dentry ללא שימוש ייכנסו תחילה לרשימת ה-<code>lru</code> של <code>super_block</code>, ממתינה לשימוש חוזר או לשחרור.</p>
<p>לכל <code>super_block</code> יש שדה <code>s_dentry_lru</code>, המשמש לשמירת רשימת ה-lru של כל dentry שאינה בשימוש, וה-dentry משתמש בשדה <code>d_lru</code> כדי לקשר אל רשימת lru זו. הפונקציות <code>d_lru_add</code> ו-<code>d_lru_del</code> מסופקות, המשמשים להוספת dentry או הסרה של רשימת ה-lru של <code>super_block</code> שלו, בהתאמה.</p>
<h3 id="dentry-tree">
  dentry tree
  <a class="heading-link" href="#dentry-tree">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>בנוסף לכל ה-hashtable-ים, יש עוד סדר שנעשה ב-dcache על מנת לאפשר גישה יעליה ומהירה, והמבנה הזה הוא עץ הירכיה של ה-dentries במערכת קבצים, כלומר יש קישורים בתוך כל dentry להורה שלו, לאחים שלו ואם הוא directory אז גם לבנים שלו אם יש לו.
הגישה הזאת לרוב משמשת בסריקות שבהן מחפשים לרוב dentries לפי קשר משפחתי (כלומר לפי הלינקים שלהם אחד לשני).
לדוגמה הפונקציה <code>d_walk</code> עושה שימוש בטכניקות סריקה לפי העץ.</p>
<h2 id="rcu--dcache">
  RCU &amp; Dcache
  <a class="heading-link" href="#rcu--dcache">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>המנגנון  RCU (read-copy-update) משמש כדי להבטיח שמבני dentries יישארו קיימים מספיק זמן כדי לבצע בדיקה מסויימת.
המנגנון RCU משמש בעיקר להגנה מפני מחיקת dentries.</p>
<p>בדיקת ההרשאה נעשית על ידי מערכת הקבצים, באמצעות פעולת <code>permission()</code>של ה-inode.</p>
<p>הערבות המיוחדת שה-<code>rcu</code> בשימוש של ה-dentry מספקת היא שמבני הנתונים המרכזיים: dentries, inodes, super_blocks ו-mounts - לא ישתחררו בזמן שהמנעול מוחזק.
הם עשויים להיות unlinked או בוטלו (invalidated) בדרך זו או אחרת, אך הזיכרון לא ישופץ (repurposed) כך שערכים בתחומים שונים עדיין יהיו בעלי משמעות.
זוהי הערבות היחידה ש-RCU מספק במקרה הזה;</p>
<h2 id="symlinks-lookup">
  Symlinks lookup
  <a class="heading-link" href="#symlinks-lookup">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>יש עוד מורכבות של חיפוש עם symlinks וזה מוסבר טוב <a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#a-walk-among-the-symlinks"  class="external-link" target="_blank" rel="noopener">במאמר</a> אבל כן הייתי רוצה להסביר משהו קטן שמוזכר שם: magic-links.</p>
<h3 id="magic-links">
  magic-links
  <a class="heading-link" href="#magic-links">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>דברים ב-<code>/proc</code> שנראים כמו קישורים סימליים אבל הם לא באמת (ולכן מכונים בדרך כלל &ldquo;magic-links&rdquo;) זה באמת הפניה לקובץ היעד, לא רק השם שלו.
​</p>
<hr>
<h2 id="lookup--inode">
  lookup &amp; inode
  <a class="heading-link" href="#lookup--inode">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>הרעיון של חיפוש cache המחזיר אובייקט לא שלם (אך נעול) רחוק מלהיות חדש.</p>
<p>חיפוש שמות ב-dcache מתרחש בתדירות גבוהה הרבה יותר מאשר חיפוש אינודים ב-icache, ולכן, בהתחשב בעובדה שהנתיבים החמים יותר נוטים להיות אופטימליים יותר, אין זה צריך להיות מפתיע שגרסת ה-dcache אינה פשוטה כמו גרסת ה-icache.</p>
<h3 id="חיפוש-הפוך">
  חיפוש הפוך
  <a class="heading-link" href="#%d7%97%d7%99%d7%a4%d7%95%d7%a9-%d7%94%d7%a4%d7%95%d7%9a">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>ניתן גם לבצע חיפוש הפוך (לא על ידי השם של הקובץ אלה על ידי מספר inode) בשימוש עם הפונקציה <code>iget_locked()</code> שמחפשת ב-inode cache  של הקרנל אחר inode שמספרו תואם לזה שנרשם במבנה ה-dentries <code>de</code>. הוא מחזיר מצביע לערך קיים, או, אם לא נמצא ערך, הוא מקצה ערך cache חדש לא מאותחל שהוא מחזיר ל-caller.</p>
<h3 id="dcache--mount-table">
  dcache &amp; mount table
  <a class="heading-link" href="#dcache--mount-table">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>ה-dcache משולב באופן הדוק עם ה-mount table שמתעד איזו מערכת קבצים מותקנת היכן. מה שבעצם mount table מאחסן הוא איזו dentry מותקן על איזו dentries אחרות.</p>
<h3 id="חיפוש-עם-מחיקה">
  חיפוש עם מחיקה
  <a class="heading-link" href="#%d7%97%d7%99%d7%a4%d7%95%d7%a9-%d7%a2%d7%9d-%d7%9e%d7%97%d7%99%d7%a7%d7%94">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>כאשר קובץ נמחק, זה יכול לבוא לידי ביטוי ב-cache: על ידי הגדרת d_inode ל-NULL, או על ידי הסרתו מטבלת ה-hash המשמשת לחיפוש השם בספריית האב. אם ה-dentry עדיין בשימוש, נעשה שימוש באפשרות השנייה מכיוון שזה חוקי לחלוטין להמשיך להשתמש בקובץ פתוח לאחר מחיקתו וה-dentries בסביבה עוזרת. אם ה-dentry לא בשימוש אחר (כלומר אם הספירה מחדש ב-d_lockref היא אחת), רק אז תוגדר d_inode ל-NULL. לעשות זאת בצורה זו יעילה יותר עבור מקרה נפוץ מאוד.</p>
<p>אז כל עוד מתקיימת הפניה שנספרה ל-dentry, ערך שאינו NULL -&gt;d_inode לעולם לא ישתנה.</p>
<h2 id="readdir--getdents">
  readdir &amp; getdents
  <a class="heading-link" href="#readdir--getdents">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>מכיוון שיש מצב הקשור ל-<code>readdir()</code> (כלומר מיקום תיקייה), זה לא ממש הגיוני לאפשר לשני thread-ים לקרוא <code>getdents()</code> באותו מתאר קובץ תיקייה במקביל. לקובץ struct המייצג את קובץ התיקייה הפתוחה יש נעילה שמונעת מ-<code>read()</code> ו-<code>lseek()</code> להתרחש במקביל; הוא משמש למניעת קריאות מקבילות<code> readdir()</code>/<code>getdents()</code>.</p>

            
          
            <ul>
<li>
<p>הדגל <code>DCACHE_REFERENCED</code>:
מדליקים אותו כשהוא כבר נמצא ברשימת ה-LRU ומנסים להחזיר אותו, הוא מסמן שה-dentry נמצא עדיין בשימוש ואסור לזרוק אותו (כמו שכתוב בתיעוד בקוד).</p>
<p>ניתן לכבות את הדגל רק כשמוציאים את ה-dentry מה-LRU.</p>
</li>
<li>
<p>הדגל <code>DCACHE_DONTCACHE</code>:
הדגל מסמן שצריך לזרוק את ה-dentry בסוף השימוש (הכוונה בסיום השימוש היא כשאין לו יותר משתמשים כשה-<code>d_lockref.count</code> הוא אפס), ואסור לשמור את ה-dentry ב-dcache. הדגל נבדק בפונקציה <code>retain_dentry</code>.</p>
</li>
<li>
<p>הדגל <code>DCACHE_DENTRY_CURSOR</code>:
משמש במערכות קבצים וירטואלית בעיקר (כמו ramfs) הוא מסמן dentry מיוחד שמשמש לעזר של פעולות במערכת קבצים, לדוגמה ב-ramfs הוא משמש ל-readdir ול-lseek בתיקיות.</p>
</li>
<li>
<p>הדגל <code>DCACHE_PAR_LOOKUP</code>:
משמש ב-d_in_lookup כדי לבדוק אם במקום אחר נעשה עבודה עם אותו dentry על מנת לסנכרן בין ריבוי משתמשים לאותו dentry, הדגל אומר אם מתבצע חיפוש (תהליך lookup).</p>
</li>
<li>
<p>הדגל <code>DCACHE_DENTRY_KILLED</code>:
נדלק כשהורגים dentry, הוא מסמן כמו שנשמע שהוא כבר מת ואסור להשתמש בו יותר.</p>
</li>
<li>
<p>הדגל <code>DCACHE_CANT_MOUNT</code>:
דלוק כשאסור לעשות mount על dentry, למשל כשמחוקים תיקייה ועדיין dentry שלו קיים, ונבדק על ידי <code>lock_mount</code> שרצה כשעושים פעולות על mount כמו הזזה של mount.</p>
</li>
<li>
<p>הדגל <code>DCACHE_MANAGE_TRANSIT</code>:
כשהדגל דלוק אז כל פעם לפני mount point אפשרי צריך לקרוא ל- <code>d_manage</code> שהיא method של dentry (הסבר בהמשך על d_manage). <a href="https://www.kernel.org/doc/html/latest/filesystems/autofs.html"  class="external-link" target="_blank" rel="noopener">ניתן לקרוא עוד בתיעוד של הקרנל.</a></p>
</li>
<li>
<p>הדגל <code>DCACHE_MOUNTED</code>:
הדגל מסמן dentry שעליו יש mount, אבל בגלל שבלינוקס יש ריבוי namespaces אז יכול להיות שהוא רק רמז ולא הבטחה, כי ייתכן שה-dentry לא יהיה mounted ב-namespace אחד ובאחר כן.</p>
</li>
<li>
<p>הדגל <code>DCACHE_NORCU</code>:
הדגל אומר שאסור להשתמש ב-callback בזמן שיחרור של ה-dentry, כלומר הוא חייב להשתחרר באופן מידי ללא אפשרות של עיכוב (delay).
הדגל משומש רק ב-<code>d_alloc_pseudo</code> כלומר כשאין אפשרות ל-lookup במערכת קבצים (כמו ב-pipes למשל).</p>
</li>
</ul>

            
          
            <p>למרות הקרנל כתוב בשפות תכנות לא מונחות עצמים זה לא מונע ממנו להשתמש בתבניות של OOP לפי הצורך.
בקרנל יש הרבה שימושים לדפוס oop ואחד המקומות הברורים לזה הוא ב-VFS ובפרט ב-dcache. בחלק הזה אסביר על הדפוס oop במימוש של ה-dentry.</p>
<h1 id="הסבר-כללי-על-oop-בקרנל">
  הסבר כללי על OOP בקרנל
  <a class="heading-link" href="#%d7%94%d7%a1%d7%91%d7%a8-%d7%9b%d7%9c%d7%9c%d7%99-%d7%a2%d7%9c-oop-%d7%91%d7%a7%d7%a8%d7%a0%d7%9c">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="הורשת-נתונים">
  הורשת נתונים
  <a class="heading-link" href="#%d7%94%d7%95%d7%a8%d7%a9%d7%aa-%d7%a0%d7%aa%d7%95%d7%a0%d7%99%d7%9d">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="הרחבה-באמצעות-unions">
  הרחבה באמצעות <code>unions</code>
  <a class="heading-link" href="#%d7%94%d7%a8%d7%97%d7%91%d7%94-%d7%91%d7%90%d7%9e%d7%a6%d7%a2%d7%95%d7%aa-unions">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הגישה הזאת, שהיא כנראה הברורה ביותר אך גם הפחות גמישה, היא להכריז על union כמרכיב אחד של המבנה המשותף, ולגבי כל יישום, להכריז על כניסה באותו union עם תחומים נוספים שהיישום המסוים צריך.
גישה זו להורשת נתונים היא פשוטה וישירה, אך היא גם מגושמת במקצת.
יש עם הגישה הזאת 2 בעיות עקריות:</p>
<ol>
<li>זה מכוער, יכול להיות מצב שיש מספר גדול של סוגי אובייקטים שיורשים מאובייקט מסויים וכל אחד מהם יצטרך להוסיף עוד שדה ל-union.</li>
<li>המימוש הזה מחייב את כל סוגי האובייקטים היורשים לשאת בשדות של אובייקטים יורשים אחרים גם אם הם לא צריכים את השדה, זה בעיה אמיתית בגלל שזה תופס עוד זיכרון מיותר.</li>
</ol>
<h3 id="embedded-structures">
  Embedded structures
  <a class="heading-link" href="#embedded-structures">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>במקום שהמבנה הפרטי יהיה מוטבע במבנה הנתונים המשותף, מבנה הנתונים המשותף מוטבע  (embedded) כעת במבנה הפרטי.
זה מונע בצורה מסודרת את שתי הבעיות עם unions, כעת למשל כל מערכת קבצים צריכה רק להקצות זיכרון לאחסון מבנה משלה ללא כל צורך לדעת דבר על מה שמערכות קבצים אחרות עשויות להזדקק לו.</p>
<p>הרבה פעמים ה-caller צריך להעביר ל-method את האובייקט שעליה היא צרכה לפעול, המימוש של מידע שהוא embedded ב-struct פותר את הבעיה עם המאקרו <code>container_of</code> כדי לבצע את אריתמטיקה המצביע הנחוצה, והמאקרו מאפשר למפות ממבנה נתונים embedded למבנה שבו הוא מוטבע בו.</p>
<p>למשל ב-<code>dentry</code> בשדה <code>d_u</code> שהוא union וזה בא לידי ביטוי בשחרור ה-dentry, בגלל שה-dentry משתמש ב-rcu אז הוא צריך להכיל שדה <code>rcu_head</code>, הדפוס הזה הוא כמו הורשה שה-dentry יורש ממחלקת אב מסויימת את rcu_head על מנת לאפשר שימוש של rcu.</p>
<p>השדה <code>d_u</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">		<span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">d_alias</span><span class="p">;</span>	<span class="cm">/* inode alias list */</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">		<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="n">d_in_lookup_hash</span><span class="p">;</span>	<span class="cm">/* only for in-lookup ones */</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">	 	<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">d_rcu</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	<span class="p">}</span> <span class="n">d_u</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</span></span></code></pre></div><p>הפונקציה <code>__d_free</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nf">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_rcu</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="nf">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>כאן אפשר לראות שעל מנת לשחרר את האובייקט צריך להשתמש במעקף כי יש לנו רק מצביע לשדה הפנימי head שהוא בתוך ה-dentry, וכדי להגיע לאובייקט עצמו צריך את <code>container_of</code>.</p>
<h2 id="methods">
  methods
  <a class="heading-link" href="#methods">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="vtables">
  vtables
  <a class="heading-link" href="#vtables">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>שימוש של methods ספציפי לאובייקט מסויים הוא נפוץ, ובהרבה שפות תכנות הוא ממומש בעזרת הרעיון של vtables (קיצור של <code>virtual function table</code>), יש לזה מספר סיבות:</p>
<p>הרבה פעמים הערכים בשדות של אובייקט משתנים אבל ה-methods נשארות קבועות ולכן זה רעיון טוב לאחד אותם למבנה אחד שהוא יכול להיות אחיד כלפי כולם ואז אפשר שיתקיים רק מופע אחד שלו בזכרון וכל אחד מהמופעים של האובייקט יכילו מצביע אליו וככה יש אפשרות לחסוך הרבה מקום בזיכרון אם אובייקט מרכזי מרכז בעצמו את כל ה-methods שאוביקטי בנים צריכים אם כולם בעלי אותם methods, למשל לרוב במערכת קבצים ה-methods של כל אובייקטי ה-<code>dentry</code> יצרכו את אותה השוואה ולכן צריכים את אותו מימוש של <code>d_compare</code> ולכן היה אפשר להעביר את המצביע הזה ב-vtable של ה-dentry אל ה-vtable של ה-super_block אבל חלק מהמערכות קבצים צריכות השוואה שונה כלפי <code>dentry</code> שונה ולכן צריך &ldquo;לבזבז&rdquo; עם הרבה שכפולים של המידע.</p>
<p>עוד יתרון שה-vtable נותן הוא גמישות, בדרך הזו כל משתמש של האובייקט יכול להחליט איזה methods הוא צריך ואפילו זה יכול לאפשר method שונה כלפי כל מופע של סוג האובייקט (במקרה ההפוך לדוגמה הראשונה - כאן במקום לאחד את כל ה-method לכל המופעים עושים את הפעולה ההפוכה).</p>
<h3 id="null-function-pointers">
  NULL function pointers
  <a class="heading-link" href="#null-function-pointers">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>בחלק המקרים מצביעי פונקציות מסוימים בטבלאות vtables מסוימות רשאיות להיות NULL.
לרוב ה-caller ל-methods הללו מכיל בדרך כלל בדיקה של המצביע שהוא NULL.
האפשרות למצביע NULL נותנת יישום default ל-method לפעמים, וגם הוא מאפשר למימושים שונים להשתמש ב-method שונים לפי הצורך, כלומר אם מערכת קבצים מסויימת צריכה method מסויים ומערכת קבצים אחרת לא אז רק זו שעושה שימוש ב-method תמלא את המצביע והשנייה תשאיר אותה NULL.</p>
<h3 id="void-pointers">
  <code>void</code> pointers
  <a class="heading-link" href="#void-pointers">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הרחבת סוג נתונים באמצעות מצביע להרחבה פרטית.
גישה זו התייחסה לשתי הבעיות עם unions, שכן אין צורך בשינויים בהצהרות משותפות וכל מימוש של סוג אובייקט משתמש רק בשטח הדרוש לו.
חסרון גדול של הגישה הזאת היא שיש צורך בגישת זיכרון נוספת של dereference כדי לגשת למבנה הפרטי מהמבנה המשותף.
זה מצריך הרבה הפניות זיכרון נוספות, או שזה דורש להחזיק את הכתובת של המבנה הפרטי ברגיסטר מה שמגביר את הלחץ רגיסטרים.</p>
<p>בעיה מסוימת היא שכאשר אתה מסתכל על מצביע void, כמו להסתכל על goto, אתה לא באמת יודע על מה הוא מצביע. מצביע void בשם private הוא אפילו יותר גרוע, כמעט חסר משמעות מבלי לקרוא הרבה הקשר.</p>
<p>ניתן לראות את השימוש בעוגן מוטבע כמו struct list_head כסגנון של ירושה שכן המבנה המכיל אותו &ldquo;הוא-&rdquo; איבר ברשימה בזכות ירושה מ-struct list_head אבל כנראה שעדיף לחשוב על סוג זה של הטבעה יותר כמו סגנון &ldquo;mixin&rdquo; של ירושה.</p>
<p>דוגמה למצביע void ב-dentry ניתן לראות בשדה <code>void *d_fsdata</code>.</p>
<h1 id="oop--dentry">
  OOP &amp; Dentry
  <a class="heading-link" href="#oop--dentry">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h3 id="ה-methods-של-ה-dentry">
  ה-methods של ה-Dentry
  <a class="heading-link" href="#%d7%94-methods-%d7%a9%d7%9c-%d7%94-dentry">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>כמו בהרבה מקומות בקרנל, גם באובייקטים של ה-dcache יש שימוש של &ldquo;OOP&rdquo; ב-C כאן משתמשים במימוש של methods לאובייקטי ה-dentry, כל מערכת קבצים יכולה ליצור את ה-methods שהיא צריכה וזה יוצר התנהגות של overload שכאן היא מתאימה ונוחה, להרבה מה-methods יש מימוש קיים כברירת מחדל או שאין ופשוט אין קריאות לאותן methods.</p>
<h4 id="d_set_d_op">
  d_set_d_op
  <a class="heading-link" href="#d_set_d_op">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>לפני שאסביר על ה-methods עצמן אני אסביר רגע על ה-<code>d_set_d_op</code> והתרומה שלו ל-OOP של ה-dentry.
כדי לחבר methods ל-dentry משתמשים במבנה <code>dentry_operations</code> שהוא struct שמכיל מצביעים לפונקציות של ה-dentry שמערכת הקבצים צריכה. הרעיון הזה נפוץ בהרבה מקרים כשצריך ליצור התנהגות כזאת, למשל קיים אותו דבר כלפי ה-<code>struct inode</code>, לו יש את ה-<code>inode_operations</code>.
כערך ברירת מחדל ה-<code>dentry_operations</code> מכיל במקום מצביעים ערכי <code>NULL</code> והרעיון הזה קצת בעייתי כי כל פעם לפני שקוראים לפונקציה מסויימת צריך לבדוק את הערך של המצביע ואז לקרוא לפונקציה רק אם היא שונה מ-<code>NULL</code>, במקרים רבים זה בסדר לעשות את זה, אבל כאן יש בעיה כי חייבים שהפונקציות יהיו מעוד מהירות ויעלות בגלל שמשתמשים במערכת הזאת הרבה מאוד, ולכן צריך לעשות כמה שיותר אופטימיזציות. בגלל זה הכניסו דגלים ל-dentry שמספרים איזה methods קיימות ואז אפשר ככה לבדוק רק את הדגל במקום לבדוק את המבציע, מכיוון ששדה הדגל צפוי להיות בכל מקרה ב-cache, ולעתים קרובות לא יהיה צורך כלל במבנה <code>dentry_operations</code>, הדבר מונע שליפת זיכרון ב-hot path.
אז התפקיד של הפונקציה <code>d_set_d_op</code> היא לחבר <code>dentry_operations</code> ל-dentry והיא מדליקה את הדגלים הרצויים.</p>
<hr>

            
          
            <h1 id="dentry-large-hash-table">
  dentry large hash table
  <a class="heading-link" href="#dentry-large-hash-table">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>על מנת לאפשר חיפוש מהיר של dentry, קיימת טבלת hash גדולה של ה-dentries, היא מוקצת על ידי <code>alloc_large_system_hash</code> והיא מאפשרת חיפוש יעיל ומהיר של dentry על פי שם וכתובת ה-dentry של האבא.</p>
<h2 id="יצרת-ה-dentry-large-hash-table">
  יצרת ה-dentry large hash table
  <a class="heading-link" href="#%d7%99%d7%a6%d7%a8%d7%aa-%d7%94-dentry-large-hash-table">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>את היצירה של ה-hash table עושה הפונקציה <code>dcache_init_early</code> שקוראת ל-<code>alloc_large_system_hash</code> מתוכה (מתוך <code>fs/dcache.c</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_hash_shift</span> <span class="n">__read_mostly</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">dentry_hashtable</span> <span class="n">__read_mostly</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">dcache_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="cm">/* If hashes are distributed across NUMA nodes, defer
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="cm">	* hash allocation until vmalloc space is available.
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">hashdist</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="n">dentry_hashtable</span> <span class="o">=</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="nf">alloc_large_system_hash</span><span class="p">(</span><span class="s">&#34;Dentry cache&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">hlist_bl_head</span><span class="p">),</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">			<span class="n">dhash_entries</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">			<span class="mi">13</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">			<span class="n">HASH_EARLY</span> <span class="o">|</span> <span class="n">HASH_ZERO</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">			<span class="o">&amp;</span><span class="n">d_hash_shift</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">			<span class="nb">NULL</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">			<span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">			<span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">	<span class="n">d_hash_shift</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">-</span> <span class="n">d_hash_shift</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>ניתן לראות שכל התפקיד של הפונקציה הזאת היא ליצור את ה-hash table.</p>
<ul>
<li>המשתנה הגלובלי <code>d_hash_shift</code> הוא ערך ה-shift עבור חיפוש hash.</li>
<li>המשתנה <code>dhash_entries</code> הוא נקבע על ידי פרמטר באתחול הקרנל (<code>command-line parameter</code>).</li>
</ul>
<p>והחתימה של <code>alloc_large_system_hash</code> היא (מתוך <code>mm/page_alloc.c</code>):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="o">*</span><span class="n">__init</span> <span class="nf">alloc_large_system_hash</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tablename</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bucketsize</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">numentries</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="kt">int</span> <span class="n">scale</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_hash_shift</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_hash_mask</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">low_limit</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">high_limit</span><span class="p">)</span>
</span></span></code></pre></div><p><code>tablename</code> - שם הטבלה (מופיע בלוגים של הקרנל)
<code>bucketsize</code> - גודל של כל כניסה בטבלה
<code>numentries</code> - כמות כניסות (כלומר כמות ה-bucket-ים)</p>
<p><code>scale</code> - נועד להפחית גדלים של טבלאות במכונות עם כמויות גדולות של זיכרון, ככל שהגודל של הזיכרון יגדל ה-<code>scale</code> יגדל אבל בקצב איטי יותר. המנגנון הזה קיים במערכות עם מעבדים עם תמיכה של יותר מ-32 ביט (בגלל שעם תמיכה של 32 בלבד אין אפשרות להשתמש בהרבה זיכרון גם ככה אז אין טעם למנגנון).</p>
<p><code>flags</code> - דגלים להקצאת הזיכרון (הסבר מורחב  יותר בהמשך)
<code>_hash_shift</code> - משמש על מנת להגן מפני הקצאות בגדלים קטנים מידי כשהדגל <code>HASH_EARLY</code> דלוק, ומשמש גם כמחזיק של הערך חזקה של הסדר (order, חזקה של חזקת 2) של ההקצאה שבוצעה של מספר הכניסות (מספר ה-bucket-ים שהוקצאו).</p>
<p><code>_hash_mask</code> - משמש כמחזיק של הערך חזרה של ה-mask של ה-hash מותאם לגודל ההקצאה שנעשתה, כלומר אם <code>_hash_shift</code> חוזר עם ערך של <code>12</code> אז <code>_hash_mask</code> יהיה <code>4095 = 1 - (12 &gt;&gt; 1)</code></p>
<p><code>low_limit</code> - מספר מינמלי של כניסות (כלומר מספר buckets)
<code>high_limit</code> -  מספר מקסימלי של כניסות (כלומר מספר buckets)</p>
<h3 id="דגלים-ל-alloc_large_system_hash">
  דגלים ל-alloc_large_system_hash
  <a class="heading-link" href="#%d7%93%d7%92%d7%9c%d7%99%d7%9d-%d7%9c-alloc_large_system_hash">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p><code>HASH_EARLY</code> - משמש להקצאה בזמן האיתחול המוקדם.
<code>HASH_SMALL</code> - הקצאה של גדלים מתחת לגודל של <code>PAGE</code> שלם מותרת, ה-shift המינמלי מועבר עם <code>_hash_shift</code>. הדגל הזה צריך להיות דלוק רק אם הדגל <code>HASH_EARLY</code> גם דלוק.
<code>HASH_ZERO</code> -  מאפס את הזיכרון שמוקצה, וגורם להקצאה עם הדגל  <code>__GFP_ZERO</code></p>
<h3 id="שימוש-ב-hlist_bl">
  שימוש ב-hlist_bl
  <a class="heading-link" href="#%d7%a9%d7%99%d7%9e%d7%95%d7%a9-%d7%91-hlist_bl">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>המשתנה גלובלי <code>dentry_hashtable</code> הוא מצביע ל-hash table וכמו שאפשר לראות הוא מסוג <code>hlist_bl_head</code> כלומר <code>hlist</code> משולב עם מנעול <code>bit lock</code> שהדבר הזה יוצר מנעול לכל bucket, וזה נעשה עם <code>bit_spinlock</code> לכל כניסה ל-bucket,  וזה נעשה עם <code>hlist_bl_head</code>.</p>
<p>הטבלה <code>dentry_hashtable</code> שמורכבת ממערך <code>hlist_bl_head</code> באורך קבוע, המקביל לטבלת hash שלעולם אינה מתרחבת, מה שיכול להפחית את תקורה הביצועים ואת מורכבות ההטמעה הנגרמת על ידי בקרת במקביל.
השימוש של הנעילה במקרה הזה בא לידי ביטוי במקרים שצריך לשנות את bucket ב-hash table, וככה מונעים בעיות של גישת שינוי מקבילה וסנכרון של מספר כותבים לאותו טבלה ואחד היתרונות הגדולים של המימוש בעזרת bl_hlist הוא שאין באמת &ldquo;אובייקט מנעול&rdquo; כלומר אין הקצאת זיכרון של מנעול ואין גישה לכתובות אחרות בזיכרון, הכל ממומש תחת אותו מצביע וככה מרוויחים חסכון גדול של מקום בזכרון במקרה של טבלאות גדולות וגם מבחינת זמני גישה ו-cache כשהכל נמצא באותו מקום אז אין הקפצות cache מיותרות כמעט.</p>
<h2 id="חיפוש">
  חיפוש
  <a class="heading-link" href="#%d7%97%d7%99%d7%a4%d7%95%d7%a9">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>החיפוש נעשה בעזרת חיפוש hash שנעשה על ידי הפונקציה <code>d_hash</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="nf">d_hash</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="k">return</span> <span class="n">dentry_hashtable</span> <span class="o">+</span> <span class="p">(</span><span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="n">d_hash_shift</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא למצוא את ה-bucket שמכיל את ה-dentry.</p>
<p>הפונקציה מקבלת כפרמטר hash של ה-dentry (שכבר חושב לפני כן) ובעזרתו היא מחפשת את ה-bucket שמכיל את ה-dentry ב-hash table.
פעולת ה-shift התפקיד של נירמול הגודל של ה-hash, שנעשית היא על מנת לדאוג שהתווך של ה-hash יהיה קטן בוודאות מהגודל של הטבלה, וככה הוא לא יוכל לצאת מהגבולות של הטבלה, ולאחר מכן התוצאה של ה-shift על ה-hash הופכת להיות ה-offset של ה-bucket בטבלה.
לאחר שאנחנו מחזיקים ב-offset של ה-bucket אפשר לחבר אותו לכתובת ההתחלתית של הטבלה (<code>dentry_hashtable</code>) וככה ניתן למצוא את הכתובת של הכניסה של ה-bucket.</p>
<h1 id="dentry-hash-table-משנית">
  dentry hash table משנית
  <a class="heading-link" href="#dentry-hash-table-%d7%9e%d7%a9%d7%a0%d7%99%d7%aa">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h3 id="הרעיון-של-טבלה-משנית">
  הרעיון של טבלה משנית
  <a class="heading-link" href="#%d7%94%d7%a8%d7%a2%d7%99%d7%95%d7%9f-%d7%a9%d7%9c-%d7%98%d7%91%d7%9c%d7%94-%d7%9e%d7%a9%d7%a0%d7%99%d7%aa">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הרעיון של הטבלה המשנית הוא שהטבלת hash שהוקצתה סטטית עם גודל קבוע היא מהירה יותר באופן ניכר, מכיוון שאין לך את הקריאה העקיפה הנוספת של <code>base/size</code> שנמצאות בנתיב הקריטי לחיפוש בפועל. אז עבור קוד dentry קיימת טבלת &ldquo;L1 hash&rdquo; בגודל קבוע ממופה ישירות, שאחר כך נופלת חזרה לטבלה הישנה בגודל דינמי כשהיא מתגעגעת (&ldquo;זיכרון ראשי&rdquo;).
(הכוונה ב-&ldquo;L1 hash&rdquo;  היא שהטבלה קטנה ומהירה כמו הרעיון של הזיכרון cache L1)</p>
<p>בטבלת hash בגודל קבוע כ-cache L1 עבור ערכי תיקייה שסיפקו שיפור ביצועים ניכר. אם חיפוש בטבלת ה-hash הראשונה נכשל, הקוד יחזור לטבלת ה-hash הקיימת בגודל דינמי.</p>
<p>אם bucket של ה-hash אינו מכיל את הערך, ה-cache השני ייבדק. על ידי הימנעות מ&quot;מרדף מצביע&quot;, ה-L1 dcache &ldquo;שיפר באמת את הביצועים&rdquo;.</p>
<h3 id="שימוש-בטבלה-המשנית-במקרה-של-התנגשות">
  שימוש בטבלה המשנית במקרה של התנגשות
  <a class="heading-link" href="#%d7%a9%d7%99%d7%9e%d7%95%d7%a9-%d7%91%d7%98%d7%91%d7%9c%d7%94-%d7%94%d7%9e%d7%a9%d7%a0%d7%99%d7%aa-%d7%91%d7%9e%d7%a7%d7%a8%d7%94-%d7%a9%d7%9c-%d7%94%d7%aa%d7%a0%d7%92%d7%a9%d7%95%d7%aa">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>אם שני thread-ים ינסו לחפש את אותו השם בו-זמנית - שם שעדיין לא נמצא ב-dcache - המנעול המשותף ב-i_rwsem לא ימנע משניהם להוסיף dentries חדשים באותו שם. מכיוון שהדבר יגרום לבלבול, נעשה שימוש ברמה נוספת של השתלבות (interlocking), המבוססת על טבלת hash משנית (<code>in_lookup_hashtable</code>) ו-bit ב-<code>d_flag</code> לכלdentry (<code>DCACHE_PAR_LOOKUP</code>).</p>
<p>כדי להוסיף dentry חדש ל-cache תוך החזקת מנעול משותף בלבד ב-i_rwsem, ה-thread חייב לקרוא ל-<code>d_alloc_parallel()</code>. זה מקצה dentry, מאחסן בו את השם וההורה הנדרש, בודק אם כבר יש dentry תואם ב-hash table הראשית או המשנית, ואם לא, מאחסן את ה-dentry החדש שהוקצה בטבלת ב-hash table המשנית, כש-<code>DCACHE_PAR_LOOKUP</code> דלוק.</p>
<p>אם נמצאה dentry תואם בטבלת ה-hash הראשית (כלומר שני thread-ים הוסיפו במקביל dentry עם אותו hash והיתה התנגשות), הוא מוחזר וה-caller יכול לדעת שהוא הפסיד במירוץ עם thread אחר שהוסיף את הערך.
אם לא נמצא dentry תואם באף אחד מה-cache, ה-dentry שהוקצה לאחרונה מוחזרות וה-caller יכול לזהות זאת מנוכחות <code>DCACHE_PAR_LOOKUP</code>. במקרה זה הוא יודע שהוא ניצח בכל מירוץ וכעת הוא אחראי לבקש ממערכת הקבצים לבצע את החיפוש ולמצוא את האינוד התואם.
כשהבדיקה הושלמה, הוא חייב לקרוא ל-<code>d_lookup_done()</code> שמנקה את הדגל ועוד כמה פעולות שהוא עושה: הסרת ה-dentry מטבלת ה-hash המשנית - זה בדרך כלל יתווסף כבר לטבלת ה-hash הראשית. שימו לב ש-<code>struct waitqueue_head</code> מועבר ל-<code>d_alloc_parallel()</code>, ויש לקרוא ל-<code>d_lookup_done()</code> בזמן שה-<code>waitqueue_head</code> הזה עדיין ב-scope.</p>
<p>אם נמצא dentry תואם בטבלת ה-hash המשנית, ל-<code>d_alloc_parallel()</code> יש עוד קצת עבודה לעשות. הוא ממתין תחילה לניקוי <code>DCACHE_PAR_LOOKUP</code>, תוך שימוש ב-<code>wait_queue</code> שהועבר למופע של <code>d_alloc_parallel()</code> שניצח במירוץ ואשר יועיר מהקריאה ל-<code>d_lookup_done()</code>. לאחר מכן הוא בודק אם ה-<code>dentry</code> שנוסף כעת לטבלת ה-hash הראשית. אם כן, ה-dentry מוחזר וה-caller רק רואה שהוא הפסיד במרוץ כלשהו. אם הוא לא התווסף לטבלת ה-hash הראשית, ההסבר הסביר ביותר הוא שעוד dentry נוסף במקום באמצעות <code>d_splice_alias()</code>.
בכל מקרה, <code>d_alloc_parallel()</code> חוזר על כל החיפושים מההתחלה ובדרך כלל יחזיר משהו מטבלת ה-hash הראשית.</p>
<h2 id="חיפוש-ב-hash-table-המשנית">
  חיפוש ב-hash table המשנית
  <a class="heading-link" href="#%d7%97%d7%99%d7%a4%d7%95%d7%a9-%d7%91-hash-table-%d7%94%d7%9e%d7%a9%d7%a0%d7%99%d7%aa">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>החיפוש נעשה בעזרת חיפוש hash והכתובת של האבא, וזה נעשה על ידי הפונקציה <code>in_lookup_hashtable</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"> <span class="n">IN_LOOKUP_SHIFT</span> <span class="mi">10</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="n">in_lookup_hashtable</span><span class="p">[</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">IN_LOOKUP_SHIFT</span><span class="p">];</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="nf">in_lookup_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	<span class="n">hash</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">parent</span> <span class="o">/</span> <span class="n">L1_CACHE_BYTES</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl">	<span class="k">return</span> <span class="n">in_lookup_hashtable</span> <span class="o">+</span> <span class="nf">hash_32</span><span class="p">(</span><span class="n">hash</span><span class="p">,</span> <span class="n">IN_LOOKUP_SHIFT</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">9</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>אפשר לראות שהגודל של הטבלה המשנית הוא די קטן, רק עם 1024 כניסות.</p>
<p>יש דגל שהוכנס ל-dentry למטרת עזר לחיפוש <code>DCACHE_PAR_LOOKUP</code>.
וכמו כן גם יש את <code>d_in_lookup</code> שבודק אם dentry במצב ב-lookup לפי הדגל.</p>
<p>טבלת ה-hash הראשית, <code>dentry_hashtable</code>, מכילה רק ערכים שהחיפוש הסתיים בהם, ולכן ידוע שהם חיוביים או שליליים, ולעומת זאת הטבלת ה-hash המשנית היא משמשת לערכים בחיפוש שעדיין לא בטוח נכנסו לטבלה הראשית.</p>
<p>ערכים מתווספים ל-<code>in_lookup_hash</code> באמצעות שדה קישור נפרד (<code>d_u.d_in_lookup_hash</code>) ב-dentries, כך שהוא יכול להיות זמני בשתי הטבלאות.
כאשר חיפוש מערכת הקבצים מסתיים, הערך מתווסף לטבלת ה-hash הראשית ולאחר מכן מוסר מטבלת ה-hash של dentries במצב lookup.</p>
<p>הערך של טבלת ה-hash המשנית הוא בכך שהיא מאפשרת הכנסת ערכים חדשים ללא צורך בחיפוש בשרשרת ה-hash בטבלה הראשית במנעול בלעדי. יש צורך במנעול בלעדי (שהושג עם <code>hlist_bl_lock()</code>) כדי לחפש בשרשרת ה-hash בטבלה המשנית, אך ניתן לצפות שזו תהיה שרשרת קצרה בהרבה, שניגשים אליה הרבה פחות. המנעול הבלעדי ב-hash chain הראשית מוחזק מספיק זמן כדי לחבר את ה-dentries ברגע שהוא מוכן.</p>

            
          
            <p>המנעול <code>lockref</code> הוא מנעול שמספק מנגנון גנרי לעדכון אטומי של reference counts שמוגן על ידי spinlock בלי לרכוש את spinlock עצמו (בחלק מהמקרים).</p>
<p>המנעול נוצר לאובייקט <code>dentry</code> בגלל שיש עומסי עבודה שיוצרים הרבה פעילות ב-vfs יכולים להיות צווארי בקבוק בניסיון לחכות לנעילה של <code>spinlock</code> על עדכון של ספירת התייחסות ל-<code>dentry</code>.</p>
<p>הרעיון של <code>lockref</code> הוא מנעול שמאחד בין spinlock לבין count ref &ldquo;אטומי&rdquo;, כשיש מבנה שצריך להעלות להעלות את המונה שימוש שלו ביעלות, עדיף שהוא ישתמש בפעולה אטומית, אבל יש גם פעמים שמבנים צריכים להיות נעולים לשינויים כולל שינויים של מונה הספירה (לדוגמה המבנה <code>dentry</code>), ולכן צריך לפני שמעלים את המונה קודם כל לנעול את המבנה או לפחות לוודא שהוא לא נעול לפני ואחרי הפעולה של שינוי המונה.
ובנוסף, המנגנון מבטיח שספירת ההתייחסות תתעדכן כאילו ה-spinlock הוחזק, אבל באמצעות גישה אטומית שמכסה את הספירת התייחסות וגם את ה-spinlock, הוא יכול לעתים קרובות לבצע את העדכון מבלי לבצע את הנעילה בפועל (במסלול המהיר).</p>
<p>מבנה ה-lockref, הוא באמת  reference counts <strong>נעול</strong>. אם אתה מחזיק את ה-spinlock, ה-reference counts יהיה יציב ותוכל לשנות את reference counts מבלי להשתמש באטומים, מכיוון שאפילו העדכונים ללא הנעילה יראו ויכבדו את מצב המנעול.</p>
<p>שינוי המונה מחייב רכישת ה-spinlock תחילה. במערכת עם עומס עבודה עתיר במערכת הקבצים, הוויכוח על ה-spinlock הוא צוואר בקבוק רציני בביצועים; רכישת המנעול לצורך שינויים בספירת ההתייחסות היא חלק משמעותי מהבעיה, ולכן זה יהיה נחמד למצוא דרך להימנע מהתקורה הזאת של הנעילה, אבל לא ניתן להשתמשי בפעולה אטומית עבור d_count, בגלל שכל thread שמחזיק את ה-d_lock, לא חייב לראות את הערך של שינוי ה-d_count, בגלל שכל אחד יכול לראות ערך אחר בגלל caching ו-other-multicopy-atomic (יוסבר במאמר נפרד) ועוד &ldquo;מוזרויות&rdquo; של מודל הזיכרון של המעבד.</p>
<p>מנגנון ה-lockref מאפשר מניפולציה ללא נעילה של ספירת ההתייחסות תוך שמירה על המנעול משויך; ה-lockref פועל על ידי אריזה (packing) של ספירת ההתייחסות וה-spinlock למבנה יחיד של שמונה בתים שנראה כך:</p>
<p>מתוך הקובץ <code>include/linux/lockref.h</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"> <span class="n">USE_CMPXCHG_LOCKREF</span> \
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	<span class="p">(</span><span class="nf">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_ARCH_USE_CMPXCHG_LOCKREF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> \
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="nf">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_SMP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">SPINLOCK_SIZE</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="k">struct</span> <span class="n">lockref</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"> <span class="n">USE_CMPXCHG_LOCKREF</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="n">aligned_u64</span> <span class="n">lock_count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">		<span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">			<span class="kt">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">			<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="p">};</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">//include/linux/types.h
</span></span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="c1"></span> <span class="n">aligned_u64</span> <span class="n">__aligned_u64</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="c1">//include/uapi/linux/types.h
</span></span></span><span class="line"><span class="ln">5</span><span class="cl"><span class="c1"></span> <span class="n">__aligned_u64</span> <span class="n">__u64</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="nf">aligned</span><span class="p">(</span><span class="mi">8</span><span class="p">)))</span>
</span></span></code></pre></div><p>המנגנון המעניין יכול להתקיים רק כש-<code>USE_CMPXCHG_LOCKREF</code> מוגדר, ויש תמיכה ב-<code>cmpxchg</code> על גישות לזיכרון בגודל 64 ביט,  כי על מנת לגרום למנגון לעבוד צריך שהגודל של ה-spinlock יהיה בגודל של 4 בתים בגלל ה-<code>cmpxchg</code> שמבוצע בצורה אטומית.
ה-<code>lockref</code> מפחית את מספר ה-cache lines התפוסות ככל האפשר על ידי כפיית יישור, מה שמשפר את הביצועים וגורם להפחתה של הקפצת ה-cache line אבל עדיין הבעיה מתרחשת.</p>
<h1 id="תהליך-הנעילה">
  תהליך הנעילה:
  <a class="heading-link" href="#%d7%aa%d7%94%d7%9c%d7%99%d7%9a-%d7%94%d7%a0%d7%a2%d7%99%d7%9c%d7%94">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>התהליך של הנעילה מופעל על ידי מספר פונקציות, אני אדגים ואסביר את התהליך על ידי הפונקציה הבסיסית: <code>lockref_get</code>:</p>
<p>מתוך הקובץ: <code>lib/lockref.c</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">lockref_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">lockref</span> <span class="o">*</span><span class="n">lockref</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="nf">CMPXCHG_LOOP</span><span class="p">(</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">		<span class="n">new</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="p">,</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockref</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="n">lockref</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockref</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה לא עושה יותר מידי כמו שניתן לראות ורוב העבודה נעשית במאקרו <code>CMPXCHG_LOOP</code> שמוגדר באותו הקובץ:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"> <span class="n">USE_CMPXCHG_LOCKREF</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="cm">* Note that the &#34;cmpxchg()&#34; reloads the &#34;old&#34; value for the
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="cm">* failure case.
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"> <span class="nf">CMPXCHG_LOOP</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="k">do</span> <span class="p">{</span> \
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="kt">int</span> <span class="n">retry</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> \
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">struct</span> <span class="n">lockref</span> <span class="n">old</span><span class="p">;</span> \
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="nf">BUILD_BUG_ON</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">);</span> \
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="n">old</span><span class="p">.</span><span class="n">lock_count</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">lockref</span><span class="o">-&gt;</span><span class="n">lock_count</span><span class="p">);</span> \
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="nf">arch_spin_value_unlocked</span><span class="p">(</span><span class="n">old</span><span class="p">.</span><span class="n">lock</span><span class="p">.</span><span class="n">rlock</span><span class="p">.</span><span class="n">raw_lock</span><span class="p">))){</span>\
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="k">struct</span> <span class="n">lockref</span> <span class="n">new</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span> \
</span></span><span class="line"><span class="ln">14</span><span class="cl">		<span class="n">CODE</span> \
</span></span><span class="line"><span class="ln">15</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="nf">try_cmpxchg64_relaxed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lockref</span><span class="o">-&gt;</span><span class="n">lock_count</span><span class="p">,</span> \
</span></span><span class="line"><span class="ln">16</span><span class="cl">											<span class="o">&amp;</span><span class="n">old</span><span class="p">.</span><span class="n">lock_count</span><span class="p">,</span> \
</span></span><span class="line"><span class="ln">17</span><span class="cl">											<span class="n">new</span><span class="p">.</span><span class="n">lock_count</span><span class="p">)))</span> <span class="p">{</span> \
</span></span><span class="line"><span class="ln">18</span><span class="cl">			<span class="n">SUCCESS</span><span class="p">;</span> \
</span></span><span class="line"><span class="ln">19</span><span class="cl">		<span class="p">}</span> \
</span></span><span class="line"><span class="ln">20</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">retry</span><span class="p">)</span> \
</span></span><span class="line"><span class="ln">21</span><span class="cl">			<span class="k">break</span><span class="p">;</span> \
</span></span><span class="line"><span class="ln">22</span><span class="cl">	<span class="p">}</span> \
</span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl"> <span class="nf">CMPXCHG_LOOP</span><span class="p">(</span><span class="n">CODE</span><span class="p">,</span> <span class="n">SUCCESS</span><span class="p">)</span> <span class="k">do</span> <span class="p">{</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span></code></pre></div><p>המאקרו <code>CMPXCHG_LOOP</code> מקבל 2 פרמטרים, שניהם הם קטעי קוד להרצה, הפרמטר <code>CODE</code> הוא הקוד עצמו שצריך להריץ, למשל אנחנו רוצים להגדיל את המונה של המנעול אז אפשר לראות בקוד של <code>lockref_get</code> שהוא מעביר הגדלה של המונה בפרמטר הזה, הפרמטר השני <code>SUCCESS</code> הוא קטע להרצה אם השינוי של המנעול הצליח בצורה אטומית ללא נעילה של ה-spinlock.</p>
<p>בשלב השני יש העתקה של הערך של המנעול למשתנה מקומי (<code>old</code>) עם שימוש של <code>READ_ONCE</code>, על מנת לקרוא בצורה שלמה את המשתנה שלא יהיה קריעת זיכרון, כי יכול להיות גישות כתיבה בין הקריאה.</p>
<p>התנאי של הלולאה הוא אם הערך של ה-spinlock הוא לא נעול, ורק אם הוא לא נעול אז אפשר להמשיך, לאחר מכן הוא עוד פעם משכפל את המידע למשתנה המקומי <code>new</code>, והפעם ללא שימוש ב-<code>READ_ONCE</code> בגלל שהפעם  אין אפשרות לשינוי הערך של המשתנה גם אם יש קריעת זיכרון.</p>
<p>לאחר מכן הקוד של הפרמטר <code>CODE</code> רץ, במקרה שלנו עם הדוגמה של הפונקציה <code>lockref_get</code> אז הקוד שרץ הוא <code>++new.count</code> כלומר הוא מעלה את הערך של <code>new</code>, ואנחנו רוצים עכשיו שהערך של <code>new</code> יהפוך להיות הערך החדש של המנעול לאחר השינוי שלנו (ההגדלה) אבל אנחנו מוכנים לעשות את זה רק אם אנחנו היחידים שכרגע משנים את המצב של המנעול <code>lockref</code> שלנו.</p>
<p>לכן כדי לעדכן את הערך של המנעול יש בדיקה של הערך של <code>lockref</code> עצמו עם השוואה של הערך הישן שלו (המשתנה <code>old</code>), כי אם שניהם שווים אז לא היה שינוי במצב של המנעול ואפשר לעדכן אותו ולהעתיק את <code>new</code> לתוך <code>lockref</code>.
הבדיקה היא על המונה ספירה וגם על ה-spinlock, והוא צריך לוודא שהוא היחדי שמשנה את הערך של המונה ברגע מסויים על מנת להבטיח שהוא לא פוגע בנעילה (כלומר לא משנה את ההמונה בזמן שאסור לו) וגם הוא צריך לוודא שהוא משנה את המונה עם הערך חוקי, ולא מנסה למשל לשנות את המונה עם מנעול מת.</p>
<p>התהליך שהוסבר בפסקה אחרונה נעשה על ידי הפונקציה <code>try_cmpxchg64_relaxed</code> שמשתמשת ב-<code>cmpxchg</code> של הארכיטקטורה של המעבד, וכל התהליך נעשה בצורה אטומית, ובזכות זה ניתן להבטיח שבאמת הבדיקה אמינה, והשינוי יראה כלפי כל המעבדים, ואם השינוי הצליח אז רץ הקוד של <code>SUCCESS</code> מכיל <code>return</code> ולא ממשיך לשאר הקוד, אם הוא לא מגיע אליו אז הוא מנסה לחכות רגע עם בעזרת הפונקציה <code>cpu_relax</code> שהיא בערך לולאת <code>nop</code> באסמבלי, והוא ממשיך לנסות עד <code>100</code> פעמים ואחרי זה הוא &ldquo;נופל&rdquo; למקרה האיטי.</p>
<p>המסלול האיטי הוא פשוט הרעיון של ה-lockref רק בלי המנגנון המיוחד, כלומר נעילה של ה-spinlock, לאחר מכן שינוי של המונה ושחרור ה-spinlock.</p>
<h1 id="מצבים-של-ה-lockref">
  מצבים של ה-<code>lockref</code>
  <a class="heading-link" href="#%d7%9e%d7%a6%d7%91%d7%99%d7%9d-%d7%a9%d7%9c-%d7%94-lockref">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>המנעול יכול להיות במספר מצבים:</p>
<ul>
<li>
<p>חופשי (free): הוא אינו מכיל מידע חשוב, הוא לא בשימוש על ידי VFS (הזיכרון מנוהל על ידי ה-slab allocator).</p>
</li>
<li>
<p>בשימוש: בשימוש על ידי הקרנל, מצביע <code>d_lockref.count</code> חיובי, והשדה <code>d_inode</code> מצביע על האינוד.</p>
</li>
<li>
<p>לא בשימוש (unused): לא בשימוש על ידי הקרנל, המונה ספירה של המנעול הוא <code>0</code>, אך השדה <code>d_inode</code> עדיין מצביע על האינוד.</p>
</li>
<li>
<p>מצב empty (שלילי - negative): לא קיים <code>inode</code> עבור ערך ה-<code>dentry</code> זה מכיוון שהאינוד בדיסק נמחק או שה-<code>dentry</code> נוצר עבור קובץ שאינו קיים. השדה <code>d_inode</code> הוא <code>NULL</code>, אך אובייקט ה-<code>dentry</code> עדיין קיים, ומאיץ פעולות חיפוש עתידיות.</p>
</li>
</ul>

            
          
            <p>(<a href="https://lwn.net/Articles/784124/"  class="external-link" target="_blank" rel="noopener">qstr מייצג בקרנל UTF-8</a>):</p>
<p>מחרוזות UTF-8 מיוצגות בממשק זה באמצעות מבנה ה-qstr המוגדר</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"> <span class="n">__LITTLE_ENDIAN</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	 <span class="n">HASH_LEN_DECLARE</span> <span class="n">u32</span> <span class="n">hash</span><span class="p">;</span> <span class="n">u32</span> <span class="n">len</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	 <span class="nf">bytemask_from_count</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="mi">0ul</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	 <span class="n">HASH_LEN_DECLARE</span> <span class="n">u32</span> <span class="n">len</span><span class="p">;</span> <span class="n">u32</span> <span class="n">hash</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	 <span class="nf">bytemask_from_count</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="mi">0ul</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">struct</span> <span class="n">qstr</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">			<span class="n">HASH_LEN_DECLARE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="p">};</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">		<span class="n">u64</span> <span class="n">hash_len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="p">};</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>
<p>השדה <code>name</code> של <code>qstr</code> הוא ה-string והוא חייב להסתיים ב-<code>NULL</code>, הוא יכול להיות מוקצה פנימית בתוך ה-dentry או חיצונית (<code>external</code>). כשיש הקצה פנימית של השם, אז <code>name</code> מצביע לשדה <code>d_iname</code> בתוך ה-dentry אם הגודל של השם קטן מ-<code>DNAME_INLINE_LEN - 1</code> (מינוס 1 בגלל ה-<code>NULL</code>). הערך של <code>DNAME_INLINE_LEN</code> תלוי בקונפיגורצית הקימפול.</p>
<p>כשיש הקצאה חיצונית אז מוקצה אובייקט <code>external_name</code>:</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">struct</span> <span class="n">external_name</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="k">union</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">		<span class="kt">atomic_t</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">		<span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">head</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="p">}</span> <span class="n">u</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[];</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>ה-<code>external_name</code> מוקצה על ידי הפונקציה <code>__d_alloc</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">dname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="n">dentry</span> <span class="o">=</span> <span class="nf">kmem_cache_alloc</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="n">name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slash_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="n">dname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">DNAME_INLINE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="nf">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">external_name</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">		<span class="k">struct</span> <span class="n">external_name</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">kmalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">					<span class="n">GFP_KERNEL_ACCOUNT</span> <span class="o">|</span> <span class="n">__GFP_RECLAIMABLE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">			<span class="nf">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">		<span class="nf">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">		<span class="n">dname</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">		<span class="n">dname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">	<span class="nf">memcpy</span><span class="p">(</span><span class="n">dname</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">	<span class="n">dname</span><span class="p">[</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dname</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>זה ההתחלה של הפונקציה <code>__d_alloc</code> ובו אפשר למצוא את החלק שאחראי על הקצאת השם של ה-dentry.
הפונקציה מקצה את השם החיצוני בתוך האובייקט <code>external_name</code> (כשמקצים את הזכרון ל-struct אז הגודל כולל גם את האורך של <code>name</code>). כשמאכלסים את ה-<code>external_name</code> אז גם מהתחלים את ה-<code>count</code> שלו ל-<code>1</code>, המטרה של המונה הוא כשיש שימוש לא ישיר ב-struct וצריך להיזהר משימוש מקביל בזמן שיחרור שלו.
בנוסף לאלה יש שימוש במנגנון ה-<code>RCU</code> (שדה ה-<code>u.head</code>) בתוך ה-<code>external_name</code>, והוא משומש רק בזמן שחרור שלו.</p>
<ul>
<li>השדה <code>hash_len</code> כמו הוא <code>u64</code> שמכיל 2 ערכים בתוכו: בחצי הנמוך את הוא מכיל את ה-hash של ה-string, ובחצי הגבוה את האורך של ה-string.</li>
<li>השדה <code>HASH_LEN_DECLARE</code> כמו אפשר לראות פשוט הופך לשדות של אורך וה-hash של ה-<code>name</code>.</li>
</ul>
<p>בנוסף כדי להזכיר את השימוש של <code>take_dentry_name_snapshot</code>:</p>
<p>היא פונקציה שבעיקר משמשת את ה-<code>fsnotify</code> (קיים גם שימוש עם <code>overlayfs</code>). המטרה שלו היא לדאוג להפניה תקינה לשם הקובץ, הוא עושה את זה על ידי שכפול של השם אם הוא פנימי ואם הוא חיצוני אז הפונקציה רק מעלה את ה-count ref שלו, וככה דואגת שה-<code>qstr</code> של ה-dentry לא ישתחרר, זה שימושי כשמעבירים את השם של הקובץ למקום חיצוני (הכוונה בחיצוני מחוץ ל-core vfs), כי לא בטוח שה-dentry ימשיך להתקיים או השם שלו לא ישתנה.</p>

            
          
            <h1 id="הקצאת-dentry-חדש">
  הקצאת <code>dentry</code> חדש
  <a class="heading-link" href="#%d7%94%d7%a7%d7%a6%d7%90%d7%aa-dentry-%d7%97%d7%93%d7%a9">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="הפונקציה-d_alloc">
  הפונקציה <code>d_alloc</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_alloc">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nf">__d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="cm">	* don&#39;t need child lock because it is not subject
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="cm">	* to concurrency here
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">__dget_dlock</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="nf">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מקבלת 2 פרמטרים:</p>
<ul>
<li>הפרמטר <code>parent</code> הוא ה-<code>dentry</code> אב שבו צריך להקצות את ה-<code>dentry</code> החדש, כלומר תקיית האב.</li>
<li>הפרמטר <code>name</code> הוא פשוט השם של הקובץ שצריך להקצות לו <code>dentry</code>.</li>
</ul>
<p>המטרה של הפונקציה די ברורה, היא פונקציה שמקצה בצורה &ldquo;high-level-ית&rdquo; אובייקט <code>dentry</code> חדש.</p>
<p>הפעולות המבוצעות על ידי הפונקציה:</p>
<ol>
<li>קוראת לפונקציה <code>d_alloc__</code> כדי להקצות את הזיכרון הנדרש למבנה <code>dentry</code> מתוך ה-<code>dentry_slab</code> וגם הפונקציה מאתחלת את השדות של ה-<code>dentry</code> שמוקצה. (בהמשך יש הסבר מורחב על <code>d_alloc__</code>), אם ההקצאה נכשלה חוזר ערך <code>NULL</code> ואז גם הפונקציה <code>d_alloc</code> נכשלת ומחזירה  <code>NULL</code>.</li>
<li>נועלים את <code>parent</code> על מנת לעדכן את השדות שלו שצריך לשנות בעקבות הוספת בן.</li>
<li>יש קריאה ל-<code>__dget_dlock</code> שמגדיל ב-<code>1</code> את המונה ספירה של <code>parent</code> בגלל שעכשיו יש עוד מצביע ל-<code>parent</code> שמגיע מתוך ה-<code>dentry</code> החדש.</li>
<li>מעדכנים את ה-<code>dentry</code> החדש להכיל הצבעה על האבא שלו.</li>
<li>מוסיפים את ה-<code>dentry</code> החדש לרשימת בנים של האבא.</li>
<li>פותחים את הנעילה של <code>parent</code>.</li>
<li>מחזירים את ה-<code>dentry</code> החדש.</li>
</ol>
<h3 id="הפונקציה-__d_alloc">
  הפונקציה <code>__d_alloc</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__d_alloc">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="kt">char</span> <span class="o">*</span><span class="n">dname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="n">dentry</span> <span class="o">=</span> <span class="nf">kmem_cache_alloc_lru</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dentry_lru</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">				      <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="cm">	 * We guarantee that the inline name is always NUL-terminated.
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="cm">	 * This way the memcpy() done by the name switching in rename
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="cm">	 * will still always have a NUL at the end, even if we might
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cm">	 * be overwriting an internal NUL character
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">		<span class="n">name</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">slash_name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">		<span class="n">dname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">DNAME_INLINE_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">		<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="nf">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">external_name</span><span class="p">,</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">		<span class="k">struct</span> <span class="n">external_name</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nf">kmalloc</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">						  <span class="n">GFP_KERNEL_ACCOUNT</span> <span class="o">|</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">						  <span class="n">__GFP_RECLAIMABLE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">			<span class="nf">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span> 
</span></span><span class="line"><span class="ln">29</span><span class="cl">			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">		<span class="nf">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">		<span class="n">dname</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">	<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">		<span class="n">dname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_iname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">	<span class="p">}</span>	
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">	<span class="nf">memcpy</span><span class="p">(</span><span class="n">dname</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">	<span class="n">dname</span><span class="p">[</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">
</span></span><span class="line"><span class="ln">42</span><span class="cl">	<span class="cm">/* Make sure we always see the terminating NUL character */</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dname</span><span class="p">);</span> <span class="cm">/* ^^^ */</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">
</span></span><span class="line"><span class="ln">45</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">	<span class="nf">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl">	<span class="nf">seqcount_spinlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">49</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">50</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">51</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">52</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">53</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">54</span><span class="cl">	<span class="nf">INIT_HLIST_BL_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">55</span><span class="cl">	<span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lru</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">56</span><span class="cl">	<span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">57</span><span class="cl">	<span class="nf">INIT_HLIST_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_alias</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">58</span><span class="cl">	<span class="nf">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">59</span><span class="cl">	<span class="nf">d_set_d_op</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">60</span><span class="cl">
</span></span><span class="line"><span class="ln">61</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_init</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">62</span><span class="cl">		<span class="n">err</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="nf">d_init</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">63</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">64</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">dname_external</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">65</span><span class="cl">				<span class="nf">kfree</span><span class="p">(</span><span class="nf">external_name</span><span class="p">(</span><span class="n">dentry</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">66</span><span class="cl">			<span class="nf">kmem_cache_free</span><span class="p">(</span><span class="n">dentry_cache</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">67</span><span class="cl">			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">68</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">69</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">70</span><span class="cl">
</span></span><span class="line"><span class="ln">71</span><span class="cl">	<span class="nf">this_cpu_inc</span><span class="p">(</span><span class="n">nr_dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">72</span><span class="cl">
</span></span><span class="line"><span class="ln">73</span><span class="cl">	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">74</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מקבלת כפרמטרים שם של הקובץ (מסוג <code>qstr</code>), ואת ה-<code>sb</code> שהוא משוייך אליו.</p>
<p>הפונקציה מתחילה בהקצאה של אובייקט <code>dentry</code> חדש ולאחר מכן מנסה למלא אותו במידע הרלוונטי:</p>
<ul>
<li>איכלוס של שם ה-dentry מוסבר בפירוט בחלק במאמר על qstr.</li>
</ul>
<p>יש שימוש ב-<code>smp_store_release</code> לצורך העתקת המידע לתוך ה-dentry עצמו, את ההסבר ניתן למצוא בתיעוד בפונקציה <code>__d_lookup_rcu</code>.</p>
<p>ולכן צריך לוודא שכל אחד (כל cpu) שקורא את התוכן שלו יראה את התוכן המעודכן של השם על מנת לוודא שכולם רואים את ה-<code>NULL</code> של הסיום.</p>
<p>לאחר מכן ממלאים את השדות של ה-<code>dentry</code> בערכים התחלתיים.</p>
<p>אפשר לראות משהו מעניין במילוי הפרטים שנוגע למימוש ה-oop של הקרנל עם הפונקציה <code>d_set_d_op</code>, היא מקבלת את ה-<code>dentry</code> עצמו ואת ה-<code>dentry-&gt;d_sb-&gt;s_d_op</code> שהם methods של ה-dentry, והם דיפולטים כלפי כל <code>sb</code>, כלומר בדרך הזאת ניתן ליצור מימוש של התנהגות אחרת כלפי כל &ldquo;class&rdquo; של dentry. להסבר מפורט יותר קרא את החלק במאמר שמדבר על oop בקרנל.</p>
<p>לאחר מכן צריך לבדוק האם המימוש של <code>d_init</code> קיים ל-<code>dentry</code> ואם קיים אז קוראים לה, ואם היא נקראה וחזרה עם שגיאות אז משחררים את המשאבים שהקצנו ל-dentry ומחזירים <code>NULL</code>.</p>
<p>ואם הגענו עד לכאן אז סיימנו את ההקצאה ואפשר להעלות את המונה <code>nr_dentry</code> ב-<code>1</code> (המונה הוא משתנה שקיים כלפי כל מעבד נפרד, והוא מונה את כמות ה-dentries שקיימים ברשותו) ולסיים את הפונקציה עם החזרה של מצביע ל-<code>dentry</code>.</p>
<h2 id="הפונקציה-d_alloc_parallel">
  הפונקציה <code>d_alloc_parallel</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_alloc_parallel">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">  1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_alloc_parallel</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">  2</span><span class="cl">				<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">  3</span><span class="cl">				<span class="kt">wait_queue_head_t</span> <span class="o">*</span><span class="n">wq</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">  5</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  6</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nf">in_lookup_hash</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">  7</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  8</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nf">d_alloc</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">  9</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl">	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">,</span> <span class="n">r_seq</span><span class="p">,</span> <span class="n">d_seq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 11</span><span class="cl">
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 13</span><span class="cl">		<span class="k">return</span> <span class="nf">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">
</span></span><span class="line"><span class="ln"> 15</span><span class="cl"><span class="nl">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">	<span class="nf">rcu_read_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl">	<span class="n">seq</span> <span class="o">=</span> <span class="nf">smp_load_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_dir_seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">	<span class="n">r_seq</span> <span class="o">=</span> <span class="nf">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">	<span class="n">dentry</span> <span class="o">=</span> <span class="nf">__d_lookup_rcu</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d_seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">lockref_get_not_dead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">			<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">d_seq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">			<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl">			<span class="nf">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 29</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">		<span class="nf">dput</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">		<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 33</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">r_seq</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 35</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">seq</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">	<span class="nf">hlist_bl_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_dir_seq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">		<span class="nf">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 51</span><span class="cl"><span class="cm">	 * No changes for the parent since the beginning of d_lookup().
</span></span></span><span class="line"><span class="ln"> 52</span><span class="cl"><span class="cm">	 * Since all removals from the chain happen with hlist_bl_lock(),
</span></span></span><span class="line"><span class="ln"> 53</span><span class="cl"><span class="cm">	 * any potential in-lookup matches are going to stay here until
</span></span></span><span class="line"><span class="ln"> 54</span><span class="cl"><span class="cm">	 * we unlock the chain.  All fields are stable in everything
</span></span></span><span class="line"><span class="ln"> 55</span><span class="cl"><span class="cm">	 * we encounter.
</span></span></span><span class="line"><span class="ln"> 56</span><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">	<span class="nf">hlist_bl_for_each_entry</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d_u</span><span class="p">.</span><span class="n">d_in_lookup_hash</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 59</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">d_same_name</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 63</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">		<span class="nf">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 65</span><span class="cl">		<span class="cm">/* now we can try to grab a reference */</span>
</span></span><span class="line"><span class="ln"> 66</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">lockref_get_not_dead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">			<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 68</span><span class="cl">			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 73</span><span class="cl"><span class="cm">		 * somebody is likely to be still doing lookup for it;
</span></span></span><span class="line"><span class="ln"> 74</span><span class="cl"><span class="cm">		 * wait for them to finish
</span></span></span><span class="line"><span class="ln"> 75</span><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">		<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">		<span class="nf">d_wait_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">		<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 79</span><span class="cl"><span class="cm">		 * it&#39;s not in-lookup anymore; in principle we should repeat
</span></span></span><span class="line"><span class="ln"> 80</span><span class="cl"><span class="cm">		 * everything from dcache lookup, but it&#39;s likely to be what
</span></span></span><span class="line"><span class="ln"> 81</span><span class="cl"><span class="cm">		 * d_lookup() would&#39;ve found anyway.  If it is, just return it;
</span></span></span><span class="line"><span class="ln"> 82</span><span class="cl"><span class="cm">		 * otherwise we really have to repeat the whole thing.
</span></span></span><span class="line"><span class="ln"> 83</span><span class="cl"><span class="cm">		 */</span>
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">			<span class="k">goto</span> <span class="n">mismatch</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">			<span class="k">goto</span> <span class="n">mismatch</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">			<span class="k">goto</span> <span class="n">mismatch</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="nf">d_same_name</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">			<span class="k">goto</span> <span class="n">mismatch</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">		<span class="cm">/* OK, it *is* a hashed match; return it */</span>
</span></span><span class="line"><span class="ln"> 93</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">		<span class="nf">dput</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">		<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">	<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 98</span><span class="cl">	<span class="cm">/* we can&#39;t take -&gt;d_lock here; it&#39;s OK, though. */</span>
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">	<span class="n">new</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_PAR_LOOKUP</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl">	<span class="n">new</span><span class="o">-&gt;</span><span class="n">d_wait</span> <span class="o">=</span> <span class="n">wq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">101</span><span class="cl">	<span class="nf">hlist_bl_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_in_lookup_hash</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">102</span><span class="cl">	<span class="nf">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">103</span><span class="cl">	<span class="k">return</span> <span class="n">new</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">104</span><span class="cl"><span class="nl">mismatch</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">105</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">106</span><span class="cl">	<span class="nf">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">107</span><span class="cl">	<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">108</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מקבלת בפרמטרים:</p>
<ul>
<li>ה-<code>dentry</code> אב</li>
<li>השם של הקובץ מסוג <code>qstr</code></li>
<li>תור המתנה</li>
</ul>
<p>הפעולות המבוצעות על ידי הפונקציה:</p>
<ol>
<li>מוצאת את ה-bucket שה-<code>dentry</code> אמור להיות בו בתוך ה-hash table המשנית (הטבלה <code>in_lookup_hashtable</code>).</li>
<li>מקצה אובייקט <code>dentry</code> חדש על ידי שימוש בפונקציה <code>d_alloc</code> , אם ההקצאה נכשלה אז הפונקציה מחזירה שגיאה שאין זיכרון (<code>-ENOMEM</code>).</li>
<li>לאחר מכן מתחיל השלב הבא בתהליך , הקטע שמסומן עם lable בשם <code>retry</code>.
<ol>
<li>מתחיל קטע קריטי על ידי קריאה ל-<code>rcu_read_lock</code>.</li>
<li>נלקחת דגימה של <code>i_dir_seq</code> על ידי <code>smp_load_acquire</code>. יש שימוש ב-<code>smp_load_acquire</code> כי הוא נותן הבטחה בין אותם המעבדים שמשתתפים בשרשרת acquire ו-release שיראו את אותו הדבר של הפעולות ויהיו חשופים השינויים בין מעבדים בשרשרת (ה-<code>smp_store_release</code> מגיע מתוך <code>start_dir_add</code>).</li>
<li>נלקחת דגימה של ה-<code>rename_lock</code> כדי לוודא שאין שינויים בעץ בזמן הזה ואם כן אז מתחילים מחדש.</li>
<li>מחפשים אם כבר קיים <code>dentry</code> לקובץ שאנחנו מנסים ליצור לו <code>dentry</code> חדש בעזרת <code>__d_lookup_rcu</code>, בנוסף מעבירים לפונקציה את <code>d_seq</code> כדי לבדוק בהמשך שלא יתרחש שינוי ב-<code>dentry</code>.
<ol>
<li>אם מוצאים <code>dentry</code> תואם אז מנסים להעלות ב-1 את המונה ספירה של ה-<code>lockref</code> שלו בעזרת <code>lockref_get_not_dead</code>.</li>
<li>אם זה מצליח אז ממשיכים ואם נכשל אז ה-<code>lockref</code> מת ומנסים שוב פעם על ידי חזרה לשלב 3.1 ושחרור של הקטע הקריטי של ה-rcu על ידי <code>rcu_read_unlock</code>.</li>
</ol>
</li>
</ol>
</li>
<li>יש קריאה ל-<code>read_seqcount_retry</code> שמסיים את הקטע הקריטי שנפתח על ידי <code>__d_lookup_rcu</code>, ואם היה שינוי ב-<code>d_seq</code> אז משחררים את ה-<code>rcu</code> (על ידי <code>rcu_read_unlock</code>) וה-<code>dentry</code> (על ידי <code>dput</code>) ומנסים שוב פעם על ידי חזרה לשלב 3.1.</li>
<li>אם הגענו לכאן אז מצאנו בשלב 3.4 <code>dentry</code> מתאים ותקף ואפשר להשתמש בו, ולכן אפשר לסיים את הפונקציה, מסיימים את הקטע הקריטי של ה-<code>rcu</code> ומשחררים את ה-<code>dentry</code> שהוקצה בשלב 2 ומחזירים את ה-dentry שמצאנו.</li>
<li>בודקים אם היה שינוי בעץ ה-dcache על ידי בדיקה של <code>rename_lock</code> ואם היה שינוי אז מסיימים את הקטע הקריטי של ה-<code>rcu</code> ומנסים שוב פעם על ידי חזרה לשלב 3.1.</li>
<li>בודקים אם הערך של <code>seq</code> הוא אי זוגי (כלומר מצב לא תקין, נעשה בו שינוי שעוד לא הסתיים) ואם הוא אי זוגי אז  מסיימים את הקטע הקריטי של ה-<code>rcu</code> ומנסים שוב פעם על ידי חזרה לשלב 3.1.</li>
<li>לאחר מכן נועלים את ה-bucket שמצאנו בשלב 1.</li>
<li>בודקים אם הדגימה שנעשה קודם של <code>i_dir_seq</code> לא תואמת למצב הנוכחי שלו אז פותחים את העילה של ה-bucket,  ומנסים שוב פעם על ידי חזרה לשלב 3.1.</li>
<li>אם הגענו לכאן אז אין שינויים עבור האב מאז תחילת ה-d_lookup (הסבר בתיעוד של הפונקציה) ובגלל שנעילה של ה-bucket אז בוודאות לא יכולים לשחרר את הערכים שנמצאים בו ולכן זה בטוח לעבור על הערכים שבו עם <code>hlist_bl_for_each_entry</code>, ולכן עוברים בלולאה על כל <code>dentry</code> שמופיע ב-bucket ובודקים אם הוא מתאים ליעד שלנו:
<ol>
<li>בודקים אם ה-<code>hash</code>, <code>parent</code> ו-<code>name</code> שונים מהיעד ואם כן מדלגים לערך הבא ב-bucket, אם כל האלה זהים אז מנסים להעלות את המונה ספירה שלו ב-lockref שלו עם <code>lockref_get_not_dead</code> ואם זה נכשל והמנעול מת אז ומנסים שוב פעם על ידי חזרה לשלב 3.1.</li>
<li>אם הגענו לכאן מצאנו את ה-<code>dentry</code> יעד שלנו ואנחנו מחזיקים הפניה אליו אז הוא לא יכול להשתחרר ולכן אפשר לסגור את הקטע הקריטי של <code>rcu</code> עם <code>rcu_read_unlock</code>.</li>
<li>לאחר מכן נועלים את ה-<code>d_lock</code> ומודאים שלא נמצאים תחת lookup ולכן קוראים ל-<code>d_wait_lookup</code>.</li>
<li>לאחר שחזרנו מ-<code>d_wait_lookup</code> אז כבר אין מישהו שמחפש את ה-<code>dentry</code> וצריך לוודא שה-<code>dentry</code> שיש לנו נשאר כמו שאנחנו צריכים ולא עבר שינוי בזמן ההמתנה ולכן עושים בדיקה אם ה-<code>hash</code>, <code>parent</code>, <code>name</code> זהים ליעד שלנו וגם בודקים שהוא נמצא ב-hash table על ידי <code>d_unhashed</code> ואם לא אז קופצים ל-lable בשם <code>mismatch</code> (שלב 14).</li>
<li>אם הגענו לכאן אז יש התאמה סופית ליעד שלנו, כלומר היה מישהו אחר שיצר את ה-dentry שחיפשנו וה-task הנוכחי הפסיד במירוץ מולו, ולכן אנחנו צריכים לשחרר את <code>new</code> שהקצאנו ולאחר מכן אפשר להחזיר את ה-<code>dentry</code> שנמצא ולסיים את הפונקציה.</li>
</ol>
</li>
<li>אם הגענו לכאן אז לא מצאנו dentry ב-bucket התואם ליעד שלנו, אנחנו צריכים אז להשתמש באחד שהקצאנו בשלב 2.</li>
<li>משחררים את ה-<code>rcu</code> עם <code>rcu_read_unlock</code>.</li>
<li>לאחר מכן אנחנו מעדכנים את השדות של ה-<code>dentry</code> שלנו ללא הנעילה <code>d_lock</code>  אבל גם לא צריך כי אנחנו היחידים שאמורים להיות נגישים אליו.</li>
<li>מדליקים את הדגל <code>DCACHE_PAR_LOOKUP</code> שאומר שאנחנו תחת תהליך lookup  מעדכנים את ה-<code>d_wait</code> לתור שלנו.</li>
<li>מוסיפים את ה-<code>dentry</code> ל-bucket המתאים (שמצאנו בשלב 1) ופותחים את הנעילה של ה-bucket ואפשר לסיים את התהליך וכאן מסתיימת הפוקנציה ומחזירים את ה-<code>dentry</code> שלנו (את <code>new</code>)</li>
<li>ה-lable בשם <code>mismatch</code> הוא קטע שאפשר להגיע אליו רק בקפיצה (לפניו יש <code>return</code>) והוא בסוף הפונקציה, הוא פשוט פתוח את הנעילה של <code>d_lock</code> ועושה <code>dput</code> ולאחר מכן חוזר לשלב 3.1.</li>
</ol>
<h2 id="הפונקציה-d_instantiate">
  הפונקציה <code>d_instantiate</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_instantiate">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="nf">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="nf">hlist_unhashed</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_alias</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		<span class="nf">security_d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">		<span class="nf">__d_instantiate</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה <code>d_instantiate</code> אחראית לקישור בין <code>inode</code> ל-<code>dentry</code> שמשוייכת אליו.</p>
<p>הפעולות המבוצעות על ידי הפונקציה:</p>
<ol>
<li>נעילת המנעול <code>i_lock</code> של ה-<code>inode</code></li>
<li>יש קריאה ל-<code>__d_instantiate</code> שאחראית בפועל לקישור עצמו בין  ה-<code>inode</code> ל-<code>dentry</code>.</li>
<li>פותחים את הנעילה של <code>i_lock</code>.</li>
</ol>
<h3 id="הפונקציה-__d_instantiate">
  הפונקציה <code>__d_instantiate</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__d_instantiate">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_instantiate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="kt">unsigned</span> <span class="n">add_flags</span> <span class="o">=</span> <span class="nf">d_flags_for_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">WARN_ON</span><span class="p">(</span><span class="nf">d_in_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="cm">	* Decrement negative dentry count if it was in the LRU list.
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_LRU_LIST</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="nf">this_cpu_dec</span><span class="p">(</span><span class="n">nr_dentry_negative</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="nf">hlist_add_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_u</span><span class="p">.</span><span class="n">d_alias</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="nf">raw_write_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="nf">__d_set_inode_and_type</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">add_flags</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="nf">raw_write_seqcount_end</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="nf">fsnotify_update_flags</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>היא פונקציה שמעדכנת את השדות הרלוונטים ב-<code>dentry</code> כשצריך לקשר אותו ל-<code>inode</code>, היא פונקציה יותר פנימית מ-<code>d_instantiate</code> (כמו שניתן לראות לפי השם שלהן) והיא מניחה שה-<code>inode</code> נעול מראש.</p>
<p>בתחילה הפונקציה משתמשת ב-<code>d_flags_for_inode</code> על מנת לקבל וליצור את הדגלים הרלוונטים ל-<code>dentry</code>.</p>
<p>לאחר מכן נועלים את ה-<code>dentry</code> עם ה-<code>d_lock</code> שלו, כדי להגן מפני שינויים בו זמנית על ה-<code>dentry</code>.</p>
<p>השלב הבא כמו שכתוב בהערות בקוד הוא הקטנת המונה של ה-<code>dentry</code> השליליות אם היא הייתה ברשימת ה-<code>LRU</code>.</p>
<p>לאחר מכן צריך להוסיף את ה-<code>dentry</code> לתוך ה-hash table של ה-<code>inode</code> בשדה <code>i_dentry</code> שהוא טבלה שמשמשת למיפוי של ריבוי לינקים לאותו <code>inode</code>. וזה נעשה על ידי השורה:
<code>hlist_add_head(&amp;dentry-&gt;d_u.d_alias, &amp;inode-&gt;i_dentry);</code></p>
<p>אחרי זה יש קריאה ל-<code>raw_write_seqcount_begin</code> בגלל שיכול להיות thread-ים אחרים שבו זמנית משתמשים ב-<code>dentry</code> הזה, ואנחנו רוצים לשנות ערכים ב-<code>dentry</code> ולכן צריך לדאוג שהם יסתנכרנו איתנו ולא ישתמשו בערכים ישנים, וזה משמש כמנגנון נעילה יחסית קל.
לאחר שה-<code>dentry</code> נעל את ה-<code>d_seq</code> שלו אפשר לקרוא ל-<code>__d_set_inode_and_type</code> שמעדכן את ה-<code>inode</code> והדגלים.</p>
<p>לאחר העדכון משחררים את <code>d_seq</code> עם קריאה ל-<code>raw_write_seqcount_end</code></p>
<p>לבסוף יש קריאה ל-<code>fsnotify_update_flags</code> שמפיצה שהיה עדכון של ה-dentry על ידי המערכת של <code>fsnotify</code>.</p>
<p>ועל מנת לסיים את התהליך פותחים את הנעילה של <code>d_lock</code>.</p>
<h2 id="פונקציות-עזר">
  פונקציות עזר
  <a class="heading-link" href="#%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%95%d7%aa-%d7%a2%d7%96%d7%a8">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<h3 id="הוספת-קבצים-לתיקייה">
  הוספת קבצים לתיקייה
  <a class="heading-link" href="#%d7%94%d7%95%d7%a1%d7%a4%d7%aa-%d7%a7%d7%91%d7%a6%d7%99%d7%9d-%d7%9c%d7%aa%d7%99%d7%a7%d7%99%d7%99%d7%94">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="הפונקציה-start_dir_add">
  הפונקציה <code>start_dir_add</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-start_dir_add">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">start_dir_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		<span class="kt">unsigned</span> <span class="n">n</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_dir_seq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nf">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_dir_seq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">			<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="nf">cpu_relax</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מתנהגת כמו <code>seqcount</code>, יש כאן התנהגות כמעט זהה ל-<code>seqcount</code> רגיל רק ללא תוספות ל-<code>lockdep</code>.</p>
<p>המטרה של הפונקציה היא למנוע שינוי של ה-<code>inode</code> (שינוי של קבצים בתיקייה) במקביל בנסיון לצמצם את הנעילה כמה שיותר, והיא משומשת בתחילת ניסיון של שינוי ה-<code>inode</code>.</p>
<p>הרעיון די פשוט:</p>
<ol>
<li>בהתחלה נלקח דגימה של המונה נעילה של ה-<code>inode</code> שהוא השדה <code>i_dir_seq</code>.</li>
<li>לאחר מכן יש <code>if</code> שבודק האם ה-<code>caller</code> הוא היחיד שמשנה עכשיו את <code>i_dir_seq</code>, וזה מונע התנגשות בין מספר כותבים.
<ol>
<li>דבר ראשון נבדק האם הערך של <code>n</code> הוא זוגי ואם לא אז  מחכים בלולאה בגלל שערך תקין על מנת להמשיך חייב להיות זוגי, המטרה של הבדיקה המקדימה הזאת כי כדי לצמצם את מספר הפעמים שצריך להשתמש ב-<code>cmpxchg</code> בגלל שהיא פעולה יחסית כבדה למעבד.</li>
<li>הבדיקה האמיתית נעשית על ידי השוואה לערך <code>n</code> שנדגם בשלב הקודם (שלב 1), ואם הם שווים אז אין עוד מישהו שמנסה לכתוב עכשיו ל-<code>i_dir_seq</code> ואפשר להמשיך. אם עוד מישהו מנסה לשנות את <code>i_dir_seq</code> הוא לא יצליח בגלל שהשינוי נעשה על די <code>cmpxchg</code> והוא יחכה בלולאה.</li>
</ol>
</li>
<li>במקרה שהתנאים ב-<code>if</code> עבדו אז ניתן לצאת מהפונקציה ולהחזיר את הערך של <code>n</code>.</li>
<li>אם ה-<code>if</code> נכשל אז ממתינים בלולאה עם <code>cpu_relax</code>.</li>
</ol>
<h4 id="הפונקציה-end_dir_add">
  הפונקציה <code>end_dir_add</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-end_dir_add">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">end_dir_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nf">smp_store_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_dir_seq</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה היא החלק השני של <code>start_dir_add</code>, המטרה של <code>end_dir_add</code> היא לפתוח את הנעילה שנעשת על ידי <code>start_dir_add</code> ולסיים את הקטע הקריטי של השינוי <code>inode</code>.
הפונקציה מקבלת את ה-<code>inode</code> שנעול ו-<code>n</code> שהוא הדגימה שנלקחה על ידי <code>start_dir_add</code>.</p>
<p>הפונקציה כמו שאפשר לראות מאוד קצרה ועושה דבר אחד, היא מעדכנת את הערך של <code>i_dir_seq</code> לערך התחלתי <code>n+2</code> כדי שהחלקים שממתינים בלולאת הנעילה בפונקציה <code>start_dir_add</code> יכולו להמשיך.</p>
<p>הפונקציה משתמשת במחסום זיכרון <code>smp_store_release</code> בגלל שצריך לוודא שלאחר השינוי הערך החדש יגיע לשאר המעבדים במערכת כדי להבטיח ששינויים אחרים שנעשו לפני stores יהיו גלויים ל-threads אחרים שרואים את ה-store.</p>
<h4 id="הפונקציה-d_wait_lookup">
  הפונקציה <code>d_wait_lookup</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_wait_lookup">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">d_wait_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">d_in_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">		<span class="nf">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		<span class="nf">add_wait_queue</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">			<span class="nf">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">			<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">			<span class="nf">schedule</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">			<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">d_in_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא לחכות (להירדם) עד שה-<code>dentry</code> שמקבלים כפרמטר לא יהיה תחת תהליך lookup.</p>
<ol>
<li>בהתחלה יש בדיקה אם ה-<code>dentry</code> בתהליך חיפוש ואם לא אז הפונקציה מסתיימת בלי לעשות כלום (אין צורך להמתין), אם היא כן בתהליך אז ממשיכים.</li>
<li>מוסיפים את <code>current</code> (ה-<code>task</code> הנוכחי) ל-<code>wait_queue</code> של ה-<code>dentry</code> ולאחר מכן הוא נכנס ללולאה:
<ol>
<li>הפונקציה משנה את המצב של ה-task הנוכחי ל-<code>TASK_UNINTERRUPTIBLE</code> כדי שתוכל ללכת לישון</li>
<li>פותחים את הנעילה של ה-d_lock של ה-<code>dentry</code> כדי לתת אפשרות לתהליך החיפוש להסתיים כי אסור לישון עם <code>spinlock</code> תפוס.</li>
<li>קוראים ל-<code>schedule</code> כדי לתזמן מחדש את ה-<code>task</code> וללכת לישון.</li>
<li>לאחר שה-<code>task</code> חוזר לריצה צריך דבר ראשון לנעול את <code>d_lock</code> כדי לוודא שלא משנים את ה-<code>dentry</code>.</li>
<li>בודקים אם ה-<code>dentry</code> נמצא בתהליך של <code>lookup</code> (כמו בהתחלה) ואם כן אז חוזרים לשלב 2.1.</li>
<li>אם ה-<code>dentry</code> לא נמצא תחת חיפוש אז אפשר להמשיך וכאן מסתיימת הפונקציה.</li>
</ol>
</li>
</ol>
<h1 id="הסרת-dentry">
  הסרת <code>dentry</code>
  <a class="heading-link" href="#%d7%94%d7%a1%d7%a8%d7%aa-dentry">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="הפונקציה-dput">
  הפונקציה <code>dput</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-dput">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">dput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">		<span class="nf">might_sleep</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="nf">rcu_read_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="nf">fast_dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">			<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">			<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="cm">/* Slow case: now with the dentry lock held */</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="nf">retain_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">			<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">			<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">		<span class="n">dentry</span> <span class="o">=</span> <span class="nf">dentry_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה משחררת החזקה של <code>dentry</code> על ידי הפחתה של המונה ספירה ב-<code>1</code>, ואם היא מגיעה למצב שאין יותר הפניות ל-<code>dentry</code> היא מטפלת בזה.</p>
<p>הפעולות המבוצעות על ידי הפונקציה:</p>
<p>בתחילה הפונקציה פותחת קטע קריטי של צד קריאה של <code>RCU</code> ולכן קוראת ל-<code>rcu_read_lock</code>.</p>
<p>לאחר מכן יש ניסיון של הפונקציה <code>fast_dput</code> שמטרתה היא להקטין את המונה ספירה בצורה מהירה בגלל שהוא מוכן לטפל במקרים שהמונה גדול מ-<code>0</code>, אם יש בעיות והוא לא מצליח או שהמונה הגיע ל-<code>0</code> אז צריך טיפול אחר, ומגיעים למסלול האיטי.
לאחר הריצה של <code>fast_dput</code> גם אם הוא הצליח וגם אם הוא נכשל צריך לסיים את הקטע הקריטי של ה-<code>RCU</code> על ידי <code>rcu_read_unlock</code>.
אם המסלול המהיר הצליח אז כאן הפונקציה מגיעה לסיום וחוזרת על ידי <code>return</code>.</p>
<p>וכמו שהוסבר למעלה אם הוא נכשל אז ממשיכים למסלול האיטי:
יש קריאה ל-<code>retain_dentry</code> שהיא פונקציה שבודקת אם צריך לשמור את ה-<code>dentry</code> (הסבר מורחב בהמשך), אם הפונקציה מצליחה אז צריך להשאיר את ה-<code>dentry</code> לשימוש חוזר בהמשך ופותחים את הנעילה של <code>d_lock</code> (הנעילה מופעלת בתוך <code>fast_dput</code> ולא משוחררת אם המסלול המהיר נכשל) והפונקציה מסתיימת, ואם הוא נכשל אז צריך להרוג את ה-<code>dentry</code> על ידי <code>dentry_kill</code> (הסבר מורחב בהמשך המאמר).</p>
<h3 id="הפונקציה-fast_dput">
  הפונקציה <code>fast_dput</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-fast_dput">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">fast_dput</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">d_flags</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_DELETE</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="k">return</span> <span class="nf">lockref_put_or_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">lockref_put_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">		<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">			<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">			<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">	<span class="nf">smp_rmb</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">	<span class="n">d_flags</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">	<span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="n">DCACHE_REFERENCED</span> <span class="o">|</span> <span class="n">DCACHE_LRU_LIST</span> <span class="o">|</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">				<span class="n">DCACHE_DISCONNECTED</span> <span class="o">|</span> <span class="n">DCACHE_DONTCACHE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">				
</span></span><span class="line"><span class="ln">24</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">d_flags</span> <span class="o">==</span> <span class="p">(</span><span class="n">DCACHE_REFERENCED</span> <span class="o">|</span> <span class="n">DCACHE_LRU_LIST</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nf">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">	
</span></span><span class="line"><span class="ln">27</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">	<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה <code>fast_dput</code> היא המסלול המהיר להפחתת הפניות ל-<code>dentry</code>. היא תנסה להשתמש בפעולות אטומיות כדי להקטין את ספירת ההתייחסות ב-<code>1</code>. אם ספירת ההתייחסות גדולה מ-<code>0</code>, היא תצליח, אחרת היא צריכה להיכנס ללוגיקת הנעילה (למרות השם של הפונקציה היא גם מוכנה לנעול את ה-<code>d_lock</code> ולהתנהג בצורה איטית יותר במקרה שנכשלה ללא הנעילה).
הפונקציה מניחה שכבר יש נעילת קריאה <code>RCU</code> (אמור לפעול על ידי קריאה ל-<code>rcu_read_lock</code> ב-<code>dput</code> הרגיל).</p>
<ol>
<li>
<p>בתחילת הפונקציה יש בדיקה אם הדגל <code>DCACHE_OP_DELETE</code> דלוק ב-<code>dentry</code>, הוא יהיה דלוק רק אם המערכת קבצים שלה ה-<code>dentry</code> שייך מקיימת <code>d_op-&gt;d_delete</code> ורשמה את הפונקציה <code>d_delete</code>.
אם הדגל דלוק אז אנחנו לא יכולים להקטין את המונה ספירה ל-<code>0</code>, כי יש טיפול שצריך להעשות ב-<code>d_delete</code> ואם צריך להוריד את המונה ל-<code>0</code> ה-<code>d_lock</code> ננעל, הקטנת המונה נעשית על ידי הפונקציה <code>lockref_put_or_lock</code> שבדיוק עושה את הלוגיקה שהוסברה קודם, היא בודקת אם המונה לפני הקטנת המונה קטן או שווה ל-<code>1</code> ואם כן אז הפונקציה נועלת את המנעול ומסתיימת, אחרת היא פשוט מקטינה את המונה ומסתיימת עם ערך חזרה  <code>true</code>.</p>
</li>
<li>
<p>אם הדגל לא דולק אז מנסים פשוט להפחית את מונה ספירה על ידי <code>lockref_put_return</code> שמקטין את המונה כל עוד הוא יכול, כלומר כל עוד המונה לפני השינוי חיובי, ואם הוא מצליח הוא מחזיר את הערך החדש של המונה, ואם הוא נכשל זה אומר שיש thread אחר שמחזיק את ה-<code>d_lock</code>, והפונקציה מחזירה ערך שגיאה <code>1-</code>. הערך חזרה נכנס לתוך המשתנה המקומי <code>ret</code>.</p>
</li>
<li>
<p>לאחר מכן אם <code>ret</code> חיובי והקטנת המונה הצליחה, אז כאן מסתיימת העבודה והפונקציה מחזירה <code>true</code>. אם <code>ret</code> מכיל ערך שגיאה אז מנסים לנעול את <code>d_lock</code>.
לאחר מכן בודקים אם אפשרי להקטין את המונה (כלומר בודקים אם המונה גדול מ-<code>1</code> בגלל שאם הוא קטן מ-<code>1</code> אז צריך טיפול אחר) ואם אפשר אז מקטינים אותו ופותחים את הנעילה ומחזירים <code>true</code> ואם אי אפשר אז המונה כבר הגיע לפני כן ל-<code>0</code> ואסור לנו כרגע להקטין אותו, והטיפול המהיר מסתיים מחזיר <code>false</code> (ללא שיחרור של המנעול).</p>
</li>
<li>
<p>אם הגענו לנקודה הזאת אז הצלחנו להפחית את המונה והוא <code>0</code> כרגע, ואנחנו לא מחזיקים את נעילת ה-<code>dentry</code>, כך שמישהו אחר יוכל לקבל הפניה ל-<code>dentry</code> שוב, ולעשות עוד <code>dput</code>, ואנחנו צריכים לא להתחרות עם זה.</p>
<p>עם זאת, יש מקרה מאוד מיוחד ונפוץ שבו לא אכפת לנו, כי אין מה לעשות: ה-<code>dentry</code> עדיין נמצאה בטבלת hash, ואין לו <code>d_delete</code>, וגם הוא עם הפניה (כלומר יש מישהו שמצביע עליו) וכבר ברשימת ה-LRU.</p>
<p>מכיוון שאנו לא נעולים, הערכים הללו אינם &ldquo;יציבים&rdquo;. עם זאת, די בכך שבשלב מסוים לאחר שזרקנו את הפניה, ה-<code>dentry</code> נכנסו לטבלת hash ולדגלים היה הערך המתאים. ייתכן שמשתמשי <code>dentry</code> אחרים קיבלו מחדש הפניה ל-<code>dentry</code> ושינו את זה, אבל העבודה שלנו הסתיימה - אנחנו יכולים להשאיר את ה-<code>dentry</code> בסביבה עם מונה <code>0</code>.</p>
<p>עם זאת, ישנם שני מקרים שעלינו להרוג את ה-<code>dentry</code> בכל מקרה.</p>
<ol>
<li>כשה-<code>dentry</code> מנותק (disconnected - כלומר ללא קישור ל-inode) וחופשי (ללא הפניות) ברגע שהמונה מגיע ל-<code>0</code>.</li>
<li>כשה-<code>dentry</code> חופשי (ללא הפניות) ואסור לאחסן אותן ב-cache.</li>
</ol>
</li>
<li>
<p>כאן כמו שהוסבר למעלה אין מנגנון נעילה דלוק, (חוץ מ-<code>RCU</code> אבל הוא לא מגן על שדות של ה-<code>dentry</code> אלה הוא מגן על כל האובייקט מפני שחרור) ולכן צריך לפעול בזהירות.
אנחנו רוצים לקבל את הערך של <code>d_flags</code> העדכני על מנת לבדוק את הדגלים הדלוקים של ה-<code>dentry</code> אבל אי אפשר סתם לקרוא אותו בגלל שכרגע אין לנו מנגנון סינכרון שמגן מפני שינוי הדגלים ב-thread-ים אחרים במקביל, ולכן לפני הקריאה עצמה צריך להוסיף מחסום זיכרון של קריאה: <code>smp_rmb</code> שמטרתו היא להבטיח שהשינויים שבוצעו על ידי thread אחר שמשנה את הדגלים יהיו גלויים לפני קריאת מבנה הנתונים המשותף. הם מונעים מהקורא להתבונן בנתונים מעופשים או לא עקביים.
לאחר מכן צריך לקרוא את <code>d_flags</code> עם <code>READ_ONCE</code> בשביל למנוע בעיות שיכולות להתרחש:</p>
<ul>
<li>
<p>קריעת זיכרון שיכולה לפגוע באחידות המידע (במקרה שיש קריעת זיכרון אז כבר הקריאה לא נעשית על ידי <code>load</code> יחיד ויכול להיות שינויים בערך בין ה-<code>loads</code>).</p>
</li>
<li>
<p>בעיות באחידות ה-cache: ה-<code>READ_ONCE</code> מספק קוהרנטיות cache עבור גישה ממעבדים מרובים למשתנה בודד.</p>
</li>
</ul>
</li>
</ol>
<p>יש עוד בעיות ואפקטים שה-<code>READ_ONCE</code> מונע, להסבר נוסף אפשר לקרוא במאמר שכתבי על מחסומי זיכרון.</p>
<ol start="6">
<li>לאחר שהשגנו את הערך של הדגלים, בודקים אם צריך לעשות עוד משהו, על ידי הדגלים: <code>DCACHE_LRU_LIST</code> ו-<code>DCACHE_REFERENCED</code> (שיש הסבר עליהם במאמר) ואם אחד מהם לפחות דולק וגם ה-<code>dentry</code> נמצא בטבלת hash, אז סיימנו את העבודה והפונקציה מחזירה <code>true</code>.</li>
</ol>
<p>7.אם הגענו לכאן אז זה לא המקרה המהיר שפשוט לטפל בו שהוזכר קודם, ולכן נועלים את ה-<code>dentry</code> וצריך לבדוק מחדש את המונה: אם הוא שונה מ-<code>0</code> אז סיימנו את העבודה כי יש מישהו אחר שגם מחזיק הפניה אל ה-<code>dentry</code> ופותחים את הנעילה ומחזירים <code>true</code>.
ואם המונה הוא <code>0</code> רק אנחנו מחזיקים בו אז צריך להעלות אותו בחזרה ל-<code>1</code> בגלל שלא הצלחנו לטפל בו כמו שצריך, יש להחזיר את המונה ל-<code>1</code> כי אנחנו לפני כן הורדנו את הערך שלו, ניתן לראות כאן שימוש נחמד של הרעיון של <code>lockref</code> שהוא מאפשר לבעל המנעול גישה עקיפה לא דרך פונקציות של משפחת ה-<code>lockref</code>, הגישה העקיפה מאפשרת למחזיק הנעילה לשנות את הערך של המונה ללא צורך בכלים מיוחדים, אלה בכתיבה פשוטה (להסבר נוסף על ה-lockref).
בסיום מחזירים ערך <code>false</code> על מנת לנסות לאחר מכן לשחרר את ההפניה של ה-<code>dentry</code>.</p>
<h2 id="הפונקציה-d_drop">
  הפונקציה <code>d_drop</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_drop">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="nf">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מטבטלת את ה-hash של ה-dentry מרשימת ה-hash של ה-detnry אב שלו, כלומר ה-d_drop מסיר את ה-dentry מעץ ה-dentries, ואז התיקייה או הקובץ לא יימצאו בעץ dentries.</p>
<p>הפונקציה <code>d_drop</code> היא עטיפת נעילה של <code>d_lock</code> שקוראת ל-<code>__d_drop</code> שעושה קצת יותר אבל גם לא עושה הכל בעצמה.</p>
<h3 id="הפונקציה-__d_drop">
  הפונקציה <code>__d_drop</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__d_drop">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">__d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">		<span class="nf">___d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">.</span><span class="n">pprev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">		<span class="nf">write_seqcount_invalidate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא ניתוק ה-<code>dentry</code> מתוך הטבלת hash שהיא נמצאת בה.</p>
<p>הפונקציה מניחה מראש ש-<code>d_lock</code> מוחזק, בהתחלה יש בדיקה האם ה-<code>dentry</code> הוא <code>hashed</code> כלומר האם הוא נמצא בטבלת hash כרגע, ואם הוא לא אז לא נעשה כלום (הוא לא נכנס ל-<code>if</code>) והפונקציה מסתיימת ואם הוא כן נמצאה אז אפשר להמשיך.</p>
<p>לאחר מכן יש קריאה ל-<code>___d_drop</code> שמנתקת את ה-<code>dentry</code> מתוך הטבלת hash.
לאחר מכן צריך לעשות עוד משהו קטן, צריך לגרום ל-<code>dentry-&gt;d_hash.pprev</code> להצביע ל-<code>NULL</code> כדי למנוע דליפה של מצביעים לא חוקיים.</p>
<p>ולבסוף יש קריאה ל-<code>write_seqcount_invalidate</code> שאחראי על ביטול התוקף של פעולות שרצות כרגע עם קריאה עם שימוש ב-<code>d_seq</code>.</p>
<h3 id="הפונקציה-___d_drop">
  הפונקציה <code>___d_drop</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-___d_drop">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">___d_drop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="cm">	* Hashed dentries are normally on the dentry hashtable,
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="cm">	* with the exception of those newly allocated by
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="cm">	* d_obtain_root, which are always IS_ROOT:
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">		<span class="n">b</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_roots</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="n">b</span> <span class="o">=</span> <span class="nf">d_hash</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="nf">hlist_bl_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	<span class="nf">__hlist_bl_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	<span class="nf">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא לנתק את ה-<code>dentry</code> מתוך הטבלת hash שהוא נמצא בא.
בתור התחלה צריך לבדוק באיזה טבלת hash ה-<code>dentry</code> נמצא, ולכן צריך לבדוק אם ה-<code>dentry</code> הוא <code>root</code>, (כלומר ה-<code>/</code> של המערכת קבצים, לא הגלובלית אלה של <code>mount</code> מסויים), בגלל ש-<code>dentry</code> שהם <code>root</code> לא נמצאות בטבלה הרגילה אלה נמצאות ב-<code>super_block</code> שלהן.
ואם הם <code>dentry</code> רגילים אז הם נמצאים ב-<code>dentry_hashtable</code>, (להרחבה בנושא של טבלאות ה-hash של ה-<code>dentry</code>) ונעשה חיפוש של ה-<code>dentry</code> בטבלת hash על ידי <code>d_hash</code>.</p>
<p>אחרי שמוצאים את ה-bucket  שמכיל את ה-<code>dentry</code> בטבלת hash, הוא מוכנס למשתנה המקומי <code>b</code>.
נועלים את ה-bucket עם הפונקציה <code>hlist_bl_lock</code>.
מוחקים את הקישור של ה-<code>dentry</code> לטבלת hash בעזרת <code>__hlist_bl_del</code>.
ולבסוף פותחים את הנעילה של ה-bucket ומסתיימת הפונקציה.</p>
<h2 id="הפונקציה-d_delete">
  הפונקציה <code>d_delete</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_delete">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">void</span> <span class="nf">d_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="cm">	* Are we the only user?
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="cm">	*/</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_CANT_MOUNT</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="nf">dentry_unlink_inode</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">		<span class="nf">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מנסה למחוק את ה-<code>dentry</code> כלומר היא מנסה לנתק את ה-inode שמשויך ל-<code>dentry</code> ולהפוך את ה-<code>dentry</code> לשלילי.</p>
<ol>
<li>הפונקציה בהתחלה נועלת את ה-spinlocks של ה-dentry וה-inode: המנעול <code>d_lock</code> ו-<code>i_lock</code>.</li>
<li>לאחר מכן יש בדיקה אם היא הפונקציה היא היחידה עם הפניה ל-<code>dentry</code> אם כן אז אין בעיה לנתק את ה-inode וזה נעשה על ידי <code>dentry_unlink_inode</code> ולפני הניתוק גם דואגים לכבות את הדגל <code>DCACHE_CANT_MOUNT</code>.</li>
<li>אם יש שימוש נוסף חוץ מבפונקציה כרגע של ה-<code>dentry</code> והמונה הוא לא <code>1</code> אז צריך למנוע גישות חדשות ל-<code>dentry</code> וזה נעשה על ידי <code>__d_drop</code> שמנתק את ה-<code>dentry</code> מתוך הטבלת hash שהיא נמצאת בה, ולבסוף משחררים את המנעולים.</li>
</ol>
<h1 id="חיפוש-dentry">
  חיפוש <code>dentry</code>
  <a class="heading-link" href="#%d7%97%d7%99%d7%a4%d7%95%d7%a9-dentry">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="הפונקציה-d_lookup">
  הפונקציה <code>d_lookup</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_lookup">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">d_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	  
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">		<span class="n">seq</span> <span class="o">=</span> <span class="nf">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="n">dentry</span> <span class="o">=</span> <span class="nf">__d_lookup</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא בהינתן ה-<code>dentry</code> אב, ושם של <code>dentry</code> בן, למצוא <code>dentry</code> מסויים ולהחזיר אותו לאחר הגדלה של מונה הספירה שלו, אם הוא לא נמצא אז חוזר ערך <code>NULL</code>.</p>
<h3 id="תהליך-החיפוש-ב-dcache">
  תהליך החיפוש ב-<code>dcache</code>:
  <a class="heading-link" href="#%d7%aa%d7%94%d7%9c%d7%99%d7%9a-%d7%94%d7%97%d7%99%d7%a4%d7%95%d7%a9-%d7%91-dcache">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>דבר ראשון נלקחת דגימה של המנעול <code>rename_lock</code> כדי לוודא שאין שינוי בעץ dentry בזמן החיפוש ואם יש שינוי אז החיפוש נעשה שוב פעם.</li>
<li>יש קריאה ל-<code>__d_lookup</code> שהיא הפונקציה שבאמת מבצעת את החיפוש אבל היא לא משתמשת ב-<code>rename_lock</code>.</li>
<li>לאחר סיום <code>__d_lookup</code> בודקים את הערך חזרה של ה-<code>dentry</code> שמחפשים, ואם הוא נמצא אז מסיים החיפוש ומחזירים את ה-<code>dentry</code>, ואם לא נמצא אז ממשיכים.</li>
<li>בנקודה הזאת לא נמצא עוד ה-<code>dentry</code> הרצוי, זה יכול להיות בגלל שבאמת הוא לא נמצא או בגלל שינויים שנעשו בעץ ה-dentry, וכדי לבדוק שלא נעשה שינוי בעץ משתמשים ב-<code>rename_lock</code> ובודקים בעזרת הפונקציה <code>read_seqretry</code> אם נעשה שינוי מהפעם הקודמת שדגמנו את המנעול, ואם היה שינוי אז פשוט מתחילים את הבדיקה עוד פעם על מנת לוודא שלא פספסנו את ה-<code>dentry</code> הרצוי.</li>
</ol>
<h3 id="הפונקציה-__d_lookup">
  הפונקציה <code>__d_lookup</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__d_lookup">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_lookup</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nf">d_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	  
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="nf">rcu_read_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="nf">hlist_bl_for_each_entry_rcu</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	  
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">		
</span></span><span class="line"><span class="ln">15</span><span class="cl">		<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">	
</span></span><span class="line"><span class="ln">17</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">		
</span></span><span class="line"><span class="ln">22</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">d_same_name</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">		
</span></span><span class="line"><span class="ln">25</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">		<span class="n">found</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">		<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="nl">next</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">	<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא כמו <code>d_lookup</code>, בהינתן ה-<code>dentry</code> אב, ושם של <code>dentry</code> בן, למצוא <code>dentry</code> מסויים ולהחזיר אותו לאחר הגדלה של מונה הספירה שלו, אם הוא לא נמצא אז חוזר ערך <code>NULL</code>.</p>
<h3 id="תהליך-החיפוש-ב-dcache-1">
  תהליך החיפוש ב-<code>dcache</code>:
  <a class="heading-link" href="#%d7%aa%d7%94%d7%9c%d7%99%d7%9a-%d7%94%d7%97%d7%99%d7%a4%d7%95%d7%a9-%d7%91-dcache-1">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>דבר ראשון מחפשים את ה-bucket שאנחנו מצפים למצוא בו את ה-dentry הרצוי על ידי הפונקציה <code>d_hash</code> שמקבלת את ה-<code>hash</code> של ה-<code>dentry</code> שמחפשים. גם אם ה-dentry הרצוי לא קיים עדיין ה-bucket תקין, פשוט הוא לא מכיל את ה-dentry הרצוי.</li>
<li>לאחר מכן מתחיל קטע קריטי של קריאת <code>RCU</code> וזה נעשה על ידי הפונקציה <code>rcu_read_lock</code>.</li>
<li>בתוך הקטע הקריטי רצים בלולאה על כל ה-<code>dentry</code> שנמצאים ב-bucket שמצאנו קודם לכן, הלולאה היא סוג של איטרטור שממומש על ידי <code>hlist_bl_for_each_entry_rcu</code> שעובר עם מנגנון <code>rcu</code> על כל הערכים ברשימה של ה-bucket. נעילת ה-<code>RCU</code> נלקחת בגלל שצריך אותה במהלך הלולאה, צריך לוודא שכל הערכים שאנחנו עוברים עליהם ממשיכים להתקיים ואין thread אחר שמנסה לשחרר במקביל את האובייקטים האלה, בגלל שאין כאן שימוש במנעול כי צריך שהקריאה תעשה בצורה מהירה. לדוגמה יכול להיות מקרה של <code>dentry</code> שנמצא ב-bucket עם  מונה הפניות <code>0</code>, שיכול להשתחרר בכל רגע וללא מנעול ה-<code>RCU</code> אין הבטחה שבין המאקרו <code>hlist_bl_for_each_entry_rcu</code> לגישה הבאה לאובייקט הוא לא ישוחרר, וזה יגרום לנו לנסות לגשת לזיכרון לא ידוע, וברור שזה מצב לא רצוי. האיטרטור מכניס את הערך של ה-<code>dentry</code> הנוכחי לתוך המשתנה המקומי <code>dentry</code>.
<ol>
<li>בתוך הלולאה נעשית השוואה אם ה-<code>dentry-&gt;d_name.hash</code> זהה ל-hash הרצוי, אם לא אז ממשיכים בלולאה ואם ה-hash זהה אז לוקחים את הנעילה <code>d_lock</code> של <code>dentry</code> (המשתנה המקומי שמצביע על הערך הנוכחי של האיטרטור).</li>
<li>לאחר מכן בודקים אם הוא באמת ה-<code>dentry</code> שאנחנו מחפשים על ידי השוואה של ה-dentry אב (<code>d_parent</code>)</li>
<li>בנוסף צריך לבדוק שהוא עדיין נמצא בטבלת hash וזה נעשה על ידי <code>d_unhashed</code>. נשמע מוזר לרגע שצריך לבדוק עוד פעם אם הוא נמצא בטבלת hash אם קיבלנו הפניה אליו משם, אבל צריך לזכור שבין הזמן שקיבלנו אותו לעכשיו הפעלנו נעילה של <code>d_lock</code> כך שרק מאותו רגע שהנעילה התחילה אנחנו יודעים שהוא לא עבר שינוי אבל לפני הנעילה יכול להיות ש-thread אחר רץ והוציא אותו מהטבלה.</li>
<li>והבדיקה האחרונה שקובעת האם זה ה-dentry הרצוי היא השוואה של השם עצמו של ה-dentry עם השם שמחפשים, בגלל שיכול להיות שתחת אותו תקיית אב יש התנגשות של hash-ים. הבדיקה נעשית על ידי <code>d_same_name</code>.</li>
<li>אם עברנו את השלב הקודם בהצלחה אז קבענו שמצאנו את ה-dentry הרצוי, ולכן עכשיו צריך להגדיל את המונה ספירה, וזה נעשה על ידי הגדלה פשוטה של המונה: <code>;++dentry-&gt;d_lockref.count</code> זה אפשרי בגלל שמנעול <code>d_lock</code> נעול על ידינו ולא צריך פונקציות של <code>lockref</code>.</li>
<li>לבסוף משחררים את הנעילה של <code>d_lock</code> ומסתיימת הלולאה.</li>
</ol>
</li>
<li>לאחר הלולאה צריך לסגור את הקטע הקריטי של <code>rcu</code> ולכן קוראים ל-<code>rcu_read_unlock</code>.</li>
<li>לבסוף אפשר להחזיר את ה-dentry שמצאנו, ואם לא מצאנו אז חוזר <code>NULL</code>.</li>
</ol>
<h2 id="הפונקציה-__d_lookup_rcu">
  הפונקציה <code>__d_lookup_rcu</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__d_lookup_rcu">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__d_lookup_rcu</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">				<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">				<span class="kt">unsigned</span> <span class="o">*</span><span class="n">seqp</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="n">u64</span> <span class="n">hashlen</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash_len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nf">d_hash</span><span class="p">(</span><span class="nf">hashlen_hash</span><span class="p">(</span><span class="n">hashlen</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">hlist_bl_for_each_entry_rcu</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="nl">seqretry</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">		
</span></span><span class="line"><span class="ln">16</span><span class="cl">		<span class="n">seq</span> <span class="o">=</span> <span class="nf">raw_seqcount_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_COMPARE</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">			<span class="kt">int</span> <span class="n">tlen</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">tname</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="nf">hashlen_hash</span><span class="p">(</span><span class="n">hashlen</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">			<span class="n">tlen</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">			<span class="n">tname</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">			<span class="cm">/* we want a consistent (name,len) pair */</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">read_seqcount_retry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_seq</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">				<span class="nf">cpu_relax</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">				<span class="k">goto</span> <span class="n">seqretry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="nf">d_compare</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">						    <span class="n">tlen</span><span class="p">,</span> <span class="n">tname</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash_len</span> <span class="o">!=</span> <span class="n">hashlen</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">dentry_cmp</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="nf">hashlen_len</span><span class="p">(</span><span class="n">hashlen</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">				<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">		<span class="o">*</span><span class="n">seqp</span> <span class="o">=</span> <span class="n">seq</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">		<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא חיפוש אחר <code>dentry</code> בצורה מהירה ללא כתיבה לאובייקטים גלובלים וללא נעילה (מלבד <code>rcu</code>), היא פונקציה שאסור לקרוא לה מחוץ לליבת ה-<code>vfs</code> בגלל שהיא לא בטוחה, צריך לעשות עוד עבודה מסביבה כדי להבטיח שהיא תחזיר תוצאה בטוחה (הפונקציה יכולה להקירא רק בזמן <code>rcu-walk</code> אז לא באמת בטוח שהיא תצליח להחזיר תוצאה בטוחה, ואם אי אפשר אז ה-caller צריך לקרוא לפונקציות חיפוש אחרות עם <code>ref-walk</code>)</p>
<p>הפרמטרים:</p>
<ul>
<li>הפרמטר <code>parent</code>, ה-<code>dentry</code> אב של יעד החיפוש.</li>
<li>הפרמטר <code>name</code> הוא השם של היעד, מסוג <code>qstr</code>.</li>
<li>הפרמטר <code>seqp</code> הוא כתובת שהפונקציה מקבלת וכותבת אליה את ה-<code>d_seq</code> של ה-<code>dentry</code> כדי שה-caller יוכל לוודא שלא התחרחש שינוי גם ללא נעילה.</li>
</ul>
<ol>
<li>הפונקציה מוצאת את ה-bucket המתאים ל-hash של יעד החיפוש בטבלת hash הראשית (<code>dentry_hashtable</code>) על ידי הפונקציה <code>d_hash</code>.</li>
<li>לאחר מכן עוברים על כל ה-<code>dentries</code> שנמצאים ב-bucket על ידי המאקרו <code>hlist_bl_for_each_entry_rcu</code>, ואנחנו לא משתמשים כאן בשום מנעול מלבד <code>rcu</code> שבאחריות ה-caller, ולכן אפשר לעבור ללא נעילה כי בוודאות לא נגיע למצב של גישה ל-<code>dentry</code> ששוחרר, אבל כן יש אפשרות לפספוס בחיפוש במקרה שיש שינוי שמות בזמן החיפוש שלנו בגלל שאין נעילה, אבל זה יכול להיפתר על ידי חיפוש חוזר במקרה כזה, אבל זה לא נעשה בפונקציה הזאת, זה נעשה ב-<code>d_lookup</code> על ידי שימוש ב- <code>rename_lock</code>.
עבור כל ערך ב-bucket נעשים השלבים הבאים כשהמשתנה המקומי <code>dentry</code> הוא ה-<code>dentry</code> שכרגע בודקים:
<ol>
<li>
<p>דוגמים את ה-<code>d_seq</code> של ה-<code>dentry</code> הנוכחי כדי לזהות אם היה <code>rename</code> במקביל אלינו, וכך מגנים על השדות <code>name</code> ו-<code>parent</code>. הדגימה נעשית על ידי <code>raw_seqcount_begin</code>, השימוש ב-<code>raw</code> ולא בפונקציות גבוהות יותר הוא בגלל שמהיר יותר כי לא מחכים ש-<code>d_seq</code> יתיצב אם הוא במצב של שינוי.
בנוסף יש שימוש ב-<code>raw_seqcount_begin</code>, הוא משתמש ב-<code>smp_rmb</code> ועוזר בצורה עקיפה לגישה לעוד שדות ב-<code>dentry</code> כמו <code>d_name.name</code>, בעזרת המחסום זיכרון שנוצר מובטח שכל פעולות הקריאה (load) הקודמות יושלמו לפני ביצוע פעולת הקריאה העוקבת. זה מונע סידור מחדש של פעולות הקריאה ומבטיח את סדר הקריאה ממיקומי זיכרון משותפים, משתמשים כאן בזה כדי להבטיח שהשינויים שבוצעו על ידי הכותב יהיו גלויים לפני קריאת מבנה הנתונים המשותף, ולכן זה מבטיח בגישה ל-<code>d_name.name</code> שיסתיים ב-<code>NULL</code> בגלל שיש כתיבה עם <code>smp_store_release</code> למשל בפונקציה <code>__d_alloc</code>.</p>
</li>
<li>
<p>לאחר מכן בודקים שה-<code>parent</code> הוא אותו אחד כמו שאנחנו צריכים ובודקים אם ה-<code>dentry</code> הנוכחי עדיין <code>hashed</code> כלומר נמצא ב-hash table, וצריך ולוודא את זה בגלל שאין נעילה.</p>
</li>
<li>
<p>לאחר מכן בודקים אם קיים מימוש של <code>d_compare</code> איחודי שה-<code>dentry</code> הזה דורש (הבדיקה היא על ידי הדגל <code>DCACHE_OP_COMPARE</code>), ואם כן אז צריך לעשות מספר פעולות כדי להשתמש בו, ואם לא אז יש מקרה פשוט יותר.
אם הדגל <code>DCACHE_OP_COMPARE</code> דלוק אז ממשיכים בתת הסעיפים האלו (2.3) ואם לא אז ממשיכים לסעיף 2.4:</p>
<ol>
<li>משווים את ה-hash של ה-<code>dentry</code> עם היעד, ואם הם שונים אז ממשיכים בלולאה ל-<code>dentry</code> הבא ב-<code>bucket</code>. (שימו לב שבודקים את ה-hash למרות שאנחנו הגענו אליו דרך ה-bucket, כלומר צריך להיות להם אותו hash אבל בגלל שאין נעילה אז הבדיקה מוודאת שלא היה שינוי).</li>
<li>בודקים האם היה שינוי ב-<code>d_seq</code> שנדגם בשלב 2.1, ואם כן אז חוזרים אליו לאחר הפסקה קצרה שנעשית עם <code>cpu_relax</code> כדי לתת ל-task שעורך את ה-<code>dentry</code>  זמן לסיים את השינוי.</li>
<li>ועכשיו אפשר להשוואת את ה-<code>dentry</code> הנוכחי עם ה-<code>d_compare</code> שלו, ואם הוא מתאים אז מצאנו את היעד שלנו ואפשר להמשיך לסיום הפונקציה בשלב 2.5.</li>
</ol>
</li>
<li>
<p>אם הגענו לכאן אז אנחנו משתמשים בהשוואה הרגילה של ה-<code>dentries</code> שהיא <code>dentry_cmp</code> אבל לפני זה בודקים שה-hash של ה-<code>dentry</code> הנוכחי זהה ל-hash של היעד שלנו. לאחר מכן אם ה-hash-ים שווים וה-<code>dentry_cmp</code> מחזיר הצלחה אז מצאנו את היעד שלנו ואפשר להתקדם לסיום הפונקציה, ואם לא מצאנו ממשיכים בלולאה.</p>
</li>
<li>
<p>רגע לפני שהפונקציה מסתיימת צריך לתת אפשרות ל-caller לזהות אם היה שינוי בין היעד שהוא מחפש ליעד שמצאנו, ולכן מחזירים לו גם את הדגימה של <code>d_seq</code> שעשינו בשלב 2.1 ועכשיו אפשר להחזיר לו את מה שמצאנו לסיים את הפונקציה.</p>
</li>
</ol>
</li>
<li>אם הגענו לכאן אז זה אומר שעברנו על כל הערכים ב-bucket ולא מצאנו התאמה, ולכן אפשר לסיים את הפונקציה עם החזרת <code>NULL</code>.</li>
</ol>
<h2 id="הפונקציה-d_walk">
  הפונקציה <code>d_walk</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_walk">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">  1</span><span class="cl">
</span></span><span class="line"><span class="ln">  2</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">d_walk</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">  3</span><span class="cl">		   <span class="k">enum</span> <span class="nf">d_walk_ret</span> <span class="p">(</span><span class="o">*</span><span class="n">enter</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">  4</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">  5</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">this_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  6</span><span class="cl">	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  7</span><span class="cl">	<span class="kt">unsigned</span> <span class="n">seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  8</span><span class="cl">	<span class="k">enum</span> <span class="n">d_walk_ret</span> <span class="n">ret</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">  9</span><span class="cl">	<span class="kt">bool</span> <span class="n">retry</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 10</span><span class="cl">
</span></span><span class="line"><span class="ln"> 11</span><span class="cl"><span class="nl">again</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 12</span><span class="cl">	<span class="nf">read_seqbegin_or_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 13</span><span class="cl">	<span class="n">this_parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 14</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 15</span><span class="cl">
</span></span><span class="line"><span class="ln"> 16</span><span class="cl">	<span class="n">ret</span> <span class="o">=</span> <span class="nf">enter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">this_parent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 17</span><span class="cl">	<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 18</span><span class="cl">	<span class="k">case</span> <span class="nl">D_WALK_CONTINUE</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 19</span><span class="cl">		<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 20</span><span class="cl">	<span class="k">case</span> <span class="nl">D_WALK_QUIT</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 21</span><span class="cl">	<span class="k">case</span> <span class="nl">D_WALK_SKIP</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 22</span><span class="cl">		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 23</span><span class="cl">	<span class="k">case</span> <span class="nl">D_WALK_NORETRY</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 24</span><span class="cl">		<span class="n">retry</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 25</span><span class="cl">		<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 26</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 27</span><span class="cl"><span class="nl">repeat</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 28</span><span class="cl">	<span class="n">next</span> <span class="o">=</span> <span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 29</span><span class="cl"><span class="nl">resume</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 30</span><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 31</span><span class="cl">		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 32</span><span class="cl">		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="nf">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_child</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 33</span><span class="cl">		<span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 34</span><span class="cl">
</span></span><span class="line"><span class="ln"> 35</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DENTRY_CURSOR</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 36</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 37</span><span class="cl">
</span></span><span class="line"><span class="ln"> 38</span><span class="cl">		<span class="nf">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 39</span><span class="cl">
</span></span><span class="line"><span class="ln"> 40</span><span class="cl">		<span class="n">ret</span> <span class="o">=</span> <span class="nf">enter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 41</span><span class="cl">		<span class="k">switch</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 42</span><span class="cl">		<span class="k">case</span> <span class="nl">D_WALK_CONTINUE</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 43</span><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 44</span><span class="cl">		<span class="k">case</span> <span class="nl">D_WALK_QUIT</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 45</span><span class="cl">			<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 46</span><span class="cl">			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 47</span><span class="cl">		<span class="k">case</span> <span class="nl">D_WALK_NORETRY</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 48</span><span class="cl">			<span class="n">retry</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 49</span><span class="cl">			<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 50</span><span class="cl">		<span class="k">case</span> <span class="nl">D_WALK_SKIP</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 51</span><span class="cl">			<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 52</span><span class="cl">			<span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 53</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 54</span><span class="cl">
</span></span><span class="line"><span class="ln"> 55</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 56</span><span class="cl">			<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 57</span><span class="cl">			<span class="nf">spin_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 58</span><span class="cl">			<span class="n">this_parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 59</span><span class="cl">			<span class="nf">spin_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">.</span><span class="n">dep_map</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_RET_IP_</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 60</span><span class="cl">			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 61</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 62</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 63</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 64</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 65</span><span class="cl"><span class="cm">	 * All done at this level ... ascend and resume the search.
</span></span></span><span class="line"><span class="ln"> 66</span><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="ln"> 67</span><span class="cl">	<span class="nf">rcu_read_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 68</span><span class="cl"><span class="nl">ascend</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 69</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">this_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 70</span><span class="cl">		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="n">this_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 71</span><span class="cl">		<span class="n">this_parent</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 72</span><span class="cl">
</span></span><span class="line"><span class="ln"> 73</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 74</span><span class="cl">		<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 75</span><span class="cl">
</span></span><span class="line"><span class="ln"> 76</span><span class="cl">		<span class="cm">/* might go back up the wrong parent if we have had a rename. */</span>
</span></span><span class="line"><span class="ln"> 77</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">need_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 78</span><span class="cl">			<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 79</span><span class="cl">		<span class="cm">/* go into the first sibling still alive */</span>
</span></span><span class="line"><span class="ln"> 80</span><span class="cl">		<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 81</span><span class="cl">			<span class="n">next</span> <span class="o">=</span> <span class="n">child</span><span class="o">-&gt;</span><span class="n">d_child</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 82</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_subdirs</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 83</span><span class="cl">				<span class="k">goto</span> <span class="n">ascend</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 84</span><span class="cl">			<span class="n">child</span> <span class="o">=</span> <span class="nf">list_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">d_child</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 85</span><span class="cl">		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_DENTRY_KILLED</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 86</span><span class="cl">		<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 87</span><span class="cl">		<span class="k">goto</span> <span class="n">resume</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 88</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln"> 89</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">need_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 90</span><span class="cl">		<span class="k">goto</span> <span class="n">rename_retry</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 91</span><span class="cl">	<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 92</span><span class="cl">
</span></span><span class="line"><span class="ln"> 93</span><span class="cl"><span class="nl">out_unlock</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 94</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 95</span><span class="cl">	<span class="nf">done_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 96</span><span class="cl">	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 97</span><span class="cl">
</span></span><span class="line"><span class="ln"> 98</span><span class="cl"><span class="nl">rename_retry</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 99</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">100</span><span class="cl">	<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">101</span><span class="cl">	<span class="nf">BUG_ON</span><span class="p">(</span><span class="n">seq</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">102</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">103</span><span class="cl">		<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">104</span><span class="cl">	<span class="n">seq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">105</span><span class="cl">	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">106</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>המטרה של הפונקציה היא הליכה בעץ ה-dentry, כלומר הפונקציה מקבלת פרמטר <code>parent</code> וסורקת ממנו את כל הבנים שלו בצורה רקורסיבית, ומפעילה את הפונקצית callback שמתקבלת כפרמטר <code>enter</code> והיא פועלת על כל dentry שנסרק.</p>
<p>הפרמטר <code>data</code>:
הוא פרמטר שמועבר ל-<code>enter</code>.</p>
<p>הפרמטר <code>enter</code>:
<code>enum d_walk_ret (*enter)(void *, struct dentry *)</code>
הפרמטר הוא פונקצית callback שמקבלת מצביע לנתונים כלליים ו-dentry שנסרק, והיא צריכה להחזיר ערך מתוך <code>d_walk_ret</code> שהוא <code>enum</code> שנראה כך:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">enum</span> <span class="n">d_walk_ret</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">	<span class="n">D_WALK_CONTINUE</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="n">D_WALK_QUIT</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="n">D_WALK_NORETRY</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="n">D_WALK_SKIP</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><ul>
<li>הערך <code>D_WALK_CONTINUE</code> - להמשיך בסריקה.</li>
<li>הערך <code>D_WALK_QUIT</code> - לעצור את הסריקה.</li>
<li>הערך <code>D_WALK_NORETRY</code> - יש פעמים שמנסים שוב פעם אם קורה משהו, ובמקרה והערך הזה חוזר אז לא נעשה ניסיון חוזר.</li>
<li>הערך <code>D_WALK_SKIP</code> -לדלג על הסריקה הנוכחית  (בגלל שזה רקורסיבי אז הדילוג נעשה גם הל הילדים של ה-dentry הנוכחי).</li>
</ul>
<p>כשאנחנו עוברים על העץ צריך להיזהר, לרוב מעבר על עצים נעשה בצורה רקורסיבית רגילה (כלומר קריאה לפונקציה מתוך עצמה עם תנאי עצירה) אבל במקרה שלנו אנחנו צריכים לעשות בזהירות רקורסיה ולכן היא נעשית ביד, מכיוון שאיננו רוצים להיות תלויים במהדר כדי שתמיד יצליח (gcc בדרך כלל לא). רקורסיה אמיתית תאכל את שטח ה-stack שלנו ולכן אנחנו נמנעים מכן ועושים רקורסיה בעזרת לולאה, ובנוסף אנחנו צריכים לעשות את הרקורסיה בדרך הזאת בגלל שצריך לטפל בנעילות ובמצבים שיכול להיות שבטיפוס במעלה העץ בחזרה, היו שינויים בעץ וחלק מה-denties כבר מתים (אבל לא משוחררים בגלל שיש את נעילת ה-rcu), בגלל שצריך להחזיק כל הזמן רק מעט נעילות כי אי אפשר לנעול את כל העץ ולשחרר אותם רק בסיום הסריקה.</p>
<ol>
<li>התחלת הפונקציה מסומנת על ידי ה-label שנקרא <code>again</code> והוא משמש לסריקות חוזרות במקרה של בעיות. כאן הסריקה מתחילה, והפונקציה דוגמת את המנעול <code>rename_lock</code> על ידי הפונקציה <code>read_seqbegin_or_lock</code> כדי לוודא שאם יש rename אז היא מודעת לזה והיא יכולה לנסות עוד פעם כדי למנוע בעיות. מעכשיו המשתנה המקומי <code>this_parent</code> משמש כדי לגשת לאב של ה-dentry שאותו אנחנו סורקים, חוץ מהסריקה הראשונה שבה סורקים אותו, ובנוסף לזה נועלים את ה-<code>d_lock</code> של <code>this_parent</code> על מנת לוודא שהוא לא ישתנה בכלל מהרגע שמתחילים לעבוד איתו.</li>
<li>הסריקה הראשונה מתחילה כשיש קריאה ל-<code>enter</code> עם <code>this_parent</code> ולאחר מכן הערך חזרה נכנס ל-<code>ret</code>, יש בדיקה של <code>ret</code> ואם הוא <code>D_WALK_CONTINUE</code> אז ממשיכים בסריקה כרגיל, אם <code>ret</code> הוא <code>D_WALK_QUIT</code> או <code>D_WALK_SKIP</code> אז מסיימים את הסריקה (לגבי <code>D_WALK_QUIT</code> זה ברור כי זה המהות שלו, אבל <code>D_WALK_SKIP</code> במקרה הזה גם עושה את אותו הדבר בגלל שזה ה-dentry הראשון לסריקה ועדיין אין dentries אחרים לסרוק בהמשך, אז אם מדלגים עליו אז מגיעים לסוף הסריקה). ובמקרה ש-<code>ret</code> הוא <code>D_WALK_NORETRY</code> אז פשוט מכבים את הדגל של <code>retry</code> (משתנה מקומי בוליאני).</li>
<li>לאחר מכן מגיעים לשלב של סריקת הבנים של ה-<code>this_parent</code> הנוכחי, הלוגיקה של סריקת הבנים מתחילה ב-label שנקרא <code>repeat</code>, ולאחריו יש עוד label שנקרא <code>resume</code> שהוא אחרי על סריקה חוזרת של אותו בן שנבדק, וב-<code>repeat</code> לוקחים את הבן הבא של <code>this_parent</code>.</li>
<li>עכשיו מתחיל הלולאה שסורקת את הבנים של ה-<code>this_parent</code>, על ידי <code>d_subdirs</code> שמחזיק רשימה של הבנים של ה-dentry, ועל כל בן של <code>this_parent</code> נעשות הפעולות הבאות:
<ol>
<li>הבן נכנס לתוך המשתנה המוקמי <code>dentry</code> וצריך לבדוק שהוא באמת ערך תקין והוא לא סתם סמן עזר, ניתן לזהות את זה על ידי הדגל <code>DCACHE_DENTRY_CURSOR</code> (סמני עזר משומשים על ידי ה-<code>ramfs</code> כדי לקרוא תיקיות).</li>
<li>לאחר מכן נועלים את ה-<code>d_lock</code> של <code>dentry</code> בעזרת <code>spin_lock_nested</code>. יש צורך בנעילה מהסוג הזה (עם nested) שמשתמשת את המערכת <code>lockdep</code>, משתמשים כאן ב-nested בגלל שכבר מוחזק לפני כן אותה הנעילה על האבא שלו (<code>this_parent</code>)  עם אותו lock-class וזה יהיה מזוהה כבעיה על ידי ה-<code>lockdep</code> בגלל שזה לא נראה תקין, אבל זה כן תקין כדי לעשות רצף &ldquo;יד על היד&rdquo; (hand-over-hand) כדי לוודא שכל הזמן כל הנעילות נעשות בצורה בטוחה. (גם מוזכר <a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#struct-path-root"  class="external-link" target="_blank" rel="noopener">במאמר הזה-</a>)</li>
<li>בשלב הזה מריצים את <code>enter</code> עם ה-<code>dentry</code> והערך חזרה נכנס ל-<code>ret</code> ונבדק כמו קודם, אבל עם הבדלים קטנים: אם חוזר <code>D_WALK_QUIT</code> אז דבר ראשון משחררים את הנעילה על <code>dentry</code> ואז מסיימים את הסריקה על ידי קפיצה ל-<code>out_unlock</code>, ואם מקבלים <code>D_WALK_SKIP</code> אז רק מדלגים על ה-dentry הנוכחי וממשיכים בסריקה של יתר הבנים של <code>this_parent</code>.</li>
<li>לאחר מכן אם ממשיכים בפלאו של הלולאה ולא היינו צריכים לצאת ממנה, אז בודקים אם יש ל-<code>dentry</code> ילדים, ואם כן אז עכשיו צריך לסרוק אותם, עד שמגיעים ל-dentry הכי עמוק ושמאלי בעץ. אבל רגע לפני שעושים את הסריקה הזאת משחררים את המנעולים: פותחים את הנעילה <code>d_lock</code> של האב (בגלל שעכשיו צריך לשנות את האבא אז לא צריך להחזיק את הנעילה) וגם משנים את הנעילה במנעול <code>d_lock</code> של <code>dentry</code> בגלל שעכשיו הוא צריך לשנות את ה-lock-class שלו כי הוא היחס משתנה והוא הופך להיות האבא.  ולאחר שהכל עודכן אז אפשר לסרוק את הילדים שלו, וקופצים לקטע <code>repeat</code> שסורק אותם שכבר דברתי עליו בשלב <code>3</code>.</li>
<li>אם אין יותר ילדים ל-<code>this_parent</code> סיימנו לסרוק את ה-level הנוכחי, ועכשיו צריך להתחיל לטפס במעלה העץ בחזרה לאבות הקדמונים עד שמגיעים ל-dentry שממנו התחלנו, ולכן צריך עוד להחזיק את המנעול על <code>this_parent</code> כי צריך לטפס ממנו אבל אין צורך בנעילה של <code>dentry</code> ולכן משחררים אותה ובזה הלולאה מסתיימת.</li>
</ol>
</li>
<li>יצאנו מהלולאה בשלב הזה ועכשיו נועלים את ה-<code>rcu</code> לקריאה עם <code>rcu_read_lock</code> ועכשיו מתחילים לטפס למעלה, וזה מתחיל ב-label שנקרא <code>ascend</code>, כלומר התפקיד של הקטע הזה הוא להעלות במעלה העץ החל מ-<code>this_parent</code>.</li>
<li>לאחר מכן צריך כל פעם לבדוק תנאי עצירה &ldquo;ברקורסיה&rdquo; הזאת שמטפסים למעלה, ובודקים אם ה-<code>this_parent</code> זהה ל-<code>parent</code> כלומר בודקים אם האב הנוכחי הוא ה-dentry שממנו התחלנו את הסריקה, ואם לא אז ממשיכים בטיפוס.</li>
<li>בשלב הזה מחליפים את היחס של <code>this_parent</code>, ה-dentry שאליו המשתנה הצביע הופך לבן, והוא נמצא במשתנה המקומי <code>child</code> ו-<code>this_parent</code> הופך להיות האבא של <code>child</code> (כלומר טיפסנו במעלה העץ), וכמובן שצריך לדאוג לנעילה ולכן משחררים את הנעילה של <code>child</code> כי אין צורך בה יותר, כי עכשיו לא משנה לנו אם הוא משתנה, רק משנה לנו שהוא לא משתחרר וזה מובטח בזכות נעילת ה-<code>rcu</code>, וגם צריך עכשיו לקחת את הנעילה של האבא החדש <code>this_parent</code> כי בו נעשה שימוש בטיפוס.</li>
<li>לאחר מכן צריך לבדוק שלא נעשה <code>rename</code>, ולכן בודקים את ה-<code>rename_lock</code> עם <code>seq</code> שנדגם קודם לכן, ואם היה שינוי אז זה בעייתי כי יכול להיות שאחנו מטפסים על האב הלא נכון, ואם היה <code>rename</code> אז קופצים לטיפול שלו ב-label שנקרא <code>rename_retry</code>, הוא פותח את הנעילה שלנו על <code>this_parent</code>, גם צריך לסגור את הקטע הקריטי של ה-<code>rcu</code>, אם הדגל <code>retry</code> כבוי אז כאן מסיימת הסריקה, ואם הדגל הוא <code>true</code> אז קופצים ל-<code>again</code>.</li>
<li>בשלב הזה צריך לאחר שעלינו לאבא לרדת בחזרה לבנים שלו ולעבור על האחים של ה-<code>dentry</code> הנוכחי שנסרק, ולכן עוברים על הרשימת אחים <code>d_subdirs</code> של <code>child</code> ומחפשים שם אחים שלו שעוד בחיים (כלומר שהדגל <code>DCACHE_DENTRY_KILLED</code> לא דלוק בהם, ואם הוא כן דלוק אז מדלגים עליהם), לאחר שהגענו לאח בחיים אז קופצים ל-<code>resume</code> שמוסבר בשלב <code>3</code>. אם הגענו לסוף הרשימה ואין יותר אחים אז קופצים ל-<code>ascend</code> שמוסבר בשלב <code>5</code>.</li>
<li>בשלב הזה אנחנו נמצאים במצב שה-<code>this_parent</code> ו-<code>parent</code> זהים, ואפשר לפתוח את הנעילה של <code>this_parent</code> ולסיים את הנעילה של <code>seq</code> וכאן מסתיימת הסריקה וההליכה בעץ.</li>
</ol>
<h1 id="ניהול-dentry-cache">
  ניהול dentry cache
  <a class="heading-link" href="#%d7%a0%d7%99%d7%94%d7%95%d7%9c-dentry-cache">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<h2 id="הפונקציה-d_rehash">
  הפונקציה <code>d_rehash</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-d_rehash">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="kt">void</span> <span class="nf">d_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">entry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">	<span class="nf">__d_rehash</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>מטרת הפונקציה היא לעשות מחדש את תהליך הכנסת ה-dentry שמתקבל כפרמטר לטבלת hash.
כמו שאפשר לראות הפונקציה <code>d_rehash</code> היא פשוט מעטפת של נעילת ה-spinlock של ה-dentry לפונקציה <code>__d_rehash</code> שבאמת עושה את התהליך.</p>
<h3 id="הפונקציה-__d_rehash">
  הפונקציה <code>__d_rehash</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__d_rehash">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln">1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__d_rehash</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">	<span class="k">struct</span> <span class="n">hlist_bl_head</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="nf">d_hash</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">	<span class="nf">hlist_bl_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">	<span class="nf">hlist_bl_add_head_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_hash</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">7</span><span class="cl">	<span class="nf">hlist_bl_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">8</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>מטרת הפונקציה היא לעשות מחדש את תהליך הכנסת ה-dentry שמתקבל כפרמטר לטבלת hash, הפונקציה מניחה שהמנעול <code>d_lock</code> נעול.</p>
<p>הפונקציה מקבלת את הפרמטר <code>entry</code> שהוא dentry שצריך לעבור hash מחדש.</p>
<p>הפונקציה מאוד פשוטה כמו שאפשר לראות, היא מחפשת את ה-bucket יעד שצריך להיות ל-<code>entry</code> על ידי החיפוש עם <code>d_hash</code>.
לאחר מכן כשהיא מצאה את ה-bucket הנכון היא נועלת את ה-bucket בגלל שהפונקציה צריכה לערוך אותו, ומוסיפה את <code>entry</code> לרשימה של ה-bucket על ידי הפונקציה <code>hlist_bl_add_head_rcu</code> וזה נעשה עם rcu.
לבסוף לאחר ההוספה הפונקציה פותחת את הנעילה של ה-bucket וכאן הפונציקה מסתיימת.</p>
<h2 id="הפונקציה-dentry_kill">
  הפונקציה <code>dentry_kill</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-dentry_kill">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">dentry_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	<span class="nf">__releases</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="nf">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="k">goto</span> <span class="n">slow_positive</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">		<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="o">!</span><span class="nf">spin_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">			<span class="n">parent</span> <span class="o">=</span> <span class="nf">__lock_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="n">inode</span> <span class="o">||</span> <span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">				<span class="k">goto</span> <span class="n">got_locks</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">			<span class="cm">/* negative that became positive */</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">				<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">			<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">			<span class="k">goto</span> <span class="n">slow_positive</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">	<span class="nf">__dentry_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">	<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="nl">slow_positive</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">	<span class="n">parent</span> <span class="o">=</span> <span class="nf">lock_parent</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="nl">got_locks</span><span class="p">:</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">.</span><span class="n">count</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="o">!</span><span class="nf">retain_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">		<span class="nf">__dentry_kill</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">		<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">	<span class="cm">/* we are keeping it, after all */</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפרמטר שמקבלים הוא ה-<code>dentry</code> שאותו רוצים להרוג, הוא צריך להגיע מראש עם <code>d_lock</code> נעול על ידי ה-caller.</p>
<p>רגע לפני שהפונקציה מתחילה יש כאן את ההצרה <code>__releases</code> לשם התיעוד שאומרת לנו שהפונקציה אחראית בעצמה לשחרר את ה-<code>d_lock</code>.</p>
<ol>
<li>הפונקציה נפתחת עם העתקה של ה-<code>d_inode</code> בגלל שגם ה-<code>inode</code> צריך להיות נעול כי גם הוא צריך לעבור ניתוק מה-<code>dentry</code>.</li>
<li>אם ה-<code>dentry</code> חיובי (כלומר יש לו <code>inode</code> אז יש ניסיון לנעול את <code>i_lock</code> של ה-<code>inode</code> של ה-<code>dentry</code> בצורה מהירה ללא המתנה עם <code>spin_trylock</code>. אם הנעילה מצליחה ממשיכים ואם לא אז מנסים לנעול בצורה איטית יותר וקופצים ל-label בשם <code>slow_positive</code> שמתואר בשלב 5. שימו לב יש כאן משהו מוזר קצת, אם קראתם את התיעוד של תחילת הקובץ אפשר לראות שהסדר של הנעילות צריך להיות קודם <code>i_inode</code> ורק אחריו <code>d_lock</code> וכאן עושים הפוך, זה יכל ליצור בעיה אבל יש כאן שימוש ב-<code>spin_trylock</code> שהיא גרסה שלא ממתינה ובגלל זה אפשר להפר את הסדר שצריך להתקיים בנעילה.</li>
<li>בחלק הזה מנסים לנעול את ה-<code>dentry</code> אב, אבל לפני כן בודקים אם ה-<code>dentry</code> הוא root ואם כן אין צורך לנעול את האב וממשיכים לשלב 4 ואם הוא לא root אז ממשיכים ל-3.1
<ol>
<li>מנסים לנעול את האב על ידי הגישה המהירה ואם מצליחים ממשיכים לשלב 4 אחרת ממשיכים לשלב 3.2</li>
<li>מנסים לנעול הפעם בצורה איטית יותר עם <code>__lock_parent</code> שנועל בצורה בטוחה את האב</li>
<li>אם ה-<code>dentry</code> היה שלילי ואז חיובי אז ממשיכים, לשלב הבא אחרת מנסים לקבל נעילות מתאימות שמתואר בשלב 6.</li>
<li>בשלב הזה בודקים אם יש <code>dentry</code> אב ואם כן אז משחררים אותו ולאחר מכן קופצים ל-<code>slow_positive</code> שמתואר בשלב 5.</li>
</ol>
</li>
<li>עכשיו הגיע הזמן באמת להרוג את ה-<code>dentry</code> על ידי <code>__dentry_kill</code> ולאחר מכן מחזירים את ה-<code>dentry</code> אב.</li>
<li>השלב הזה מתאר את ה-label בשם <code>slow_positive</code>, המטרה של הקטע הזה היא לנעול את המשאבים שלנו בצורה נכונה בגלל שלא הצלחנו לנעול אותם בצורה המהירה, ולכן דבר ראשון משחררים את ה-<code>d_lock</code> של ה-<code>dentry</code> שרוצים להרוג, ולאחר מכן ממשיכים ונועלים לפי הסדר את ה-<code>i_inode</code> לאחר מכן את ה-<code>d_lock</code> שלנו ולאחר מכן את האבא (הסדר של נעילת האבא אפשרי כי הוא מטופל על ידי <code>lock_parent</code> שהיא עטיפה קטנה ל-<code>__lock_parent</code> שהוא מתואר במאמר הזה והוא דואג לנעול את האבא בצורה נכונה).</li>
<li>לאחר מכן מגיעים לקטע <code>got_locks</code> שבו בודקים אם אפשר להרוג את ה-<code>dentry</code> (אם אנחנו היחידים שמחזיקים בו) אם אי אפשר להרוג אותו עדיין אז פשוט מקטינים את המונה של <code>lockref</code> ב-1 וממשיכים לסיום הפונקציה ללא הרג (שלב 9)</li>
<li>אם אנחנו היחידים עם בעלות על ה-<code>dentry</code> אז בודקים בעזרת <code>retain_dentry</code> אם צריך לשמור את ה-<code>dentry</code> ואסור להרוג אותו כרגע ואם כן אז ממשיכים לסיום הפונקציה ללא הרג. (שלב 9).</li>
<li>אם הגענו עד לכאן אז אפשר להרוג אותו על ידי הפונקציה <code>__dentry_kill</code> וכאן המשימה שלנו מסתיימת.</li>
<li>אם הגענו לכאן אז כנראה לא הצלחנו להרוג את ה-<code>dentry</code> אז צריך לסיים את הפונקציה ולהוריד את הנעילות בסדר הנכון ולאחר מכן מחזירים <code>NULL</code>.</li>
</ol>
<h3 id="הפונקציה-__dentry_kill">
  הפונקציה <code>__dentry_kill</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__dentry_kill">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">__dentry_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="kt">bool</span> <span class="n">can_free</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="cm">	 * The dentry is now unrecoverably dead to the world.
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">lockref_mark_dead</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lockref</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="cm">	 * inform the fs via d_prune that this dentry is about to be
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="cm">	 * unhashed and destroyed.
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_OP_PRUNE</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="nf">d_prune</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_LRU_LIST</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_SHRINK_LIST</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">			<span class="nf">d_lru_del</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">	<span class="cm">/* if it was on the hash then remove it */</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">	<span class="nf">__d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">	<span class="nf">dentry_unlist</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">		<span class="nf">dentry_unlink_inode</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">	<span class="nf">this_cpu_dec</span><span class="p">(</span><span class="n">nr_dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_release</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="nf">d_release</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_SHRINK_LIST</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_MAY_FREE</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">		<span class="n">can_free</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">43</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">likely</span><span class="p">(</span><span class="n">can_free</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">		<span class="nf">dentry_free</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">	<span class="nf">cond_resched</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מקבלת כפרמטר <code>dentry</code> והמטרה של הפונקציה היא להרוג סופית את ה-<code>dentry</code> הזה.</p>
<p>בתחילה בודקים אם ה</p>
<h3 id="הפונקציה-__lock_parent">
  הפונקציה <code>__lock_parent</code>
  <a class="heading-link" href="#%d7%94%d7%a4%d7%95%d7%a0%d7%a7%d7%a6%d7%99%d7%94-__lock_parent">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">__lock_parent</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="nf">rcu_read_lock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">	<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="nl">again</span><span class="p">:</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">	<span class="n">parent</span> <span class="o">=</span> <span class="nf">READ_ONCE</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	<span class="nf">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">	<span class="cm">/*
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="cm">	 * We can&#39;t blindly lock dentry until we are sure
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="cm">	 * that we won&#39;t violate the locking order.
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="cm">	 * Any changes of dentry-&gt;d_parent must have
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="cm">	 * been done with parent-&gt;d_lock held, so
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="cm">	 * spin_lock() above is enough of a barrier
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="cm">	 * for checking if it&#39;s still our child.
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="cm">	 */</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">		<span class="nf">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">	<span class="nf">rcu_read_unlock</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">dentry</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">		<span class="nf">spin_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">,</span> <span class="n">DENTRY_D_LOCK_NESTED</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">		<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">	<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה מקבלת כפרמטר <code>dentry</code> שה-<code>d_lock</code> שלו חייב להיות נעול כבר על ידי ה-caller.
המטרה של הפונקציה היא לנעול את ה-<code>dentry</code> אב של ה-<code>dentry</code> שמקבלים כפרמטר.
הפונקציה עושה את זה בזהירות כדי לא לשבור את הסדר של הנעילה ולגרום למצב של בעיות נעילה כמו deadlock, הדרך שהיא עושה את זה זה מעבר &ldquo;יד על יד&rdquo; (hand over hand) כדי לוודא שהכל נעשה בצורה נכונה.</p>
<ol>
<li>בתחילת הפונקציה היא פותחת בקטע קריטי של <code>rcu</code> וככה היא מממשת את היד על יד.</li>
<li>לאחר מכן משחררים את הנעילת <code>d_lock</code> של ה-<code>dentry</code> כדי לתפוס בסדר הנכון את הנעילה (הסדר הוא לנעול את האב ולאחר מכן את הבן).</li>
<li>עכשיו מתחיל הקטע שבו מנסים להשיג את הנעילה של האבא שהקטע מסומן על ידי label בשם <code>again</code>.</li>
<li>מעתיקים את המצביע ל-<code>d_parent</code> על ידי <code>READ_ONCE</code> בגלל שזה נעשה ללא נעילה יכול להיות שינויים, אז צריך קריאה עם <code>READ_ONCE</code> כדי להבטיח שאנחנו נראה את הערך העדכני במקרה שמישהו אחר שינה את האבא.</li>
<li>לאחר מכן נועלים את ה-<code>d_lock</code> של האבא עם <code>spin_lock</code>.</li>
<li>לאחר שנעלנו צריך לוודא שבזמן שחיכינו לנעילה לא התרחש שינוי וצריך לבדוק אם ה-<code>d_parent</code> של ה-<code>dentry</code> שקיבלנו כפרמטר הוא זה שנעלנו. בנוסף הנעילה של אבא היא גם נעילה של השדה <code>d_parent</code> אצל הבן בגלל שבזמן שינוי של האב גם צריך לעדכן את ה-<code>dentry</code> אב, ואם הוא נעול אז זה נותן חסימה מספיקה כדי לבדוק אם זה עדיין הילד שלנו.</li>
<li>אם היה שינוי ולא נעלנו את ה-<code>dentry</code> אב הנכון אז משחררים את הנעילה וחוזרים לשלב 3, ואם נעלנו את הנכון אז אפשר להמשיך.</li>
<li>לאחר מכן יש לנו נעילה על האבא ועכשיו רק צריך לנעול את הבן, וכמו שהוסבר קודם בשלב 6 יש לנו כרגע נעילה על האבא שהיא מספיקה כדי לאפשר לנו להגיע לבן ולכן אפשר לשחרר את מנעול ה-<code>rcu</code> בשלב הזה.</li>
<li>לאחר מכן צריך לבדוק שה-<code>dentry</code> אב ובן הם לא אותו אחד, ואם הם כן אז הוא כבר נעול ואין לנו יותר מה לעשות ומחזירים <code>NULL</code>. במקרה והם שונים אז צריך לנעול עכשיו את הבן וזה נעשה על ידי <code>spin_lock_nested</code> כדי לאפשר ל-<code>lockdep</code> לבדוק שאין בעיות אם הוא מופעל. ולאחר מכן הפונקציה מסתיימת ומחזירים מצביע אל האבא כשהוא מוחזק עם נעילה.</li>
</ol>
<hr>
<h3 id="d_lookup_done">
  <code>d_lookup_done</code>
  <a class="heading-link" href="#d_lookup_done">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>הפונקציה <code>d_lookup_done</code> - אומרת למערכת שסיימנו עם חיפוש ואם הוא עדיין מסומן כ-in-lookup, זה אמור להפסיק להיות כזה.</p>

            
          
            <h2 id="bit-spinlock">
  bit spinlock
  <a class="heading-link" href="#bit-spinlock">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<ul>
<li>הוא מנעול קטן ומהיר וצריך להשתמש בו רק כשיש משהו באמת שצריך לעשות במהירות מאוד מהירה.</li>
<li>המנעול משתמש במשתנה שאותו רוצים לנעול, הוא לא צריך מבנה נתונים משלו לצורך הנעילה,  (בניגוד ל-spinlock רגיל שצורך struct משלו).</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">bit_spin_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">bitnum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">	<span class="p">{</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">	<span class="nf">pt_disable</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">	<span class="k">while</span> <span class="p">(</span><span class="nf">unlikely</span><span class="p">(</span><span class="nf">test_and_set_bit_lock</span><span class="p">(</span><span class="n">bitnum</span><span class="p">,</span> <span class="n">addr</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">		<span class="nf">preempt_enable</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">		<span class="k">do</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">			<span class="nf">cpu_relax</span><span class="p">();</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nf">test_bit</span><span class="p">(</span><span class="n">bitnum</span><span class="p">,</span> <span class="n">addr</span><span class="p">));</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">		<span class="nf">preempt_disable</span><span class="p">();</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">	<span class="nf">__acquire</span><span class="p">(</span><span class="n">bitlock</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>הפונקציה <code>bit_spin_lock</code> נועלת את המנעול עם לולאת סרק (idle), היא עושה את זה על ידי הדלקת ביט הנעילה (<code>bitnum</code>) בכתובת <code>addr</code>. אם המנעול לא בשימוש (הביט כבוי) אז לא נכנסים לתוך הלולאה בכלל ומסתיימת הפונקציה.
אם המנעול נעול אז יש בדיקה לא אטומית <code>test_bit</code> לנעילה, זה נעשה לא אטומי כדי להקטין את הריבים (contention) על ה-bus.</p>

            
          
            <h2 id="שימוש-של-bl_hlist-עם-hash-table">
  שימוש של bl_hlist עם hash-table
  <a class="heading-link" href="#%d7%a9%d7%99%d7%9e%d7%95%d7%a9-%d7%a9%d7%9c-bl_hlist-%d7%a2%d7%9d-hash-table">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>הוא גרסה מיוחדת של רשימה, שבה ל-head של הרשימה יש נעילה בביט במיקום אפס. זה שימושי עבור טבלאות Hash הניתנות להרחבה מבלי להגדיל את טביעת הרגל של הזיכרון.</p>
<p>ה-<code>bl_hlist</code> הוא <code>hlist</code> (כלומר <code>hash-list</code>) עם נעילת <code>bit_spinlock</code>, (bl - קיצור של bit-lock).</p>
<p>רשימת ה-Hash של bit lock הנה גרסת מימוש רשימת hash בקרנל.</p>
<p>אין צורך להקצות מנעול לכל רשימת hash, ורק צריך להשתמש ב-bit של מצביע הראש של הרשימה המקושרת כדי לבצע בקרת גישה במקביל כדי לחסוך תקורה בזיכרון. לדוגמה ב-dcach יש שימוש מרכזי בטבלה כזאת.</p>
<h2 id="מימוש-הנעילה-על-bl_hlist">
  מימוש הנעילה על bl_hlist
  <a class="heading-link" href="#%d7%9e%d7%99%d7%9e%d7%95%d7%a9-%d7%94%d7%a0%d7%a2%d7%99%d7%9c%d7%94-%d7%a2%d7%9c-bl_hlist">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>עבור פעולות שינוי, יש להגדיר את הביט ה-0 של המצביע <code>hlist_bl_head-&gt;first</code> .</p>
<p>עם כמה שינויים קטנים, ניתן להתאים את זה בקלות לאחסון כמה ביטים שרירותיים (לא רק סיביות נעילה בודדות), אם מתעורר צורך לאחסן כמה נתוני עזר מהירים וקומפקטיים.</p>
<p>הרבה מאוד דברים משותפים ל-hlist_bl ול-hlist רגיל, ולכן לא אסביר כאן את הכל, אלה רק את החלקים השונים.</p>
<p>המצב הנעול של הרשימה הוא כשביט הנעילה של ראש הרשימה דלוק.</p>
<ul>
<li>
<p>הפונקציה <code>hlist_bl_first</code> מקבלת מצביע להתחלה של הרשימה (<code>hlist_bl_head</code>) ותמיד מחזירה אותו כשביט הנעילה כבוי.</p>
</li>
<li>
<p>הפונקציה <code>hlist_bl_set_first</code> מעדכנת את שדה ה-<code>first</code> של ראש הרשימה (<code>hlist_bl_head</code>) ומכניסה את המצביע של <code>first</code> עם ביט הנעילה דלוק.</p>
</li>
</ul>

            
          
            <p>RCU הוא מנגנון מורכב והוא יכול בקלות להיות חומר למספר מאמרים, ולכן אני כרגע אסביר עליו בקצרה (ובתקווה אכתוב עליו מאמר יותר מעמיק בהמשך)</p>
<p>RCU ראשי תיבות של &ldquo;Read-Copy-Update&rdquo;, הוא מנגנון סנכרון המשמש בקרנל לניהול גישה במקביל למבני נתונים ללא צורך במנעולים שעלולים להכניס contention ו-performance bottlenecks.</p>
<p>המנגנון RCU מאפשר ל-thread-ים מרובים לקרוא מבנה נתונים במקביל ללא נעילה, ועדכונים למבנה הנתונים מבוצעים באמצעות מנגנון המבטיח עקביות. RCU מתאים במיוחד לתרחישים שבהם הקריאות תכופות הרבה יותר מאשר כתיבה.</p>
<p>RCU שונה ממנגנוני סינכורון נפוצים, הוא לא דורש אובייקט מנעול למשתמש אלה הוא גלובלי ופועל כלפי כלל המערכת.</p>
<h2 id="צד-קריאה-וצד-וכתיבה">
  צד קריאה וצד וכתיבה
  <a class="heading-link" href="#%d7%a6%d7%93-%d7%a7%d7%a8%d7%99%d7%90%d7%94-%d7%95%d7%a6%d7%93-%d7%95%d7%9b%d7%aa%d7%99%d7%91%d7%94">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>ה-RCU מפשט את הבעיה של סנכון בין מספר גורמים על ידי שהוא עושה מספר חלוקות למקרים:
ב-RCU יש 2 צדדים: הצד הכותב והצד הקורא, הצד הקורא צריך להיות מהיר מאוד (יש מקרים שהוא יכול להיות עם 0 תקורה) והצד הכותב הוא כבר מטפל בכל הבעיות (כמעט) והוא כבר איטי יותר.</p>
<p>הצד הכותב גם בתוכו מחלק את הפעולות שהוא צריך לעשות ל-2 שלבים עקריים:</p>
<ul>
<li>שלב ההסרה (removal): מסיר או מעדכן הפניות לפריטי נתונים בתוך מבנה נתונים.</li>
<li>שלב הטיוב (reclamation): השלב שבו צריך לשחרר את הזיכרון הישן.</li>
</ul>
<p>בצורה הזו ניתן לעשות את שלב ההסרה במקביל לקוראים (המגנון מבטיח שהקוראים יראו זיכרון שלם אבל לא בטוח עדכני - כלומר לא בטוח איזה מידע יגיע לקורא שפועל בזמן העדכון) ורק את שלב השחרור לעשות לאחר שאנחנו בטוחים שכבר אף אחד לא יגש לזיכרון הישן ולכן צריך לחכות שכל הקוראים האפשריים יסימו את הקריאה שלהם.
הרעיון המרכזי ב-RCU הוא שיחרור זיכרון בצורה דחויה.</p>
<p>הזמן בו הכותב מחכה מהרגע שהוא מעדכן את המידע לרגע שהוא יכול לשחרר את המידע הישן נקרא <code>grace period</code> (תקופת חסד) וזה הזמן שבו אנחנו מאפשרים לכל הקוראים לסיים את הגישה לזיכרון הישן ולאחר תקופת החסד ניתן לשחרר את הזיכרון הזה כי מובטח שאין אף אחד שיגש אליו.</p>
<p>המנגנון RCU מבטיח קוהרנטיות לגישות קריאה על ידי שמירה על גרסאות מרובות של מבני נתונים והבטחה שהן לא משוחררות עד להשלמת כל הקטעים הקריטיים הקיימים בצד הקריאה.</p>
<p>המנגנון RCU הוא דרך להמתין עד שקטעים קריטיים בצד הקריאה של RCU יסתיימו לחלוטין, כולל פעולות זיכרון המבוצעות על ידי אותם מקטעים קריטיים.</p>
<p>RCU פועל על פי העיקרון של לאפשר לקוראים להמשיך מבלי לחסום או לרכוש מנעולים, תוך הבטחה שעדכונים מכותבים אינם מציגים חוסר עקביות. זה עושה את זה יעיל במיוחד בתרחישים שבהם יש פעולות קריאה תכופות ופעולות כתיבה נדירות.</p>
<h2 id="תפקידים">
  תפקידים
  <a class="heading-link" href="#%d7%aa%d7%a4%d7%a7%d7%99%d7%93%d7%99%d7%9d">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>קורא (read): קוראים ב-RCU יכולים לגשת בבטחה למבנה הנתונים המשותף מבלי לרכוש מנעולים. הם מסתמכים על העובדה שמבנה הנתונים נשאר יציב לאורך כל הגישה שלהם. עם זאת, חשוב לציין שקוראים עשויים לראות את הגרסה הישנה של הנתונים או את הגרסה המעודכנת החדשה, בהתאם להתקדמות העדכונים.</p>
<p>עדכון (update): כאשר עדכון צריך לשנות את מבנה הנתונים המשותף, הוא יוצר עותק חדש של הנתונים. זה נעשה כדי להבטיח שהקריאה השוטפת תוכל להמשיך ללא הפרעה בגרסה הישנה. לאחר מכן, המעדכן מבצע את השינויים הדרושים בעותק החדש, שהופך לגרסה ה&quot;נוכחית&quot; של מבנה הנתונים לאחר השלמת העדכון.</p>
<p>טיוב (Reclaimer): תפקידו של Reclaimer הוא לשחרר (deallocate) את הגרסה הישנה של מבנה הנתונים ברגע שבטוח שאף קוראים לא ניגשים אליו. RCU מספק מנגנונים כדי להבטיח שכל הקוראים הקיימים השלימו את הגישה שלהם לגרסה הישנה לפני שהיא משוחררת.</p>
<h2 id="ספירת-הפניות">
  ספירת הפניות
  <a class="heading-link" href="#%d7%a1%d7%a4%d7%99%d7%a8%d7%aa-%d7%94%d7%a4%d7%a0%d7%99%d7%95%d7%aa">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>שימוש נפוץ של RCU הוא עם ספירת הפניות, RCU משתמשת לעתים קרובות בטכניקות ספירת הפניות כדי לעקוב אחר השימוש במבנה הנתונים. זה מבטיח שהגרסה הישנה לא תשוחרר בטרם עת בזמן שעדיין יש קוראים שניגשים אליה.
גם באובייקט ה-dentry זאת המטרה של השימוש ב-rcu (יחד עם השדה <code>d_rcu</code>).</p>
<h2 id="מחסומי-זיכרון">
  מחסומי זיכרון
  <a class="heading-link" href="#%d7%9e%d7%97%d7%a1%d7%95%d7%9e%d7%99-%d7%96%d7%99%d7%9b%d7%a8%d7%95%d7%9f">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>מחסומי זיכרון חיוניים ב-RCU מכיוון שהם אוכפים את ערבויות הסנכרון והסידור (memory order) הנדרש. הם מונעים מהקומפיילר,והמעבד לבצע אופטימיזציה או סדר מחדש של פעולות הזיכרון בדרכים שעלולות להוביל להתנהגות לא נכונה או לתצוגות לא עקביות של מבנה הנתונים.</p>
<p>על ידי ניצול יעיל של מחסומי זיכרון, RCU מבטיח שהקוראים יראו תצוגה עקבית של מבנה הנתונים המשותף, או הגרסה הישנה או הגרסה החדשה, בהתאם להתקדמות העדכונים. הוא מאפשר גישת צד קריאה יעילה ולא חוסמת תוך שמירה על תקינות וסנכרון עם עדכוני צד כתיבה בקרנל.</p>
<p>מחסומי זיכרון ב-RCU מספקים ערובות סידור לפעולות זיכרון, מונעות סידור מחדש לא רצוי או אופטימיזציות שעלולות להוביל לתצוגות לא עקביות של מבנה הנתונים המשותף. הם מבטיחים ששינויים שנעשו על ידי כותבים יהיו גלויים לקוראים בסדר הנכון ובזמן המתאים.</p>
<p>חשוב לציין שפונקציות מחסום הזיכרון הספציפיות המשמשות ב-RCU עשויות להשתנות בהתאם לארכיטקטורה ופרטי היישום של קרנל. גרסאות שונות של RCU וחלקים שונים של הקרנל עשויים להשתמש בפונקציות ספציפיות של מחסום זיכרון או בפקודות מאקרו המותאמות לדרישות שלהם.</p>
<h2 id="קטע-קריטי-ב-rcu">
  קטע קריטי ב-RCU
  <a class="heading-link" href="#%d7%a7%d7%98%d7%a2-%d7%a7%d7%a8%d7%99%d7%98%d7%99-%d7%91-rcu">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>קטע קריטי של צד הקריאה מתחיל ב-<code>rcu_read_lock</code> ומסתיים ב-<code>rcu_read_unlock</code> ויכולים להיות מקוננים, הקטע הקריטי בצד הקריאה חייב להיות מאוד מהיר ולכן אסור לעשות פעולות שחוסמות (כמו תזמון מחדש, אבל כן מותר למשל להשתמש ב-spinlock כי גם הוא נועד לשימושים מהירים וקצרים),<br>
אם כי קרנלים שנבנו עם <code>CONFIG_PREEMPT_RCU</code> יכולים להקדים את החלקים הקריטיים בצד הקריאה של RCU. כל מבנה נתונים מוגן RCU שאליו ניגש במהלך קטע קריטי בצד הקריאה של RCU מובטח שיישאר ללא שינוי לכל משך הזמן המלא של אותו קטע קריטי. ניתן להשתמש ב-reference count בשילוב עם RCU כדי לשמור על הפניות לטווח ארוך יותר למבני נתונים.</p>
<p>החזקת הפניה מקטע קריטי בצד הקריאה של ה-RCU למשנהו אינה חוקית באותה מידה כמו החזקת הפניה מקטע קריטי מבוסס מנעול אחד לאחר! באופן דומה, שימוש בהפניה מחוץ לסעיף הקריטי בו הוא נרכש אינו חוקי בדיוק כמו לעשות זאת עם נעילה רגילה.</p>
<h2 id="צד-הכתיבה">
  צד הכתיבה
  <a class="heading-link" href="#%d7%a6%d7%93-%d7%94%d7%9b%d7%aa%d7%99%d7%91%d7%94">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>הפונקציה <code>synchronize_rcu</code> מסמנת את סיומו של קוד המעדכן ותחילתו של קוד reclaimer.
צריך להשתמש ב-<code>synchronize_rcu()</code> כדי להבטיח שכל הקוראים שיש להם הפניות למבנה הישן ישלימו לפני שחרור המבנה הישן.
הפונקציה <code>synchronize_rcu</code> מחכה עד שכל הקטעים הקריטים שהתחילו מלפני הקריאה לפונקציה הסיימו ולכן היא חוסמת ויכולה לגרום לעיכוב בצד העדכון.
אם יש צורך גם בצד כתיבה מהיר ולא חוסם אז ניתן להשתמש ב-callback על ידי הפונקציה <code>call_rcu</code> והפונקצית callback תרוץ בסוף תקופת החסד בצורה אסינכרונית.</p>

            
          
        

      </div>
      <footer>
        
  <h3 dir="rtl">
    מקורות
  </h3>
  <ul dir="ltr">
    
    
      
        
      
    
      
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
      
    
      
        
          
            
          
        
          
            
          
        
          
            
          
        
      
    
      
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
      
    
      
        
          
            
          
        
      
    
      
        
          
            
          
        
          
            
          
        
      
    
      
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
      
    
      
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
      
    
      
        
          
            
          
        
      
    
      
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
      
    
      
        
      
    
      
        
      
    
      
        
      
    
    
      <li>
        <a href="https://en.wikipedia.org/wiki/Slab_allocation">https://en.wikipedia.org/wiki/Slab_allocation</a>
      </li>
    
      <li>
        <a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html">https://www.kernel.org/doc/gorman/html/understand/understand011.html</a>
      </li>
    
      <li>
        <a href="https://www.kernel.org/doc/Documentation/sysctl/vm.txt">https://www.kernel.org/doc/Documentation/sysctl/vm.txt</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/890025/">https://lwn.net/Articles/890025/</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/545119/">https://lwn.net/Articles/545119/</a>
      </li>
    
      <li>
        <a href="https://github.com/torvalds/linux/commit/5160ee6fc891a9ca114be0e90fa6655647bb64b2">https://github.com/torvalds/linux/commit/5160ee6fc891a9ca114be0e90fa6655647bb64b2</a>
      </li>
    
      <li>
        <a href="https://github.com/torvalds/linux/commit/946e51f2bf37f1656916eb75bd0742ba33983c28">https://github.com/torvalds/linux/commit/946e51f2bf37f1656916eb75bd0742ba33983c28</a>
      </li>
    
      <li>
        <a href="https://github.com/torvalds/linux/commit/d9171b9345261e0d941d92fdda5672b5db67f968">https://github.com/torvalds/linux/commit/d9171b9345261e0d941d92fdda5672b5db67f968</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/419811/">https://lwn.net/Articles/419811/</a>
      </li>
    
      <li>
        <a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html">https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html</a>
      </li>
    
      <li>
        <a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#a-walk-among-the-symlinks">https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#a-walk-among-the-symlinks</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/685108/">https://lwn.net/Articles/685108/</a>
      </li>
    
      <li>
        <a href="https://zhuanlan.zhihu.com/p/457005511">https://zhuanlan.zhihu.com/p/457005511</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/692546/">https://lwn.net/Articles/692546/</a>
      </li>
    
      <li>
        <a href="https://www.kernel.org/doc/html/latest/filesystems/autofs.html">https://www.kernel.org/doc/html/latest/filesystems/autofs.html</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/444910/">https://lwn.net/Articles/444910/</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/446317/">https://lwn.net/Articles/446317/</a>
      </li>
    
      <li>
        <a href="https://github.com/torvalds/linux/commit/85c7f81041d57cfe9dc97f4680d5586b54534a39">https://github.com/torvalds/linux/commit/85c7f81041d57cfe9dc97f4680d5586b54534a39</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/510280/">https://lwn.net/Articles/510280/</a>
      </li>
    
      <li>
        <a href="https://github.com/torvalds/linux/commit/ceb5bdc2d246f6d81cf61ed70f325308a11821d2">https://github.com/torvalds/linux/commit/ceb5bdc2d246f6d81cf61ed70f325308a11821d2</a>
      </li>
    
      <li>
        <a href="https://linux-kernel.vger.kernel.narkive.com/qQlGC986/rfc-0-4-generic-hashtable-implementation">https://linux-kernel.vger.kernel.narkive.com/qQlGC986/rfc-0-4-generic-hashtable-implementation</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/565734/">https://lwn.net/Articles/565734/</a>
      </li>
    
      <li>
        <a href="https://kernelnewbies.org/Linux_3.12#New_lockref_locking_scheme.2C_VFS_locking_improvements">https://kernelnewbies.org/Linux_3.12#New_lockref_locking_scheme.2C_VFS_locking_improvements</a>
      </li>
    
      <li>
        <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bc08b449ee14ace4d869adaa1bb35a44ce68d775">https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bc08b449ee14ace4d869adaa1bb35a44ce68d775</a>
      </li>
    
      <li>
        <a href="https://www.clear.rice.edu/comp422/lecture-notes/linuxcon-2014-locking-jmc.pdf">https://www.clear.rice.edu/comp422/lecture-notes/linuxcon-2014-locking-jmc.pdf</a>
      </li>
    
      <li>
        <a href="https://cloud.tencent.com/developer/article/2146041">https://cloud.tencent.com/developer/article/2146041</a>
      </li>
    
      <li>
        <a href="https://students.mimuw.edu.pl/ZSO/Wyklady/09_VFS2/VFS-2.pdf">https://students.mimuw.edu.pl/ZSO/Wyklady/09_VFS2/VFS-2.pdf</a>
      </li>
    
      <li>
        <a href="https://lwn.net/Articles/784124/">https://lwn.net/Articles/784124/</a>
      </li>
    
      <li>
        <a href="https://lore.kernel.org/all/1460768127-31822-11-git-send-email-viro@ZenIV.linux.org.uk/">https://lore.kernel.org/all/1460768127-31822-11-git-send-email-viro@ZenIV.linux.org.uk/</a>
      </li>
    
      <li>
        <a href="https://lore.kernel.org/all/1460768127-31822-12-git-send-email-viro@ZenIV.linux.org.uk/">https://lore.kernel.org/all/1460768127-31822-12-git-send-email-viro@ZenIV.linux.org.uk/</a>
      </li>
    
      <li>
        <a href="https://github.com/torvalds/linux/commit/94bdd655caba2080ae81d83d756d325abdffcb9f">https://github.com/torvalds/linux/commit/94bdd655caba2080ae81d83d756d325abdffcb9f</a>
      </li>
    
      <li>
        <a href="https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#struct-path-root">https://www.kernel.org/doc/html/latest/filesystems/path-lookup.html#struct-path-root</a>
      </li>
    
  </ul>


        


        
        
        
        
        
        
        
      </footer>
    </article>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css"
    integrity="sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0" crossorigin="anonymous">
  
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"
    integrity="sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body,
      {
        delimiters: [
          {left: '$$', right: '$$', display:true},
          {left: '$', right: '$', display:false},
          {left: '\\(', right: '\\)', display: false},
          {left: '\\[', right: '\\]', display: true}
        ]
      }
    );"></script><style>
  .katex {
    direction: ltr;
    display: inline-flex;
    flex-direction: row-reverse;
    unicode-bidi: embed;
  }
</style>
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2025
     Michael Shalitin 
    ·
    
    מופעל על ידי <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  
<script defer src='https://static.cloudflareinsights.com/beacon.min.js'
        data-cf-beacon='{"token": "316bf5f2576c4cb68b54c0b2a91cb739"}'></script>



  

  

  

  

  

  

  

  

  

  

  

  
</body>
</html>
